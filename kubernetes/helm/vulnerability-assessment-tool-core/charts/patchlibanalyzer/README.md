# Patchlibanalyzer

> This chart is already included in the vulnerability-assessment-tool-core chart

The patch library analyzer is a Java application that establishes whether a library contains a construct modified to fix a vulnerability (aka changed-construct) in its vulnerable or fixed version. The core idea of the patch lib analyzer is to compare the abstract syntax tree (AST) of the body of the changed-construct contained in a library with the AST of its vulnerable and fixed version. However, the biggest obstacle is that vulnerability fixes are applied on source code whereas library releases imported within applications are binaries. The patch lib analyzer overcomes this issue by retrieving the source code of binaries (if available) from Maven repositories (e.g. Maven Central or organization's specific Nexus repositories).

## Prerequisites
-   Kubernetes >=v1.15.0 with Beta APIs enabled
-   Persistent volume provisioner support in underlying infrastructure

## Installing the chart
To install the chart with the release name `release`:
```console
$ helm install release .
```

The command deploys the patchlibanalyzer subchart of the vulnerability-assessment-tool-core chart v0.1.1 chart
on the Kubernetes cluster in the default configuration. The configuration section lists
the parameters that can be configured during installation.

## Uninstalling the chart
To uninstall/delete the `release` deployment:
```console
$ helm delete release
```

## Configuration
The following table lists the configurable parameters of the patchlibanalyzer chart and their default values.

| Parameter | Description | Default |
| --- | --- | --- |
| deployment.enabled | If set to `true` creates a deployment, if set to `False` creates a cronJob | `False` |
| cronJob.period | Defaults to `23h` | `{}` |
| replicas | For HA `2` or `3` replicas are recommended (only applied if set to deployment) | `3` |
| startUpDelay |  | `5` |
| backoffDuration | delay between probe attempts for init containers | `5` |
| debug | Sets the debug level for scripts | `true` |
| horizontalPodAutoScaler.enabled | Enables an autoscaling (requires a metrics server up and running) | `False` |
| image.initContainer.name |  | `postgres` |
| image.initContainer.tag | | `11.5-alpine` |
| image.mainContainer.pullPolicy | These images are maintained by the team and won't be subject to drift | `IfNotPresent` |
| image.mainContainer.name |  | `eclipse/steady-patch-lib-analyzer` |
| image.mainContainer.tag | image tag | `3.2.0-jib` |

## Production configuration
This chart includes a `values_production.yaml` file where you can find some parameters oriented to production configuration in comparison to the regular `values.yaml`.
```sh
$ helm install { custom release name }  -f values_production.yaml .
```
These values can be configured as follows:

| Parameter | Description | Default |
| --- | --- | --- |
| cronJob.period | Defaults to `23h` | `{}` |
| image.initContainer.securityContext |  | runAsUser: `65534`<br>runAsGroup: `65534`<br>privileged: `False`<br>readOnlyRootFilesystem: `False`<br>capabilities:<br>&emsp;drop: `["ALL"]` <br>&emsp;add: `["SYS_TIME", "NET_ADMIN"]` |
| image.mainContainer.securityContext |  | runAsUser: `65534`<br>runAsGroup: `65534`<br>privileged: `False`<br>readOnlyRootFilesystem: `False`<br>capabilities:<br>&emsp;drop: `["ALL"]` <br>&emsp;add: `["DAC_OVERRIDE","SYS_TIME", "NET_ADMIN"]` |
| image.initContainer.resources |  | requests:<br>&emsp;memory:`1Gi`<br>&emsp;cpu: `500m`<br>limit:<br>&emsp;memory: `4Gi`<br>&emsp;cpu: `1000m` |
| persistentVolume.storage | storage size for PVC | `1Gi` |
| persistentVolume.mountPath | PVC mountpath | `/patcheval-data` |
| persistentVolume.nfs.server | nfs server IP | `{}` |
| persistentVolume.nfs.path | nfs server shared path | `{}` |
|  livenessProbe |  | enabled: `true`<br>initialDelaySeconds: `30`<br>periodSeconds: `20`<br>timeoutSeconds: `5`<br>failureThreshold: `5` |


### Chosing between deployments and cronjob:

As set previously this chart can either deploy the patchlibanalyzer as a cronjob or as a deployment. When set to a deployment, the java application automatically configures itself ats a cronjob, the main benefit of this approach being the persistence of the cache between scans. *note*: As the application is not suited for parallel execution, a deployment with n replicas would have the same efficiency as a chart with 1 replicas. On the other hand if you have an nfs, a cronjob is recommended due to its light footprint (only launched when the execution is required).

To chose a deployment over a cronjob
```diff
- deployment.enabled: False
+ deployment.enabled: true
```
