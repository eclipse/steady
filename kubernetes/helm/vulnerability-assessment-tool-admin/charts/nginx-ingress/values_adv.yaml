
metrics:
  enabled: true

rbac:
  # This would create clusterrole and roles required for nginx ingress controller
  # to perform operations accross three namespaces : vulas-core, vulas-admin,
  # and vulas-monitoring
  create: true

defaultBackend:
  enabled: true

  # Suggestion : ~= 1 (returns 404 so useless to duplicate)
  replicas: 1

  selfAntiAffinity:
    soft: true
    weight: 100

  podDisruptionBudget:
    minAvailable: 1

  image:
    pullPolicy: "IfNotPresent"
    registry: {}
    registryPort: {}
    name: "nginx"
    tag: "1.17.4-alpine"
    runAsUser: 101

    resources:
      limits:
        memory: "60Mi"
        cpu: "110m"
      requests:
        memory: "50Mi"
        cpu: "100m"

  livenessProbe:
    enabled: true
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    enabled: true
    initialDelaySeconds: 0
    periodSeconds: 5
    timeoutSeconds: 5
    failureThreshold: 6

ingressController:
  authIngress:
    # This enables basic auth access to (if present) kibana, frontendbugs, prometheus
    enabled: true
    credentials:
      # These credentials are generated and encrypted with htpasswd with a
      # poststart helm hook named `nginx-ingress-secret-generator` which
      # communicates with the kubernetes API to modify the corresponding secret
      user: vulas
      password: vulas

  # Suggestion : ~= Depending on load
  # (kubernetes/nginx-ingress controller has internal distribution
  # mechanisms such as elections so it can handle it)
  replicas: 3

  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1

  # Possible values are listed in NGINX's error_log config documentation
  # (see http://nginx.org/en/docs/ngx_core_module.html#error_log)
  debugLevel: error
  external: true
  externalIP: {}
  electionID: ingress-controller-leader
  ingressClass: nginx
  # If rbac is set to {} no clusterrole, role and rolebinding
  # will be created to link up to the desired service account
  rbac: true

  selfAntiAffinity:
    # You can set selfAntiAffinity to {} in order to skip
    # all affinity declarations
    soft: true
    weight: 100

  podDisruptionBudget:
    minAvailable: 1

  persistentVolume:
    storage: "1Gi"
    storageG: "1g"
    mountPath: /tmp/nginx-cache/

    cache:
      enabled: true
    # nfs:
    #   server: ::
    #   path: /share

  image:
    pullPolicy: "IfNotPresent"
    registry: "quay.io"
    registryPort: {}
    name: "kubernetes-ingress-controller/nginx-ingress-controller"
    tag: "0.25.0"
    runAsUser: 33
    allowPrivilegeEscalation: true

    resources:
      limits:
        memory: "500Mi"
        cpu: "500m"
      requests:
        memory: "150Mi"
        cpu: "80m"

  livenessProbe:
    # Overall time before container is considered unready by k8s :
    # initialDelaySeconds + ((periodSeconds + timeoutSeconds) * successThreshold)
    # = 510s ~= 8.5min
    enabled: true
    initialDelaySeconds: 15
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 10
    successThreshold: 1

  readinessProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 60
    timeoutSeconds: 5
    failureThreshold: 10
    successThreshold: 2
    path: /healthz
