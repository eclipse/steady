{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"vulnerability-assessment-tool \u00b6 General What is vulnerability-assessment-tool? Users Quick start Frequently Asked Questions/Troubleshooting User Manual Get support Admins Operating your own vulnerability-assessment-tool servers Vulnerabilities Learn about vulnerability-assessment-tool's vulnerability database","title":"Home"},{"location":"#vulnerability-assessment-tool","text":"General What is vulnerability-assessment-tool? Users Quick start Frequently Asked Questions/Troubleshooting User Manual Get support Admins Operating your own vulnerability-assessment-tool servers Vulnerabilities Learn about vulnerability-assessment-tool's vulnerability database","title":"vulnerability-assessment-tool"},{"location":"about/","text":"About \u00b6 vulnerability-assessment-tool analyzes Java and Python applications in order to: detect whether they depend on open-source components with known vulnerabilities, collect evidence of the execution of vulnerable code in a given application context (through a novel combination of static and dynamic analysis), and support developers in the mitigation of such vulnerable dependencies. vulnerability-assessment-tool addresses the OWASP Top 10 security risk A9, Using Components with Known Vulnerabilities . Differently from other tools that have similar goals, the detection approach of vulnerability-assessment-tool is code-centric and usage-based , which allows for a more accurate detection and assessment than tools relying on meta-data. vulnerability-assessment-tool is implemented as a collection of client-side tools (for Java and Python), server-side RESTful services and several Web frontends. Initially developed by SAP Security Research , vulnerability-assessment-tool was adopted internally by SAP as early as 2015. The tool has been open-sourced in October 2018 under the Apache License v.2.0. The approach implemented in vulnerability-assessment-tool is described in detail in the the following scientific papers: Serena Ponta, Henrik Plate, Antonino Sabetta, Beyond Metadata: Code-centric and Usage-based Analysis of Known Vulnerabilities in Open-source Software , 34 th International Conference on Software Maintenance and Evolution (ICSME), 2018 (recipient of the IEEE TCSE Distinguished Paper Award) Henrik Plate, Serena Ponta, Antonino Sabetta, Impact Assessment for Vulnerabilities in Open-Source Software Libraries , 31 st International Conference on Software Maintenance and Evolution (ICSME), 2015 The Team \u00b6 Henrik Plate (SAP Security Research) Serena E. Ponta (SAP Security Research) Antonino Sabetta (SAP Security Research) C\u00e9dric Dangremont (SAP Security Testing and Validation) Alessandro Pezz\u00e9 (SAP Security Testing and Validation)","title":"About"},{"location":"about/#about","text":"vulnerability-assessment-tool analyzes Java and Python applications in order to: detect whether they depend on open-source components with known vulnerabilities, collect evidence of the execution of vulnerable code in a given application context (through a novel combination of static and dynamic analysis), and support developers in the mitigation of such vulnerable dependencies. vulnerability-assessment-tool addresses the OWASP Top 10 security risk A9, Using Components with Known Vulnerabilities . Differently from other tools that have similar goals, the detection approach of vulnerability-assessment-tool is code-centric and usage-based , which allows for a more accurate detection and assessment than tools relying on meta-data. vulnerability-assessment-tool is implemented as a collection of client-side tools (for Java and Python), server-side RESTful services and several Web frontends. Initially developed by SAP Security Research , vulnerability-assessment-tool was adopted internally by SAP as early as 2015. The tool has been open-sourced in October 2018 under the Apache License v.2.0. The approach implemented in vulnerability-assessment-tool is described in detail in the the following scientific papers: Serena Ponta, Henrik Plate, Antonino Sabetta, Beyond Metadata: Code-centric and Usage-based Analysis of Known Vulnerabilities in Open-source Software , 34 th International Conference on Software Maintenance and Evolution (ICSME), 2018 (recipient of the IEEE TCSE Distinguished Paper Award) Henrik Plate, Serena Ponta, Antonino Sabetta, Impact Assessment for Vulnerabilities in Open-Source Software Libraries , 31 st International Conference on Software Maintenance and Evolution (ICSME), 2015","title":"About"},{"location":"about/#the-team","text":"Henrik Plate (SAP Security Research) Serena E. Ponta (SAP Security Research) Antonino Sabetta (SAP Security Research) C\u00e9dric Dangremont (SAP Security Testing and Validation) Alessandro Pezz\u00e9 (SAP Security Testing and Validation)","title":"The Team"},{"location":"admin/","text":"DevOps \u00b6 vulnerability-assessment-tool is meant to run within the internal network of software development organizations, and this tutorial is meant to facilitate the operation of vulnerability-assessment-tool using local Docker repositories or local container orchestration systems (e.g., Kubernetes or OpenShift). Important : Due to the current lack of an authorization concept, we do not advise to expose an instance of vulnerability-assessment-tool to the Internet. Deploy on Docker and Import the knowledge base Build JAVA archives and local Docker images Push Docker images to a registry Deploy on Kubernetes with Kustomize Deploy on Kubernetes with Helm Miscellaneous information \u00b6 Kubernetes resource requirements","title":"DevOps"},{"location":"admin/#devops","text":"vulnerability-assessment-tool is meant to run within the internal network of software development organizations, and this tutorial is meant to facilitate the operation of vulnerability-assessment-tool using local Docker repositories or local container orchestration systems (e.g., Kubernetes or OpenShift). Important : Due to the current lack of an authorization concept, we do not advise to expose an instance of vulnerability-assessment-tool to the Internet. Deploy on Docker and Import the knowledge base Build JAVA archives and local Docker images Push Docker images to a registry Deploy on Kubernetes with Kustomize Deploy on Kubernetes with Helm","title":"DevOps"},{"location":"admin/#miscellaneous-information","text":"Kubernetes resource requirements","title":"Miscellaneous information"},{"location":"admin/manuals/","text":"","title":"Home"},{"location":"admin/support/faq/","text":"","title":"Faq"},{"location":"admin/support/getting_help/","text":"","title":"Getting help"},{"location":"admin/tutorials/build/","text":"Building Docker images from source \u00b6 Pre-requisites \u00b6 git docker docker-compose Customization \u00b6 All the following commands are supposed to be executed from the root folder of the project. If you want to build images specific to a version you can checkout a stable version of Vulas. Usually the master branch holds a -SNAPSHOT version. git checkout tags/3.1.6 Make a copy of the sample configuration: cp docker/.env.sample docker/.env Customize the file docker/.env to match your needs, make sure you set the version you want to build in VULAS_RELEASE. In docker/.env you must configure at least POSTGRES_USER= , you should also configure the HAPROXY 's user and password as well as the credentials to access the bugs' frontend Generate JAVA archives \u00b6 At this point, you are ready to build the JAR/WAR artifacts with the following command: docker build --tag vulnerability-assessment-tool-generator:3.1.6 -f docker/Dockerfile . docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = -DskipTests vulnerability-assessment-tool-generator:3.1.6 If the command above fails, add -DreuseForks=False flag to mvn_flags . As shown in the example below. docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = '-DskipTests -DreuseForks=False' vulnerability-assessment-tool-generator:3.1.6 In case you are running behind a proxy you need to configure it in the --build-arg arguments. Check the predefined ARG s documentation to know more. As a result, the folders docker/<component-name> will contain compiled JARs (or WARs, depending on the component). The folder docker/client-tools will be populated with the JARs for client side tools (CLI, plugins, patchanalyzer). Additionally, you may want to make the artifacts available to the developers of your organization (e.g., through an internal Nexus or other artifact distribution system). Generate Docker images \u00b6 You are now ready to run the system with the generated archives and create the Docker images: ( cd docker && docker-compose -f docker-compose.build.yml build ) You can create and run containers from the generated images. ( cd docker && docker-compose -f docker-compose.yml -f docker-compose.build.yml up -d ) To check everything started successfully, browse the page http://localhost:8033/haproxy?stats . All endpoints should appear as green. username and password can be found in your .env file, be also advised that rest-backend could take more than 30 seconds to be ready to answer HTTP requests Get going: Push the images you have built to a private Docker registry Deploy vulnerability-assessment-tool locally with Docker","title":"Build JAVA archives/Docker images"},{"location":"admin/tutorials/build/#building-docker-images-from-source","text":"","title":"Building Docker images from source"},{"location":"admin/tutorials/build/#pre-requisites","text":"git docker docker-compose","title":"Pre-requisites"},{"location":"admin/tutorials/build/#customization","text":"All the following commands are supposed to be executed from the root folder of the project. If you want to build images specific to a version you can checkout a stable version of Vulas. Usually the master branch holds a -SNAPSHOT version. git checkout tags/3.1.6 Make a copy of the sample configuration: cp docker/.env.sample docker/.env Customize the file docker/.env to match your needs, make sure you set the version you want to build in VULAS_RELEASE. In docker/.env you must configure at least POSTGRES_USER= , you should also configure the HAPROXY 's user and password as well as the credentials to access the bugs' frontend","title":"Customization"},{"location":"admin/tutorials/build/#generate-java-archives","text":"At this point, you are ready to build the JAR/WAR artifacts with the following command: docker build --tag vulnerability-assessment-tool-generator:3.1.6 -f docker/Dockerfile . docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = -DskipTests vulnerability-assessment-tool-generator:3.1.6 If the command above fails, add -DreuseForks=False flag to mvn_flags . As shown in the example below. docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = '-DskipTests -DreuseForks=False' vulnerability-assessment-tool-generator:3.1.6 In case you are running behind a proxy you need to configure it in the --build-arg arguments. Check the predefined ARG s documentation to know more. As a result, the folders docker/<component-name> will contain compiled JARs (or WARs, depending on the component). The folder docker/client-tools will be populated with the JARs for client side tools (CLI, plugins, patchanalyzer). Additionally, you may want to make the artifacts available to the developers of your organization (e.g., through an internal Nexus or other artifact distribution system).","title":"Generate JAVA archives"},{"location":"admin/tutorials/build/#generate-docker-images","text":"You are now ready to run the system with the generated archives and create the Docker images: ( cd docker && docker-compose -f docker-compose.build.yml build ) You can create and run containers from the generated images. ( cd docker && docker-compose -f docker-compose.yml -f docker-compose.build.yml up -d ) To check everything started successfully, browse the page http://localhost:8033/haproxy?stats . All endpoints should appear as green. username and password can be found in your .env file, be also advised that rest-backend could take more than 30 seconds to be ready to answer HTTP requests Get going: Push the images you have built to a private Docker registry Deploy vulnerability-assessment-tool locally with Docker","title":"Generate Docker images"},{"location":"admin/tutorials/docker/","text":"Deploy on Docker \u00b6 In this tutorial you will be guided through the necessary steps to set-up the vulnerability-assessment-tool backend services. Important Remark The setup obtained following these instructions is meant for demonstration purposes. It shall not be used in productive scenarios (both for security and scalability concerns). Pre-requisites \u00b6 git docker docker-compose Installation \u00b6 Setup \u00b6 Clone locally the vulnerability-assessment-tool repository git clone https://github.com/SAP/vulnerability-assessment-tool Customize the file docker/.env to match your needs, make sure you set the version you want to run in VULAS_RELEASE. cp docker/.env.sample docker/.env In docker/.env you must configure at least POSTGRES_USER= , you should also configure the HAPROXY 's user and password as well as the credentials to access the bugs' frontend Run \u00b6 You are now ready to run the system: ( cd docker && docker-compose up -d --build ) To check if everything started successfully, check the page http://localhost:8033/haproxy?stats . All endpoints should appear as green (you may want to replace localhost with the actual hostname of your machine). Credentials and start up time username and password can be found in your .env file, be also advised that rest-backend could take more than 30 seconds to be available to answer HTTP requests Populate/maintain the vulnerability database \u00b6 In order for the tool to detect vulnerabilities, you need to import and analyze them first so that they are available in the tool's vulnerability database. Large part of CVE's and bugs are open sourced in vulnerability-assessment-kb . Follow the instructions mentioned here , to import and build all the vulnerabilities' knowledge. Get going: Import all the CVEs and bugs in your local database Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"Deploy on Docker"},{"location":"admin/tutorials/docker/#deploy-on-docker","text":"In this tutorial you will be guided through the necessary steps to set-up the vulnerability-assessment-tool backend services. Important Remark The setup obtained following these instructions is meant for demonstration purposes. It shall not be used in productive scenarios (both for security and scalability concerns).","title":"Deploy on Docker"},{"location":"admin/tutorials/docker/#pre-requisites","text":"git docker docker-compose","title":"Pre-requisites"},{"location":"admin/tutorials/docker/#installation","text":"","title":"Installation"},{"location":"admin/tutorials/docker/#setup","text":"Clone locally the vulnerability-assessment-tool repository git clone https://github.com/SAP/vulnerability-assessment-tool Customize the file docker/.env to match your needs, make sure you set the version you want to run in VULAS_RELEASE. cp docker/.env.sample docker/.env In docker/.env you must configure at least POSTGRES_USER= , you should also configure the HAPROXY 's user and password as well as the credentials to access the bugs' frontend","title":"Setup"},{"location":"admin/tutorials/docker/#run","text":"You are now ready to run the system: ( cd docker && docker-compose up -d --build ) To check if everything started successfully, check the page http://localhost:8033/haproxy?stats . All endpoints should appear as green (you may want to replace localhost with the actual hostname of your machine). Credentials and start up time username and password can be found in your .env file, be also advised that rest-backend could take more than 30 seconds to be available to answer HTTP requests","title":"Run"},{"location":"admin/tutorials/docker/#populatemaintain-the-vulnerability-database","text":"In order for the tool to detect vulnerabilities, you need to import and analyze them first so that they are available in the tool's vulnerability database. Large part of CVE's and bugs are open sourced in vulnerability-assessment-kb . Follow the instructions mentioned here , to import and build all the vulnerabilities' knowledge. Get going: Import all the CVEs and bugs in your local database Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"Populate/maintain the vulnerability database"},{"location":"admin/tutorials/helm/","text":"Deploy on Kubernetes with Helm \u00b6 In this tutorial you will be guided through the necessary steps to set-up the vulnerability-assessment-tool services in a Kubernetes cluster using Helm version 3.0.0-beta4 and is compatible with any helm2 version 2.15.0 . Helm2 and Helm3 Helm2 has officially gone into maintenance mode (no further release after 2.15.0) but this chart is meant to be compatible with both major versions of Helm. The main difference being that in helm 3 tiller is no longer required and all charts are namespaced. Pre-requisites \u00b6 git Helm Kubernetes >=v1.15.0 with Beta APIs enabled Setup \u00b6 This repository contains three charts: vulnerability-assessment-tool-core : which encapsulates all the core components of the tool vulnerability-assessment-tool-admin : which encapsulates all the cluster admin tools (namely the ingress controller to expose the service) vulnerability-assessment-tool-monitoring : which is used to deploy the dedicated monitoring stack Clone locally vulnerability-assessment-tool repository and change the directory to the Helm chart's folder git clone https://github.com/SAP/vulnerability-assessment-tool cd vulnerability-assessment-tool/kubernetes/helm Modify the values.yaml files and edit them to match your needs. In order to verify the validity of your values and get a preview of your generated chart: helm template vulnerability-assessment-tool-core helm template vulnerability-assessment-tool-admin helm template vulnerability-assessment-tool-monitoring Run \u00b6 You are now ready to deploy vulnerability-assessment-tool inside your Kubernetes cluster: Vulnerability-assessment-tool-core chart \u00b6 # For helm 2 helm install vulnerability-assessment-tool-core/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-core ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-core (which can be specified in the vulnerability-assessment-tool-core/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-core . The deployment will request a couple PersistentVolumeClaims which could need some time to be created depending on the cloud provider you are running on. Vulnerability-assessment-tool-monitoring chart \u00b6 # For helm 2 helm install vulnerability-assessment-tool-monitoring/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-monitoring ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-monitoring (which can be specified in the vulnerability-assessment-tool-monitoring/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-monitoring . The deployment will request a couple PersistentVolumeClaims which could need some time to be created depending on the cloud provider you are running on. Monitoring scope This chart's monitoring is not scoped to any namespace so you can add other pods to be monitored simply by adding prometheus.io/scrape: \"true\" in the correct pod annotation and in which ever namespace you desire. Vulnerability-assessment-tool-admin chart \u00b6 # For helm 2 helm install vulnerability-assessment-tool-admin/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-admin ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-admin (which can be specified in the vulnerability-assessment-tool-admin/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-admin . The deployment will request a LoadBalancer which could need some time to be created depending on the cloud provider you are running on. Reaching vulnerability-assessment-tool from the Internet This chart creates a LoadBalancer to allow Internet traffic to reach the cluster provisioned by your provider and will connect to it. This LoadBalancer will be exposed on the Internet so be careful to change the authentication ingress values from the default ones. The Service type:LoadBalancer should work with most providers such as GKE, Azure. If not, you can follow this ingress-nginx guide","title":"Deploy on Kubernetes with Helm"},{"location":"admin/tutorials/helm/#deploy-on-kubernetes-with-helm","text":"In this tutorial you will be guided through the necessary steps to set-up the vulnerability-assessment-tool services in a Kubernetes cluster using Helm version 3.0.0-beta4 and is compatible with any helm2 version 2.15.0 . Helm2 and Helm3 Helm2 has officially gone into maintenance mode (no further release after 2.15.0) but this chart is meant to be compatible with both major versions of Helm. The main difference being that in helm 3 tiller is no longer required and all charts are namespaced.","title":"Deploy on Kubernetes with Helm"},{"location":"admin/tutorials/helm/#pre-requisites","text":"git Helm Kubernetes >=v1.15.0 with Beta APIs enabled","title":"Pre-requisites"},{"location":"admin/tutorials/helm/#setup","text":"This repository contains three charts: vulnerability-assessment-tool-core : which encapsulates all the core components of the tool vulnerability-assessment-tool-admin : which encapsulates all the cluster admin tools (namely the ingress controller to expose the service) vulnerability-assessment-tool-monitoring : which is used to deploy the dedicated monitoring stack Clone locally vulnerability-assessment-tool repository and change the directory to the Helm chart's folder git clone https://github.com/SAP/vulnerability-assessment-tool cd vulnerability-assessment-tool/kubernetes/helm Modify the values.yaml files and edit them to match your needs. In order to verify the validity of your values and get a preview of your generated chart: helm template vulnerability-assessment-tool-core helm template vulnerability-assessment-tool-admin helm template vulnerability-assessment-tool-monitoring","title":"Setup"},{"location":"admin/tutorials/helm/#run","text":"You are now ready to deploy vulnerability-assessment-tool inside your Kubernetes cluster:","title":"Run"},{"location":"admin/tutorials/helm/#vulnerability-assessment-tool-core-chart","text":"# For helm 2 helm install vulnerability-assessment-tool-core/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-core ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-core (which can be specified in the vulnerability-assessment-tool-core/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-core . The deployment will request a couple PersistentVolumeClaims which could need some time to be created depending on the cloud provider you are running on.","title":"Vulnerability-assessment-tool-core chart"},{"location":"admin/tutorials/helm/#vulnerability-assessment-tool-monitoring-chart","text":"# For helm 2 helm install vulnerability-assessment-tool-monitoring/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-monitoring ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-monitoring (which can be specified in the vulnerability-assessment-tool-monitoring/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-monitoring . The deployment will request a couple PersistentVolumeClaims which could need some time to be created depending on the cloud provider you are running on. Monitoring scope This chart's monitoring is not scoped to any namespace so you can add other pods to be monitored simply by adding prometheus.io/scrape: \"true\" in the correct pod annotation and in which ever namespace you desire.","title":"Vulnerability-assessment-tool-monitoring chart"},{"location":"admin/tutorials/helm/#vulnerability-assessment-tool-admin-chart","text":"# For helm 2 helm install vulnerability-assessment-tool-admin/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-admin ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-admin (which can be specified in the vulnerability-assessment-tool-admin/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-admin . The deployment will request a LoadBalancer which could need some time to be created depending on the cloud provider you are running on. Reaching vulnerability-assessment-tool from the Internet This chart creates a LoadBalancer to allow Internet traffic to reach the cluster provisioned by your provider and will connect to it. This LoadBalancer will be exposed on the Internet so be careful to change the authentication ingress values from the default ones. The Service type:LoadBalancer should work with most providers such as GKE, Azure. If not, you can follow this ingress-nginx guide","title":"Vulnerability-assessment-tool-admin chart"},{"location":"admin/tutorials/kubernetes_resources/","text":"Operational requirements \u00b6 The following document is meant to summarize the vulnerability-assessment-tool requirements when it comes to running it on the Kubernetes architecture. This will detail its operational cost for a couple of scenarios: Lightweight : the cluster is instantiated with no prior scan and data, then, the bugs are loaded using the patch-analyzer. This deployment is not destined for high availability or resilience (therefore with less replicas, no auto-scaling) and is optimal for small testing environments with a 6 month usage buffer. Lightweight HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Medium Load : the cluster is instantiated with no prior scan and data, then, the bugs are loaded using the patch-analyzer. This deployment is not destined for high availability or resilience (therefore with less replicas, no auto-scaling) and is optimal for small production environments with a 2 year buffer. Medium Load HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Production Load : the cluster is loaded with the latest dump of the internal SAP vulnerability-assessment-tool database (which at the time of this document creation is around 249GB). This deployment is not destined for high availability or resilience and is optimal for production environments with a 3-5 year usage buffer. This data load includes app specific data (once those are removed, the database size is around 150GB in our current setup) Production Load HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Extra PVC : this use case is destined towards optimizing certain components of the vulnerability-assessment-tool which require read write many volumes (in particular rest-lib-utils ) Hosted DB : for using a pre-existing database (for cloud providers such as GCP, AWS, Azure, etc...) which require lower resources as the database are no longer self managed. CPU request CPU Limit Memory Request (GiB) Memory Limit (GiB) PV (GiB) Lightweight 8.5 17.1 12.5 25.6 30 Lightweight HA 17.6 35.2 30.5 61.2 90 Lightweight HA (with extra PVC) 17.6 35.2 30.5 61.2 102 Medium Load 16.5 33.1 24.5 49.6 50 Medium Load HA 30.2 60.7 51.7 102.7 150 Medium Load HA (with extra PVC) 30.2 60.7 51.7 102.7 195 Production Load 40.7 57.6 57.2 92.6 400 Production Load HA 107.9 160.2 159.4 262.2 1200 Production Load HA (with extra PVC) 107.9 160.2 159.4 262.2 1380 Lightweight HA (hosted db) 8.7 17.7 16.7 34.2 90 Medium Load HA (hosted db) 16.7 33.7 32.7 66.2 150 Production Load HA (hosted db) 48.9 98.2 97.4 197.2 1200 In-depth break down of resource requirements \u00b6 Frontendapps replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 0.1 0.3 0.1 0.3 0 lightweight_ha 2 0.1 0.3 0.1 0.3 0 lightweight_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 medium_load 1 0.1 0.3 0.1 0.3 0 medium_load_ha 2 0.1 0.3 0.1 0.3 0 medium_load_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 prod_load 1 0.1 0.3 0.1 0.3 0 prod_load_ha 2 0.1 0.3 0.1 0.3 0 prod_load_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 lightweight_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 medium_load_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 prod_load_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 Frontendbugs replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 0.1 0.3 0.1 0.3 0 lightweight_ha 2 0.1 0.3 0.1 0.3 0 lightweight_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 medium_load 1 0.1 0.3 0.1 0.3 0 medium_load_ha 2 0.1 0.3 0.1 0.3 0 medium_load_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 prod_load 1 0.1 0.3 0.1 0.3 0 prod_load_ha 2 0.1 0.3 0.1 0.3 0 prod_load_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 lightweight_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 medium_load_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 prod_load_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 Patch-lib-analyzer replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 0.3 0.5 0.3 1 0 lightweight_ha 2 0.3 0.5 0.3 1 0 lightweight_ha_extra_pvc 2 0.3 0.5 0.3 1 2 medium_load 1 0.3 0.5 0.3 1 0 medium_load_ha 2 0.3 0.5 0.3 1 0 medium_load_ha_extra_pvc 2 0.3 0.5 0.3 1 5 prod_load 1 0.5 1 1 4 0 prod_load_ha 2 0.5 1 1 4 30 prod_load_ha_extra_pvc 2 0.5 1 1 4 0 lightweight_ha_hosted_db 2 0.3 0.5 0.3 1 0 medium_load_ha_hosted_db 2 0.3 0.5 0.3 1 0 prod_load_ha_hosted_db 2 0.5 1 1 0.3 0 Rest-lib-utils replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 2 4 4 8 0 lightweight_ha 2 2 4 4 8 0 lightweight_ha_extra_pvc 2 2 4 4 8 5 medium_load 1 4 8 8 16 0 medium_load_ha 2 4 8 8 16 0 medium_load_ha_extra_pvc 2 4 8 8 16 20 prod_load 1 8 16 16 32 0 prod_load_ha 3 8 16 16 32 0 prod_load_ha_extra_pvc 3 8 16 16 32 50 lightweight_ha_hosted_db 2 2 4 4 8 0 medium_load_ha_hosted_db 2 4 8 8 16 0 prod_load_ha_hosted_db 3 8 16 16 32 0 Rest-backend replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 2 4 4 8 0 lightweight_ha 2 2 4 4 8 0 lightweight_ha_extra_pvc 2 2 4 4 8 0 medium_load 1 4 8 8 16 0 medium_load_ha 2 4 8 8 16 0 medium_load_ha_extra_pvc 2 4 8 8 16 0 prod_load 1 8 16 16 32 0 prod_load_ha 3 8 16 16 32 0 prod_load_ha_extra_pvc 3 8 16 16 32 0 lightweight_ha_hosted_db 2 2 4 4 8 0 medium_load_ha_hosted_db 2 4 8 8 16 0 prod_load_ha_hosted_db 3 8 16 16 32 0 Postgres master replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 4 8 4 8 30 lightweight_ha 1 4 8 4 8 0 lightweight_ha_extra_pvc 1 4 8 4 8 0 medium_load 1 8 16 8 16 50 medium_load_ha 1 8 16 8 16 50 medium_load_ha_extra_pvc 1 8 16 8 16 50 prod_load 1 24 24 24 24 0 prod_load_ha 1 24 24 24 24 0 prod_load_ha_extra_pvc 1 24 24 24 24 0 lightweight_ha_hosted_db 1 0 0 0 0 30 medium_load_ha_hosted_db 1 0 0 0 0 50 prod_load_ha_hosted_db 1 0 0 0 0 400 Postgres replicas replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 0 0 0 0 0 0 lightweight_ha 2 2 4 4 8 30 lightweight_ha_extra_pvc 2 2 4 4 8 0 medium_load 0 0 0 0 0 0 medium_load_ha 2 2 4 4 8 50 medium_load_ha_extra_pvc 2 2 4 4 8 50 prod_load 0 0 0 0 0 0 prod_load_ha 2 16 16 16 16 400 prod_load_ha_extra_pvc 2 16 16 16 16 400 lightweight_ha_hosted_db 2 0 0 0 0 30 medium_load_ha_hosted_db 2 0 0 0 0 50 prod_load_ha_hosted_db 2 0 0 0 0 400 Pgpool replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 0 0 0 0 0 0 lightweight_ha 3 0.3 0.5 0.6 1 0 lightweight_ha_extra_pvc 3 0.3 0.5 0.6 1 0 medium_load 0 0 0 0 0 0 medium_load_ha 3 0.5 1 1 1.5 0 medium_load_ha_extra_pvc 3 0.5 1 1 1.5 0 prod_load 0 0 0 0 0 0 prod_load_ha 3 1 2 2 3 0 prod_load_ha_extra_pvc 3 1 2 2 3 0 lightweight_ha_hosted_db 0 0 0 0 0 0 medium_load_ha_hosted_db 0 0 0 0 0 0 prod_load_ha_hosted_db 0 0 0 0 0 0","title":"Kubernetes resources requirements"},{"location":"admin/tutorials/kubernetes_resources/#operational-requirements","text":"The following document is meant to summarize the vulnerability-assessment-tool requirements when it comes to running it on the Kubernetes architecture. This will detail its operational cost for a couple of scenarios: Lightweight : the cluster is instantiated with no prior scan and data, then, the bugs are loaded using the patch-analyzer. This deployment is not destined for high availability or resilience (therefore with less replicas, no auto-scaling) and is optimal for small testing environments with a 6 month usage buffer. Lightweight HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Medium Load : the cluster is instantiated with no prior scan and data, then, the bugs are loaded using the patch-analyzer. This deployment is not destined for high availability or resilience (therefore with less replicas, no auto-scaling) and is optimal for small production environments with a 2 year buffer. Medium Load HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Production Load : the cluster is loaded with the latest dump of the internal SAP vulnerability-assessment-tool database (which at the time of this document creation is around 249GB). This deployment is not destined for high availability or resilience and is optimal for production environments with a 3-5 year usage buffer. This data load includes app specific data (once those are removed, the database size is around 150GB in our current setup) Production Load HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Extra PVC : this use case is destined towards optimizing certain components of the vulnerability-assessment-tool which require read write many volumes (in particular rest-lib-utils ) Hosted DB : for using a pre-existing database (for cloud providers such as GCP, AWS, Azure, etc...) which require lower resources as the database are no longer self managed. CPU request CPU Limit Memory Request (GiB) Memory Limit (GiB) PV (GiB) Lightweight 8.5 17.1 12.5 25.6 30 Lightweight HA 17.6 35.2 30.5 61.2 90 Lightweight HA (with extra PVC) 17.6 35.2 30.5 61.2 102 Medium Load 16.5 33.1 24.5 49.6 50 Medium Load HA 30.2 60.7 51.7 102.7 150 Medium Load HA (with extra PVC) 30.2 60.7 51.7 102.7 195 Production Load 40.7 57.6 57.2 92.6 400 Production Load HA 107.9 160.2 159.4 262.2 1200 Production Load HA (with extra PVC) 107.9 160.2 159.4 262.2 1380 Lightweight HA (hosted db) 8.7 17.7 16.7 34.2 90 Medium Load HA (hosted db) 16.7 33.7 32.7 66.2 150 Production Load HA (hosted db) 48.9 98.2 97.4 197.2 1200","title":"Operational requirements"},{"location":"admin/tutorials/kubernetes_resources/#in-depth-break-down-of-resource-requirements","text":"","title":"In-depth break down of resource requirements"},{"location":"admin/tutorials/kustomize/","text":"Deploy on Kubernetes with Kustomize \u00b6 In this tutorial you will be guided through the necessary steps to set-up the vulnerability-assessment-tool backend services in a Kubernetes cluster using Kustomize version 2.0.3 Kustomize and Kubectl kubectl starting version 1.14 already comes with Kustomize 2.0.3 bundled. As of now Kustomize 3.1.0 is not supported by kubectl so it will also not be supported by vulnerability-assessment-tool Pre-requisites \u00b6 git kubectl a Kubernetes cluster Setup \u00b6 Clone locally vulnerability-assessment-tool repository and change the directory to Kustomize's folder git clone https://github.com/SAP/vulnerability-assessment-tool cd vulnerability-assessment-tool/kubernetes/kustomize Make a copy of the files in kubernetes/kustomize/secrets and edit them to match your needs. cp secrets/.env.sample secrets/.env cp secrets/bugs-frontend-credentials.sample secrets/bugs-frontend-credentials # edit the above files Run \u00b6 You are now ready to deploy vulnerability-assessment-tool inside your Kubernetes cluster: kubectl apply -k . The above command will create a Namespace called vulnerability-assessment-tool and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl -n vulnerability-assessment-tool get pods -w . The deployment will request two PersistentVolumeClaims and a Service type:LoadBalancer which could need some time to be created depending on the provider you are running on. Reaching vulnerability-assessment-tool from the Internet vulnerability-assessment-tool uses a Service of type LoadBalancer to allow Internet traffic to reach the cluster. This Service will request an external LoadBalancer to your provider and will connect to it. This LoadBalancer will be exposed on the Internet so be careful. The Service type:LoadBalancer should work with most providers such as GKE, Azure. If not, you can follow this ingress-nginx guide Debugging vulnerability-assessment-tool from the local network You can avoid listening to the Internet by disabling the Service present in the services/cloud.yml file. To disable the file you can just comment the relative line in the root-level kustomization.yaml file. You can then connect to the main Service by port-forward ing with the command kubectl -n vulnerability-assessment-tool port-forward svc/haproxy-ingress 7000:8080 and then opening your browser at localhost:8080/apps Populate/maintain the vulnerability database \u00b6 In order for the tool to detect vulnerabilities, you need to import and analyze them first so that they are available in the tool's vulnerability database. Large part of CVE's and bugs are open sourced in vulnerability-assessment-kb . Follow the instructions mentioned here , to import and build all the vulnerabilities' knowledge. Get going: Import all the CVEs and bugs in your local database Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"Deploy on Kubernetes with Kustomize"},{"location":"admin/tutorials/kustomize/#deploy-on-kubernetes-with-kustomize","text":"In this tutorial you will be guided through the necessary steps to set-up the vulnerability-assessment-tool backend services in a Kubernetes cluster using Kustomize version 2.0.3 Kustomize and Kubectl kubectl starting version 1.14 already comes with Kustomize 2.0.3 bundled. As of now Kustomize 3.1.0 is not supported by kubectl so it will also not be supported by vulnerability-assessment-tool","title":"Deploy on Kubernetes with Kustomize"},{"location":"admin/tutorials/kustomize/#pre-requisites","text":"git kubectl a Kubernetes cluster","title":"Pre-requisites"},{"location":"admin/tutorials/kustomize/#setup","text":"Clone locally vulnerability-assessment-tool repository and change the directory to Kustomize's folder git clone https://github.com/SAP/vulnerability-assessment-tool cd vulnerability-assessment-tool/kubernetes/kustomize Make a copy of the files in kubernetes/kustomize/secrets and edit them to match your needs. cp secrets/.env.sample secrets/.env cp secrets/bugs-frontend-credentials.sample secrets/bugs-frontend-credentials # edit the above files","title":"Setup"},{"location":"admin/tutorials/kustomize/#run","text":"You are now ready to deploy vulnerability-assessment-tool inside your Kubernetes cluster: kubectl apply -k . The above command will create a Namespace called vulnerability-assessment-tool and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl -n vulnerability-assessment-tool get pods -w . The deployment will request two PersistentVolumeClaims and a Service type:LoadBalancer which could need some time to be created depending on the provider you are running on. Reaching vulnerability-assessment-tool from the Internet vulnerability-assessment-tool uses a Service of type LoadBalancer to allow Internet traffic to reach the cluster. This Service will request an external LoadBalancer to your provider and will connect to it. This LoadBalancer will be exposed on the Internet so be careful. The Service type:LoadBalancer should work with most providers such as GKE, Azure. If not, you can follow this ingress-nginx guide Debugging vulnerability-assessment-tool from the local network You can avoid listening to the Internet by disabling the Service present in the services/cloud.yml file. To disable the file you can just comment the relative line in the root-level kustomization.yaml file. You can then connect to the main Service by port-forward ing with the command kubectl -n vulnerability-assessment-tool port-forward svc/haproxy-ingress 7000:8080 and then opening your browser at localhost:8080/apps","title":"Run"},{"location":"admin/tutorials/kustomize/#populatemaintain-the-vulnerability-database","text":"In order for the tool to detect vulnerabilities, you need to import and analyze them first so that they are available in the tool's vulnerability database. Large part of CVE's and bugs are open sourced in vulnerability-assessment-kb . Follow the instructions mentioned here , to import and build all the vulnerabilities' knowledge. Get going: Import all the CVEs and bugs in your local database Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"Populate/maintain the vulnerability database"},{"location":"admin/tutorials/registry/","text":"Push Docker images on a registry \u00b6 Pre-requisites \u00b6 git bash docker docker-compose Generate vulnerability-assessment-tool images \u00b6 In order to generate the Docker images to upload to a local registry, you should generate vulnerability-assessment-tool's Java archives. This can be done following Build JAVA archives/Docker images tutorial. To briefly summarize you should build and run an image which will populate your local directories with the vulnerability-assessment-tool JARs and WARs. In the end of this preliminary step you should have your images locally, this can be tested with the command docker images | grep vulnerability-assessment-tool . # sample output for `docker images` command vulnerability-assessment-tool-generator 3 .1.6 a829f93eb9aa 22 hours ago 223MB vulnerability-assessment-tool-patch-lib-analyzer 3 .1.6 fbe5ec6de811 22 hours ago 103MB vulnerability-assessment-tool-rest-backend 3 .1.6 277217bc35b2 22 hours ago 136MB vulnerability-assessment-tool-rest-lib-utils 3 .1.6 53bbb929895d 22 hours ago 127MB vulnerability-assessment-tool-frontend-bugs 3 .1.6 fab5925fe785 22 hours ago 316MB vulnerability-assessment-tool-frontend-apps 3 .1.6 191ce235c420 22 hours ago 317MB Push the images to a registry \u00b6 A script was created to push the images to a local Docker registry running inside your organization. This script simply tags the images and pushes them towards the registry. To use the script you will need: a registry in your organization (e.g., goharbor/harbor ) a username vulnerability-assessment-tool used version Invoke the script with the following positional arguments. docker login [ registry ] bash push-images.sh -r [ registry ] -u [ username ] -v [ vulnerability-assessment-tool-version ] Pulling the images from a repository \u00b6 You can use Docker to pull your images from a registry. docker pull [ registry ] / [ username ] /vulnerability-assessment-tool-rest-backend: [ vulnerability-assessment-tool-version ] Get going: Deploy a Kubernetes cluster on the Internet with the images you just pushed","title":"Push Docker images to a registry"},{"location":"admin/tutorials/registry/#push-docker-images-on-a-registry","text":"","title":"Push Docker images on a registry"},{"location":"admin/tutorials/registry/#pre-requisites","text":"git bash docker docker-compose","title":"Pre-requisites"},{"location":"admin/tutorials/registry/#generate-vulnerability-assessment-tool-images","text":"In order to generate the Docker images to upload to a local registry, you should generate vulnerability-assessment-tool's Java archives. This can be done following Build JAVA archives/Docker images tutorial. To briefly summarize you should build and run an image which will populate your local directories with the vulnerability-assessment-tool JARs and WARs. In the end of this preliminary step you should have your images locally, this can be tested with the command docker images | grep vulnerability-assessment-tool . # sample output for `docker images` command vulnerability-assessment-tool-generator 3 .1.6 a829f93eb9aa 22 hours ago 223MB vulnerability-assessment-tool-patch-lib-analyzer 3 .1.6 fbe5ec6de811 22 hours ago 103MB vulnerability-assessment-tool-rest-backend 3 .1.6 277217bc35b2 22 hours ago 136MB vulnerability-assessment-tool-rest-lib-utils 3 .1.6 53bbb929895d 22 hours ago 127MB vulnerability-assessment-tool-frontend-bugs 3 .1.6 fab5925fe785 22 hours ago 316MB vulnerability-assessment-tool-frontend-apps 3 .1.6 191ce235c420 22 hours ago 317MB","title":"Generate vulnerability-assessment-tool images"},{"location":"admin/tutorials/registry/#push-the-images-to-a-registry","text":"A script was created to push the images to a local Docker registry running inside your organization. This script simply tags the images and pushes them towards the registry. To use the script you will need: a registry in your organization (e.g., goharbor/harbor ) a username vulnerability-assessment-tool used version Invoke the script with the following positional arguments. docker login [ registry ] bash push-images.sh -r [ registry ] -u [ username ] -v [ vulnerability-assessment-tool-version ]","title":"Push the images to a registry"},{"location":"admin/tutorials/registry/#pulling-the-images-from-a-repository","text":"You can use Docker to pull your images from a registry. docker pull [ registry ] / [ username ] /vulnerability-assessment-tool-rest-backend: [ vulnerability-assessment-tool-version ] Get going: Deploy a Kubernetes cluster on the Internet with the images you just pushed","title":"Pulling the images from a repository"},{"location":"blog/2018/","text":"","title":"Home"},{"location":"contributor/","text":"Contribute \u00b6 Our aim is to build a lively community, hence, we welcome any exchange and collaboration with individuals and organizations interested in the use, support and extension of vulnerability-assessment-tool. To contribute, read on to learn about your options: Help Others on Stack Overflow Report Bugs as GitHub issues Analyze Bugs Contribute Code (fixes and features) Contribute to the Vulnerability Knowledge Base Help Others \u00b6 You can help by helping others who use vulnerability-assessment-tool and need support. Find them on Stack Overflow . Report Bugs \u00b6 If you find a bug - a behavior of the code contradicting its specification - you are welcome to report it. We can only handle well-reported, actual bugs, so please follow the guidelines below and use forums like Stack Overflow for support questions or when in doubt whether the issue is an actual bug. Once you have familiarized with the guidelines, you can go to the GitHub issue tracker to report the issue. Quick Checklist for Bug Reports \u00b6 Issue report checklist: Real, current bug No duplicate Reproducible Good summary Well-documented Minimal example Use the template Requirements for a bug report \u00b6 These eight requirements are the mandatory base of a good bug report: Only real bugs : please do your best to make sure to only report real bugs! Do not report: issues caused by application code or any code outside vulnerability-assessment-tool. something that behaves just different from what you expected. A bug is when something behaves different than specified. When in doubt, ask in a forum. something you do not get to work properly. Use a support forum like Stack Overflow to request help. feature requests. Well, this is arguable: critical or easy-to-do enhancement suggestions are welcome, but we do not want to use the issue tracker as wishlist. No duplicate: you have searched the issue tracker to make sure the bug has not yet been reported Good summary: the summary should be specific to the issue Current bug: the bug can be reproduced in the most current version (state the tested version!) Reproducible bug: there are clear steps to reproduce given. This includes, where possible: a URL to access the example any required user/password information (do not reveal any credentials that could be mis-used!) detailed and complete step-by-step instructions to reproduce the bug Precise description: precisely state the expected and the actual behavior give information about the used browser/device and its version, if possible also the behavior in other browsers/devices if the bug is about wrong UI appearance, attach a screenshot and mark what is wrong generally give as much additional information as possible. (But find the right balance: do not invest hours for a very obvious and easy to solve issue. When in doubt, give more information.) Minimal example: it is highly encouraged to provide a minimal example to reproduce in e.g. jsbin: isolate the application code which triggers the issue and strip it down as much as possible as long as the issue still occurs. If several files are required, you can create a gist. This may not always be possible and sometimes be overkill, but it always helps analyzing a bug. Only one bug per report: open different tickets for different issues You are encouraged to use this template . Please report bugs in English, so all users can understand them. If the bug appears to be a regression introduced in a new version of vulnerability-assessment-tool, try to find the closest versions between which it was introduced. Issue handling process \u00b6 When an issue is reported, a committer will look at it and either confirm it as a real issue (by giving the \"approved\" label), close it if it is not an issue, or ask for more details. Approved issues are then either assigned to a committer in GitHub, reported in our internal issue handling system, or left open as \"contribution welcome\" for easy or not urgent fixes. An issue that is about a real bug is closed as soon as the fix is committed. The closing comment explains which patch version(s) will contain the fix. Usage of Labels \u00b6 Github offers labels to categorize issues. We defined the following labels so far: Labels for issue categories: bug: this issue is a bug in the code documentation: this issue is about wrong documentation enhancement: this is not a bug report, but an enhancement request Status of open issues: unconfirmed: this report needs confirmation whether it is really a bug (no label; this is the default status) approved: this issue is confirmed to be a bug author action: the author is required to provide information contribution welcome: this fix/enhancement is approved and you are invited to contribute it Status/resolution of closed issues: fixed: a fix for the issue was provided duplicate: the issue is also reported in a different ticket and is handled there invalid: for some reason or another this issue report will not be handled further (maybe lack of information or issue does not apply anymore) works: not reproducible or working as expected wontfix: while acknowledged to be an issue, a fix cannot or will not be provided The labels can only be set and modified by committers. Issue Reporting Disclaimer \u00b6 We want to improve the quality of vulnerability-assessment-tool and good bug reports are welcome! But our capacity is limited, so we cannot handle questions or consultation requests and we cannot afford to ask for required details. So we reserve the right to close or to not process insufficient bug reports in favor of those which are very cleanly documented and easy to reproduce. Even though we would like to solve each well-documented issue, there is always the chance that it won't happen - remember: vulnerability-assessment-tool is Open Source and comes without warranty. Analyze Bugs \u00b6 Analyzing issue reports can be a lot of effort. Any help is welcome! Go to the Github issue tracker and find an open issue which needs additional work or a bugfix. Additional work may be further information, or a minimized jsbin example or gist, or it might be a hint that helps understanding the issue. Maybe you can even find and contribute a bugfix? Contribute Code \u00b6 You are welcome to contribute code in order to fix bugs or to implement new features. There are three important things to know: You must be aware of the Apache License (which describes contributions) and agree to the Contributors License Agreement . This is common practice in all major Open Source projects. To make this process as simple as possible, we are using CLA assistant for individual contributions. CLA assistant is an open source tool that integrates with GitHub very well and enables a one-click-experience for accepting the CLA. For company contributors special rules apply. See the respective section below for details. There are several requirements regarding code style, quality, and product standards which need to be met (we also have to follow them). The respective section below gives more details on the coding guidelines. Not all proposed contributions can be accepted . Some features may e.g. just fit a third-party add-on better. The code must fit the overall direction of the open-source vulnerability assessment tool and really improve it, so there should be some \"bang for the byte\". For most bug fixes this is a given, but major feature implementation first need to be discussed with one of the vulnerability-assessment-tool committers , possibly one who touched the related code recently. The more effort you invest, the better you should clarify in advance whether the contribution fits: the best way would be to just open an enhancement ticket in the issue tracker to discuss the feature you plan to implement (make it clear you intend to contribute). We will then forward the proposal to the respective code owner, this avoids disappointment. Contributor License Agreement \u00b6 When you contribute (code, documentation, or anything else), you have to be aware that your contribution is covered by the same Apache 2.0 License that is applied to the open-source vulnerability assessment tool itself. In particular you need to agree to the Individual Contributor License Agreement, which can be found here . (This applies to all contributors, including those contributing on behalf of a company). If you agree to its content, you simply have to click on the link posted by the CLA assistant as a comment to the pull request. Click it to check the CLA, then accept it on the following screen if you agree to it. CLA assistant will save this decision for upcoming contributions and will notify you if there is any change to the CLA in the meantime. Company Contributors If employees of a company contribute code, in addition to the individual agreement above, there needs to be one company agreement submitted. This is mainly for the protection of the contributing employees. A company representative authorized to do so needs to download, fill, and print the Corporate Contributor License Agreement form. Then either: Scan it and e-mail it to opensource@sap.com and henrik.plate@sap.com Fax it to: +49 6227 78-45813 Send it by traditional letter to: Industry Standards & Open Source Team, Dietmar-Hopp-Allee 16, 69190 Walldorf, Germany The form contains a list of employees who are authorized to contribute on behalf of your company. When this list changes, please let us know. Contribution Content Guidelines \u00b6 Contributed content can be accepted if it: is useful to improve vulnerability-assessment-tool (explained above) follows the applicable guidelines and standards The second requirement could be described in entire books and would still lack a 100%-clear definition, so you will get a committer's feedback if something is not right. These are some of the most important rules to give you an initial impression: Apply a clean coding style adapted to the surrounding code, even though we are aware the existing code is not fully clean Use tabs for indentation (except if the modified file consistently uses spaces) Use variable naming conventions like in the other files you are seeing (e.g. hungarian notation) No System.out.println Only access public APIs of other entities (there are exceptions, but this is the rule) Comment your code where it gets non-trivial Keep an eye on performance and memory consumption Write a unit test Do not do any incompatible changes, especially do not modify the name or behavior of public API methods or properties Always consider the developer who USES your control/code! Think about what code and how much code he/she will need to write to use your feature Think about what she/he expects your control/feature to do If this list sounds lengthy and hard to achieve - well, that's what WE have to comply with as well, and it's by far not complete\u2026 How to contribute - the Process \u00b6 Make sure the change would be welcome (e.g. a bugfix or a useful feature); best do so by proposing it in a GitHub issue Create a branch forking vulnerability-assessment-tool repository and do your change Commit and push your changes on that branch When you have several commits, squash them into one (see this explanation ) - this also needs to be done when additional changes are required after the code review Provide a meaningful commit message incl. links to the respective issue If your change fixes an issue reported at GitHub, add the following line to the commit message: Fixes https://github.com/SAP/vulnerability-assessment-tool/issues/(issueNumber) Do NOT add a colon after \"Fixes\" - this prevents automatic closing. When your pull request number is known (e.g. because you enhance a pull request after a code review), you can also add the line Closes https://github.com/SAP/vulnerability-assessment-tool/pull/(pullRequestNumber) Create a Pull Request to https://github.com/SAP/vulnerability-assessment-tool Follow the link posted by the CLA assistant to your pull request and accept it, as described in detail above. Wait for our code review and approval, possibly enhancing your change on request Note that vulnerability-assessment-tool developers also have their regular duties, so depending on the required effort for reviewing, testing and clarification this may take a while Once the change has been approved we will inform you in a comment Your pull request cannot be merged directly into the branch (internal SAP processes), but will be merged internally and immediately appear in the public repository as well. Pull requests for non-code branches (like \"gh-pages\" for the website) can be directly merged. We will close the pull request, feel free to delete the now obsolete branch Contribute to the Vulnerability Knowledge Base \u00b6 Every installation of vulnerability-assessment-tool relies on a database with detailed information about vulnerable code (methods, functions, etc.) in open-source software components. This database is populated by analyzing the source code changes (commits) done by open source developers to fix a given vulnerability. This analysis is done using the patch-analyzer , which takes several arguments as input, e.g., the source code repository of the respective component, the commit identifier(s), and a vulnerability identifier. Analysis results such as the names and abstract syntax trees of modified methods are eventually stored in the local PostgreSQL database of vulnerability-assessment-tool. In order to prevent that each and every user of vulnerability-assessment-tool has to collect the repository URL and the fix commit(s) for a given vulnerability by himself, we created the shared vulnerability assessment knowledge base The maintenance of this knowledge base will become - in the ideal case - a community effort involving both open source projects as well as users of vulnerability-assessment-tool. Please create an issue if you want to provide new information about publicly disclosed vulnerabilities in open source components, or correct an existing entry.","title":"Contribute"},{"location":"contributor/#contribute","text":"Our aim is to build a lively community, hence, we welcome any exchange and collaboration with individuals and organizations interested in the use, support and extension of vulnerability-assessment-tool. To contribute, read on to learn about your options: Help Others on Stack Overflow Report Bugs as GitHub issues Analyze Bugs Contribute Code (fixes and features) Contribute to the Vulnerability Knowledge Base","title":"Contribute"},{"location":"contributor/#help-others","text":"You can help by helping others who use vulnerability-assessment-tool and need support. Find them on Stack Overflow .","title":"Help Others"},{"location":"contributor/#report-bugs","text":"If you find a bug - a behavior of the code contradicting its specification - you are welcome to report it. We can only handle well-reported, actual bugs, so please follow the guidelines below and use forums like Stack Overflow for support questions or when in doubt whether the issue is an actual bug. Once you have familiarized with the guidelines, you can go to the GitHub issue tracker to report the issue.","title":"Report Bugs"},{"location":"contributor/#quick-checklist-for-bug-reports","text":"Issue report checklist: Real, current bug No duplicate Reproducible Good summary Well-documented Minimal example Use the template","title":"Quick Checklist for Bug Reports"},{"location":"contributor/#requirements-for-a-bug-report","text":"These eight requirements are the mandatory base of a good bug report: Only real bugs : please do your best to make sure to only report real bugs! Do not report: issues caused by application code or any code outside vulnerability-assessment-tool. something that behaves just different from what you expected. A bug is when something behaves different than specified. When in doubt, ask in a forum. something you do not get to work properly. Use a support forum like Stack Overflow to request help. feature requests. Well, this is arguable: critical or easy-to-do enhancement suggestions are welcome, but we do not want to use the issue tracker as wishlist. No duplicate: you have searched the issue tracker to make sure the bug has not yet been reported Good summary: the summary should be specific to the issue Current bug: the bug can be reproduced in the most current version (state the tested version!) Reproducible bug: there are clear steps to reproduce given. This includes, where possible: a URL to access the example any required user/password information (do not reveal any credentials that could be mis-used!) detailed and complete step-by-step instructions to reproduce the bug Precise description: precisely state the expected and the actual behavior give information about the used browser/device and its version, if possible also the behavior in other browsers/devices if the bug is about wrong UI appearance, attach a screenshot and mark what is wrong generally give as much additional information as possible. (But find the right balance: do not invest hours for a very obvious and easy to solve issue. When in doubt, give more information.) Minimal example: it is highly encouraged to provide a minimal example to reproduce in e.g. jsbin: isolate the application code which triggers the issue and strip it down as much as possible as long as the issue still occurs. If several files are required, you can create a gist. This may not always be possible and sometimes be overkill, but it always helps analyzing a bug. Only one bug per report: open different tickets for different issues You are encouraged to use this template . Please report bugs in English, so all users can understand them. If the bug appears to be a regression introduced in a new version of vulnerability-assessment-tool, try to find the closest versions between which it was introduced.","title":"Requirements for a bug report"},{"location":"contributor/#issue-handling-process","text":"When an issue is reported, a committer will look at it and either confirm it as a real issue (by giving the \"approved\" label), close it if it is not an issue, or ask for more details. Approved issues are then either assigned to a committer in GitHub, reported in our internal issue handling system, or left open as \"contribution welcome\" for easy or not urgent fixes. An issue that is about a real bug is closed as soon as the fix is committed. The closing comment explains which patch version(s) will contain the fix.","title":"Issue handling process"},{"location":"contributor/#usage-of-labels","text":"Github offers labels to categorize issues. We defined the following labels so far: Labels for issue categories: bug: this issue is a bug in the code documentation: this issue is about wrong documentation enhancement: this is not a bug report, but an enhancement request Status of open issues: unconfirmed: this report needs confirmation whether it is really a bug (no label; this is the default status) approved: this issue is confirmed to be a bug author action: the author is required to provide information contribution welcome: this fix/enhancement is approved and you are invited to contribute it Status/resolution of closed issues: fixed: a fix for the issue was provided duplicate: the issue is also reported in a different ticket and is handled there invalid: for some reason or another this issue report will not be handled further (maybe lack of information or issue does not apply anymore) works: not reproducible or working as expected wontfix: while acknowledged to be an issue, a fix cannot or will not be provided The labels can only be set and modified by committers.","title":"Usage of Labels"},{"location":"contributor/#issue-reporting-disclaimer","text":"We want to improve the quality of vulnerability-assessment-tool and good bug reports are welcome! But our capacity is limited, so we cannot handle questions or consultation requests and we cannot afford to ask for required details. So we reserve the right to close or to not process insufficient bug reports in favor of those which are very cleanly documented and easy to reproduce. Even though we would like to solve each well-documented issue, there is always the chance that it won't happen - remember: vulnerability-assessment-tool is Open Source and comes without warranty.","title":"Issue Reporting Disclaimer"},{"location":"contributor/#analyze-bugs","text":"Analyzing issue reports can be a lot of effort. Any help is welcome! Go to the Github issue tracker and find an open issue which needs additional work or a bugfix. Additional work may be further information, or a minimized jsbin example or gist, or it might be a hint that helps understanding the issue. Maybe you can even find and contribute a bugfix?","title":"Analyze Bugs"},{"location":"contributor/#contribute-code","text":"You are welcome to contribute code in order to fix bugs or to implement new features. There are three important things to know: You must be aware of the Apache License (which describes contributions) and agree to the Contributors License Agreement . This is common practice in all major Open Source projects. To make this process as simple as possible, we are using CLA assistant for individual contributions. CLA assistant is an open source tool that integrates with GitHub very well and enables a one-click-experience for accepting the CLA. For company contributors special rules apply. See the respective section below for details. There are several requirements regarding code style, quality, and product standards which need to be met (we also have to follow them). The respective section below gives more details on the coding guidelines. Not all proposed contributions can be accepted . Some features may e.g. just fit a third-party add-on better. The code must fit the overall direction of the open-source vulnerability assessment tool and really improve it, so there should be some \"bang for the byte\". For most bug fixes this is a given, but major feature implementation first need to be discussed with one of the vulnerability-assessment-tool committers , possibly one who touched the related code recently. The more effort you invest, the better you should clarify in advance whether the contribution fits: the best way would be to just open an enhancement ticket in the issue tracker to discuss the feature you plan to implement (make it clear you intend to contribute). We will then forward the proposal to the respective code owner, this avoids disappointment.","title":"Contribute Code"},{"location":"contributor/#contributor-license-agreement","text":"When you contribute (code, documentation, or anything else), you have to be aware that your contribution is covered by the same Apache 2.0 License that is applied to the open-source vulnerability assessment tool itself. In particular you need to agree to the Individual Contributor License Agreement, which can be found here . (This applies to all contributors, including those contributing on behalf of a company). If you agree to its content, you simply have to click on the link posted by the CLA assistant as a comment to the pull request. Click it to check the CLA, then accept it on the following screen if you agree to it. CLA assistant will save this decision for upcoming contributions and will notify you if there is any change to the CLA in the meantime.","title":"Contributor License Agreement"},{"location":"contributor/#contribution-content-guidelines","text":"Contributed content can be accepted if it: is useful to improve vulnerability-assessment-tool (explained above) follows the applicable guidelines and standards The second requirement could be described in entire books and would still lack a 100%-clear definition, so you will get a committer's feedback if something is not right. These are some of the most important rules to give you an initial impression: Apply a clean coding style adapted to the surrounding code, even though we are aware the existing code is not fully clean Use tabs for indentation (except if the modified file consistently uses spaces) Use variable naming conventions like in the other files you are seeing (e.g. hungarian notation) No System.out.println Only access public APIs of other entities (there are exceptions, but this is the rule) Comment your code where it gets non-trivial Keep an eye on performance and memory consumption Write a unit test Do not do any incompatible changes, especially do not modify the name or behavior of public API methods or properties Always consider the developer who USES your control/code! Think about what code and how much code he/she will need to write to use your feature Think about what she/he expects your control/feature to do If this list sounds lengthy and hard to achieve - well, that's what WE have to comply with as well, and it's by far not complete\u2026","title":"Contribution Content Guidelines"},{"location":"contributor/#how-to-contribute-the-process","text":"Make sure the change would be welcome (e.g. a bugfix or a useful feature); best do so by proposing it in a GitHub issue Create a branch forking vulnerability-assessment-tool repository and do your change Commit and push your changes on that branch When you have several commits, squash them into one (see this explanation ) - this also needs to be done when additional changes are required after the code review Provide a meaningful commit message incl. links to the respective issue If your change fixes an issue reported at GitHub, add the following line to the commit message: Fixes https://github.com/SAP/vulnerability-assessment-tool/issues/(issueNumber) Do NOT add a colon after \"Fixes\" - this prevents automatic closing. When your pull request number is known (e.g. because you enhance a pull request after a code review), you can also add the line Closes https://github.com/SAP/vulnerability-assessment-tool/pull/(pullRequestNumber) Create a Pull Request to https://github.com/SAP/vulnerability-assessment-tool Follow the link posted by the CLA assistant to your pull request and accept it, as described in detail above. Wait for our code review and approval, possibly enhancing your change on request Note that vulnerability-assessment-tool developers also have their regular duties, so depending on the required effort for reviewing, testing and clarification this may take a while Once the change has been approved we will inform you in a comment Your pull request cannot be merged directly into the branch (internal SAP processes), but will be merged internally and immediately appear in the public repository as well. Pull requests for non-code branches (like \"gh-pages\" for the website) can be directly merged. We will close the pull request, feel free to delete the now obsolete branch","title":"How to contribute - the Process"},{"location":"contributor/#contribute-to-the-vulnerability-knowledge-base","text":"Every installation of vulnerability-assessment-tool relies on a database with detailed information about vulnerable code (methods, functions, etc.) in open-source software components. This database is populated by analyzing the source code changes (commits) done by open source developers to fix a given vulnerability. This analysis is done using the patch-analyzer , which takes several arguments as input, e.g., the source code repository of the respective component, the commit identifier(s), and a vulnerability identifier. Analysis results such as the names and abstract syntax trees of modified methods are eventually stored in the local PostgreSQL database of vulnerability-assessment-tool. In order to prevent that each and every user of vulnerability-assessment-tool has to collect the repository URL and the fix commit(s) for a given vulnerability by himself, we created the shared vulnerability assessment knowledge base The maintenance of this knowledge base will become - in the ideal case - a community effort involving both open source projects as well as users of vulnerability-assessment-tool. Please create an issue if you want to provide new information about publicly disclosed vulnerabilities in open source components, or correct an existing entry.","title":"Contribute to the Vulnerability Knowledge Base"},{"location":"contributor/manuals/","text":"","title":"Home"},{"location":"contributor/manuals/languages/","text":"ANTLR grammar \u00b6 vulnerability-assessment-tool uses ANTLR to parse Java and Python source code. Grammars are downloaded from https://github.com/antlr/grammars-v4 and put into directory src/main/antlr4 (in subdirectories matching the target Java package namespace of the generated parsers, e.g., com/sap/psr/vulas/java/antlr for Java). The actual Java classes are generated by the ANTLR plugin org.antlr:antlr4-maven-plugin . Python \u00b6 Grammars https://github.com/antlr/grammars-v4/tree/master/ ... and https://github.com/antlr/grammars-v4/tree/master/python3 are put into the modules lang-python , folder src/main/antlr4/com/sap/psr/vulas/python/antlr/python3 and python355 . The default parser has been generated from the Python 3.3.5 grammar, including for Python 2 source code. Which parser is taken at runtime depends on the presence of language features specific to Python 2 (e.g., raw_input ) and Python 3.5 (e.g., async ), see Java class PythonFileAnalyzer in module lang-python .","title":"ANTLR grammar"},{"location":"contributor/manuals/languages/#antlr-grammar","text":"vulnerability-assessment-tool uses ANTLR to parse Java and Python source code. Grammars are downloaded from https://github.com/antlr/grammars-v4 and put into directory src/main/antlr4 (in subdirectories matching the target Java package namespace of the generated parsers, e.g., com/sap/psr/vulas/java/antlr for Java). The actual Java classes are generated by the ANTLR plugin org.antlr:antlr4-maven-plugin .","title":"ANTLR grammar"},{"location":"contributor/manuals/languages/#python","text":"Grammars https://github.com/antlr/grammars-v4/tree/master/ ... and https://github.com/antlr/grammars-v4/tree/master/python3 are put into the modules lang-python , folder src/main/antlr4/com/sap/psr/vulas/python/antlr/python3 and python355 . The default parser has been generated from the Python 3.3.5 grammar, including for Python 2 source code. Which parser is taken at runtime depends on the presence of language features specific to Python 2 (e.g., raw_input ) and Python 3.5 (e.g., async ), see Java class PythonFileAnalyzer in module lang-python .","title":"Python"},{"location":"contributor/support/faq/","text":"","title":"Faq"},{"location":"contributor/support/getting_help/","text":"Getting help \u00b6","title":"Getting help"},{"location":"contributor/support/getting_help/#getting-help","text":"","title":"Getting help"},{"location":"contributor/tutorials/new_lang/","text":"Support new language \u00b6 Info This tutorial is under construction, the information provided is expected to be incomplete... Extending vulnerability-assessment-tool to cover new languages requires the following steps: Extend enumerations comprised in component shared Create a new component lang-xyz that is able to extract all constructs from source and compiled code as well as packages of the respective programming language Add RUNTIME dependencies on lang-xyz to the client-side scan tools and patch-analyzer Extend the enumerations \u00b6 Extend enumeration com.sap.psr.vulas.shared.enums.ProgrammingLanguage to cover the new programming language. Right now, there exist the three values JAVA , PY (Python) and JS (JavaScript). However, even if the enumeration value for JavaScript exists, the other parts have not been implemented yet (see next sections). Create new component lang-xyz \u00b6 Create a new Maven module lang-xyz and add it to the root pom.xml . You can use lang-python as a template. The purpose of the component is to extract all constructs of source and compiled code as well as packaged artifacts (e.g., wheels in Python). ...","title":"Support new language"},{"location":"contributor/tutorials/new_lang/#support-new-language","text":"Info This tutorial is under construction, the information provided is expected to be incomplete... Extending vulnerability-assessment-tool to cover new languages requires the following steps: Extend enumerations comprised in component shared Create a new component lang-xyz that is able to extract all constructs from source and compiled code as well as packages of the respective programming language Add RUNTIME dependencies on lang-xyz to the client-side scan tools and patch-analyzer","title":"Support new language"},{"location":"contributor/tutorials/new_lang/#extend-the-enumerations","text":"Extend enumeration com.sap.psr.vulas.shared.enums.ProgrammingLanguage to cover the new programming language. Right now, there exist the three values JAVA , PY (Python) and JS (JavaScript). However, even if the enumeration value for JavaScript exists, the other parts have not been implemented yet (see next sections).","title":"Extend the enumerations"},{"location":"contributor/tutorials/new_lang/#create-new-component-lang-xyz","text":"Create a new Maven module lang-xyz and add it to the root pom.xml . You can use lang-python as a template. The purpose of the component is to extract all constructs of source and compiled code as well as packaged artifacts (e.g., wheels in Python). ...","title":"Create new component lang-xyz"},{"location":"contributor/tutorials/project_structure/","text":"Project structure \u00b6 The following picture shows all of the components (modules) of the Maven project hosted at https://github.com/SAP/vulnerability-assessment-tool . Each component visible in the picture corresponds to a module listed in the pom.xml . The component (module) dependencies shown are of three kinds: Dependencies with Maven scopes COMPILE or RUNTIME and REST calls happening at runtime. The project comprises the following client-side tools to scan Java and Python applications. All of those run on a client, typically a Jenkins build server or a developer work station. plugin-maven scans Java applications developed with Java and Maven (based on the application-specific pom.xml ) plugin-gradle scans Java applications developed with Java and Gradle (based on the application-specific build.gradle ) cli-scanner scans both Java and Python applications (based on code present in the file system) plugin-setuptools scans Python applications (based on the application-specific setup.py ). Important : This component is not yet part of the GitHub repo https://github.com/SAP/vulnerability-assessment-tool . Those client-side tools have just one COMPILE dependency on the language-agnostic component lang , which comprises a number of general functionality related to, for instance, backend connectivity or language-agnostic goals such as clean or report . The client-side tools also have RUNTIME dependencies on language-specific components. The motivation to use RUNTIME dependencies is to keep the client-side tools free of language-specific code. The project comprises the following frontends, all of them developed using OpenUI5 : frontend-apps is used by application developers to check scan results or their application frontend-bugs is used by administrators to check and maintain bug information frontend-patch-analyzer is used by administrators to trigger the analysis of fix commits. Important : This component is outdated, the analysis of fix commits is done using the patch-analyzer command-line tool. The language-specific component comprise all the logic to analyze source and compiled code as well as the various package formats of the respective programming language, e.g., JARs and WARs in case of Java. For Java, there also exist several modules related to the static analysis, namely lang-java-reach , lang-java-reach-wala and lang-java-reach-soot . There exist the following two server-side components, both of them exposing a RESTful interface browsable through Swagger: rest-backend is connected to a PostgreSQL database in order to store and join vulnerability information and application analysis results rest-lib-utils analyses Java archives in order to, for instance, obtain Abstract Syntax Trees for Java methods comprises in given Maven artifacts The remaining components are as follows: repo-client supports interactions with Git and SVN repositories patch-lib-analyzer determines whether open source components comprise the affected (vulnerable) or the fixed version of a given methods shared comprises utilities, model classes used for (de)serialization and other general functionality relevant for all other components patch-analyzer examines the fix commit(s) of a given vulnerability in order to understand which methods have been changed in order to fix the vulnerability","title":"Project structure"},{"location":"contributor/tutorials/project_structure/#project-structure","text":"The following picture shows all of the components (modules) of the Maven project hosted at https://github.com/SAP/vulnerability-assessment-tool . Each component visible in the picture corresponds to a module listed in the pom.xml . The component (module) dependencies shown are of three kinds: Dependencies with Maven scopes COMPILE or RUNTIME and REST calls happening at runtime. The project comprises the following client-side tools to scan Java and Python applications. All of those run on a client, typically a Jenkins build server or a developer work station. plugin-maven scans Java applications developed with Java and Maven (based on the application-specific pom.xml ) plugin-gradle scans Java applications developed with Java and Gradle (based on the application-specific build.gradle ) cli-scanner scans both Java and Python applications (based on code present in the file system) plugin-setuptools scans Python applications (based on the application-specific setup.py ). Important : This component is not yet part of the GitHub repo https://github.com/SAP/vulnerability-assessment-tool . Those client-side tools have just one COMPILE dependency on the language-agnostic component lang , which comprises a number of general functionality related to, for instance, backend connectivity or language-agnostic goals such as clean or report . The client-side tools also have RUNTIME dependencies on language-specific components. The motivation to use RUNTIME dependencies is to keep the client-side tools free of language-specific code. The project comprises the following frontends, all of them developed using OpenUI5 : frontend-apps is used by application developers to check scan results or their application frontend-bugs is used by administrators to check and maintain bug information frontend-patch-analyzer is used by administrators to trigger the analysis of fix commits. Important : This component is outdated, the analysis of fix commits is done using the patch-analyzer command-line tool. The language-specific component comprise all the logic to analyze source and compiled code as well as the various package formats of the respective programming language, e.g., JARs and WARs in case of Java. For Java, there also exist several modules related to the static analysis, namely lang-java-reach , lang-java-reach-wala and lang-java-reach-soot . There exist the following two server-side components, both of them exposing a RESTful interface browsable through Swagger: rest-backend is connected to a PostgreSQL database in order to store and join vulnerability information and application analysis results rest-lib-utils analyses Java archives in order to, for instance, obtain Abstract Syntax Trees for Java methods comprises in given Maven artifacts The remaining components are as follows: repo-client supports interactions with Git and SVN repositories patch-lib-analyzer determines whether open source components comprise the affected (vulnerable) or the fixed version of a given methods shared comprises utilities, model classes used for (de)serialization and other general functionality relevant for all other components patch-analyzer examines the fix commit(s) of a given vulnerability in order to understand which methods have been changed in order to fix the vulnerability","title":"Project structure"},{"location":"user/","text":"Docs \u00b6 Step by step tutorials Here you can find detailed, hands-on guidance on how to setup and use vulnerability-assessment-tool, starting from your very first scan, through the use of the advanced features (such as reachability analysis and mitigation support/. We also have tutorials dedicated to automating vulnerability-assessment-tool scans with Jenkins or other continuous integration systems, and more are coming. Go to the Tutorials page User Manual The manual contains a comprehensive description of all aspects of vulnerability-assessment-tool from the perspective of users. If you followed the tutorials and still have questions on some specific topic, this is where you will most likely find your answers. Go to the User Manual Getting Help If the tutorials and the manual could not help you with a specific problem you are facing, the support pages are what you should check out next. Go to the User Support page","title":"Docs"},{"location":"user/#docs","text":"Step by step tutorials Here you can find detailed, hands-on guidance on how to setup and use vulnerability-assessment-tool, starting from your very first scan, through the use of the advanced features (such as reachability analysis and mitigation support/. We also have tutorials dedicated to automating vulnerability-assessment-tool scans with Jenkins or other continuous integration systems, and more are coming. Go to the Tutorials page User Manual The manual contains a comprehensive description of all aspects of vulnerability-assessment-tool from the perspective of users. If you followed the tutorials and still have questions on some specific topic, this is where you will most likely find your answers. Go to the User Manual Getting Help If the tutorials and the manual could not help you with a specific problem you are facing, the support pages are what you should check out next. Go to the User Support page","title":"Docs"},{"location":"user/manuals/","text":"User Manual \u00b6 Configuration \u00b6 This section of the manual explains in detail how to setup vulnerability-assessment-tool and how to configure it. Analysis \u00b6 This section covers all the commands (a.k.a, goals ) offered by vulnerability-assessment-tool, including those related to the analysis ( app , a2c , t2c , instr , test ) and the data management and reporting ( upload , report , clean , cleanspace ) Frontend \u00b6 Here you will find a detailed description (including annotated screenshots) of all the functionality exposed by the different views of the vulnerability-assessment-tool web frontend. Report \u00b6 Coming soon! Assessment and Mitigation \u00b6 This section explains in detail how to assess the findings of vulnerability-assessment-tool and how to proceed to mitigate them.","title":"Intro"},{"location":"user/manuals/#user-manual","text":"","title":"User Manual"},{"location":"user/manuals/#configuration","text":"This section of the manual explains in detail how to setup vulnerability-assessment-tool and how to configure it.","title":"Configuration"},{"location":"user/manuals/#analysis","text":"This section covers all the commands (a.k.a, goals ) offered by vulnerability-assessment-tool, including those related to the analysis ( app , a2c , t2c , instr , test ) and the data management and reporting ( upload , report , clean , cleanspace )","title":"Analysis"},{"location":"user/manuals/#frontend","text":"Here you will find a detailed description (including annotated screenshots) of all the functionality exposed by the different views of the vulnerability-assessment-tool web frontend.","title":"Frontend"},{"location":"user/manuals/#report","text":"Coming soon!","title":"Report"},{"location":"user/manuals/#assessment-and-mitigation","text":"This section explains in detail how to assess the findings of vulnerability-assessment-tool and how to proceed to mitigate them.","title":"Assessment and Mitigation"},{"location":"user/manuals/analysis/","text":"Analysis Manual \u00b6 Overview \u00b6 The various client-side tools offer so-called goals in order to analyze applications and interact with the backend. The following goals perform some sort of application analysis: app : Creates a method-level bill of material of an application and all its dependencies. a2c : Builds a call graph (starting from app methods) and checks whether vulnerable code is potentially executable (reachable). test : This is not an actual goal implemented by any of the clients, but describes the collection of execution traces by a so-called Java agent that dynamically instruments Java bytecode during JUnit and integration tests. instr : Produces a modified version of Java archives ( static instrumentation ) that can be deployed/executed in order to collect traces of actual method executions. t2c : Builds a call graph (starting from traced methods) and checks whether vulnerable code is potentially reachable from those. The following goals are related to data management and reporting: upload : Uploads analysis data previously written to disk to the backend report : Downloads analysis data from the backend to the client, produces a result report (HTML, XML, JSON), and throws a build exception in order to break Jenkins jobs clean : Cleans the analysis data of a single app in the backend cleanspace : Cleans an entire workspace in the backend Which goals are supported by the different clients, and how-to configure and execute them is explained in the following subsections. Note that all goal executions (including configuration settings and statistics) are shown on the \"History\" tab of the respective applications. Important: Make sure to understand the following before proceeding: app has to be executed before all the other analysis goals in order to detect all application dependencies with vulnerable code. Once it has been run, the assessment of findings can already start, each finding of app shown on the \"Vulnerabilities\" tab corresponds to a dependency of an application on a component with a known security vulnerability. The number of findings will not change when running other analysis goals. Instead, a2c , test and t2c try to collect evidence concerning the potential or actual execution of vulnerable code brought up by app . Assess every finding, no matter whether a2c , test and t2c were able to collect evidence or not. Not finding such evidence does not mean that vulnerabilities cannot be exploited. The absence of proof is not a proof of absence (of exploitable vulnerabilities). Prerequisites: A workspace has been created and its token is known Java 7 or later is installed Maven: The plugin is available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Limitations : The reachability analysis (goals a2c and t2c ) does not work with Java 9, as the underlying analysis frameworks do not support it. Prerequisites A workspace has been created and its token is known Java 7 or later is installed Maven: The vulnerability-assessment-tool Maven plugin must be available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Java 9 support The reachability analysis (goals a2c and t2c ) is not supported with Java 9, due to limitations of the 3 rd -party analysis frameworks that vulnerability-assessment-tool relies upon. Bill of material analysis (app) \u00b6 Objective Create a complete bill of material (BOM) of the application and of all its dependencies (direct and transitive). Most importantly, the BOM comprises the signatures of all methods of the application and all dependencies, which is compared with a list of methods known to be vulnerable. Moreover, the BOM also comprises meta-info on archive level, e.g., the manifest file entries or the archive's digest (SHA1 in case of Java archives, MD5 in case of Python). Result In the vulnerability-assessment-tool frontend, the table in tab \"Dependencies\" is populated. In case any of the dependencies has vulnerabilities, they are shown in tab \"Vulnerabilities\". The column \"Inclusion of vulnerable code\" indicates whether the version in use is known to be vulnerable or not (see tooltip for more information). Important By default, the Maven plugin searches for application source and compiled code in the folders src/main/java and target/classes . If source or byte code is generated or modified during the build process, and stored in other folders than the ones mentioned, you need to add those directories using the parameter vulas.core.app.sourceDir . Otherwise, the respective code will not be recognized as application code, hence, ignored when performing the reachability analysis. Example: Suppose source code is generated into the folder target/generated-sources . If this code is compiled into the folder target/classes , you do not need to do anything. If it is compiled into a different folder, you would need to add this folder to entries of vulas.core.app.sourceDir . Run as follows CLI java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal app Maven mvn -Dvulas compile vulas:app Gradle ./gradlew assemble vulasApp Configure as follows # Where application source or bytecode and application dependencies (JAR and/or WAR files) are located # Relative or absolute paths, multiple values to be separated by comma vulas.core.app.sourceDir = # Whether or not empty apps (w/o constructs and dependencies) are uploaded to the backend vulas.core.app.uploadEmpty = false # When true, JAR not known to vulnerability-assessment-tool Maven central and not already available to the backend are posted to the backend vulas.core.app.uploadLibrary = false # Number of worker threads analyzing the JAR files from which classes are loaded vulas.core.jarAnalysis.poolSize = 4 # Package prefix(es) of application code (multiple values to be separated by comma) # Default: # CLI: - # Note: Ignored when running the Maven plugin. In all other cases it avoids the separation of application and dependency JARs into distinct folders vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma) # Default: # CLI: - # Note: Ignored when running the Maven plugin. In all other cases it avoids the separation of application and dependency JARs into distinct folders vulas.core.app.appJarNames = Reachable from app (a2c) \u00b6 Objectives Check whether vulnerable methods are reachable, i.e., whether the application can be run in a way that a vulnerable method is executed. Identify all so-called touch points, which are direct calls from an application method to a library method. Collect all reachable methods for every dependency of the application. The first objective supports the risk assessment for a given vulnerability, while the second and third objectives primarily support the mitigation. Depending on the size of the application, the reachability analysis can consume a considerable amount of resources (time and memory). It is not seldom that it runs for several hours. Limitations Python is not supported Java 9 and later versions are not supported by the underlying frameworks Result In the vulnerability-assessment-tool frontend, tab \"Vulnerabilities\", the column \"Static Analysis\" is populated for all libraries subject to known vulnerabilities. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). How does it work vulnerability-assessment-tool uses Wala or Soot , both static analysis frameworks for Java, in order to construct a call graph representing all possible program executions starting from application methods. This graph is traversed in order to see whether and from where methods with known vulnerabilities can be reached. Run as follows CLI java -Xmx8g -Xms2g -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal a2c Maven export MAVEN_OPTS = \"-Xmx8g -Xms2g\" mvn -Dvulas compile vulas:a2c Gradle ./gradlew assemble vulasA2C Configure as follows The following configuration options apply to the reachability analysis no matter which call graph construction framework is used. See below for framework-specific configuration options. # Limits the analysis to certain bugs (multiple values separated by comma) # If empty, all relevant bugs retrieved from backend will be considered # Default: empty vulas.reach.bugs = # Analysis framework to be used # Possible values: wala, soot vulas.reach.fwk = wala # Regex to filter entry points (semicolon separated) vulas.reach.constructFilter = # All packages to be excluded from call graph construction, packages # are separated by semicolon e.g. [java/.*;sun/.*]. Defaults for the different # analysis frameworks are provided in the respective configuration files. --> vulas.reach.excludePackages = # All JAR files to be excluded from call graph construction (multiple entries to be separated by comma) # # Default: WebServicesAgent.jar (from Wily Introscope, an app perf monitoring tool that has invalid manifest header fields creating problems for Wala) vulas.reach.excludeJars = WebServicesAgent.jar # Dir to search for app source files (only vulas:a2c) # If empty, they will be fetched from backend vulas.reach.sourceDir = # Timeout for reachability analysis (in mins) # Default: 120 mins vulas.reach.timeout = 120 # Max number of paths uploaded for a reachable change list element vulas.reach.maxPathPerChangeListElement = 10 # Whether or not to collect touch points # Default: true vulas.reach.identifyTouchpoints = true # Whether to search for the shortest path(s) from entry points to vulnerable constructs, or to quit after the first path found # Default: true vulas.reach.searchShortest = true Call graph construction framework Behind the scene, a source code analysis framework is used to construct the call graph, either starting from application methods ( a2c ) or from traced methods ( t2c ). Right now, the two frameworks Wala and Soot are supported and can be configured with vulas.reach.fwk . Both offer several configuration options to influence the accuracy of the call graph and its construction time. Once the call graph has been constructed, its size (in terms of nodes and edges) is printed to the console, which is useful for comparing the impact of the different configuration options, e.g. [vulas-reach-1] INFO com.sap.psr.vulas.cg.wala.WalaCallgraphConstructor - Normalized call graph has [167639 nodes] (with distinct ConstructId) and [1279495 edges] WALA The setting vulas.reach.wala.callgraph.algorithm determines the construction algorithm to be used. From RTA (Rapid Type Analysis) to 0-1-ctn-CFA , the call graph becomes more accurate, but the construction takes more time. A more accurate call graph means that it contains less false-positives, i.e., method invocations that cannot happen during actual program execution. As a rule of thumb, a call graph constructed with RTA contains more nodes and edges than one constructed with 0-1-ctn-CFA . Note the following before choosing a more simple algorithm: The increase of nodes and edges resulting from, for instance, the choice of RTA, has a negative impact on the performance of the later analysis phases. As such, it may be worth to spend more time on the graph construction. See here , there and there for more information regarding the difference of call graph construction algorithms. # Possible values: 0-CFA; 0-ctn-CFA; vanilla-0-1-CFA; 0-1-CFA; 0-1-ctn-CFA # Default algorithm: 0-1-CFA vulas.reach.wala.callgraph.algorithm = 0-1-CFA The setting vulas.reach.wala.callgraph.reflection determines the consideration of reflection, which is commonly used to instantiate and invoke classes and methods. See here for more information. # Reflection option to be used for call graph construction # Possible values: FULL; NO_METHOD_INVOKE; NO_STRING_CONSTANTS; APPLICATION_GET_METHOD # Possible values: NONE; NO_FLOW_TO_CASTS; NO_FLOW_TO_CASTS_NO_METHOD_INVOKE; ONE_FLOW_TO_CASTS_NO_METHOD_INVOKE; NO_FLOW_TO_CASTS_APPLICATION_GET_METHOD; ONE_FLOW_TO_CASTS_APPLICATION_GET_METHOD # Default value: NO_FLOW_TO_CASTS_NO_METHOD_INVOKE vulas.reach.wala.callgraph.reflection = NO_FLOW_TO_CASTS_NO_METHOD_INVOKE Soot The subset of Soot configuration options that can be set through vulnerability-assessment-tool are as follows. For all other Soot settings, the respective defaults are taken. See here for a complete documentation of Soot configuration options. # Packages that are excluded when building callgraph # Soot option: -exclude ... # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#section_5 vulas.reach.soot.exclusions = java.awt.*;javax.swing.*;sun.awt.*;sun.swing.*;org.netbeans.*;com.sun.*;org.openide.*;com.ibm.crypto.*;com.ibm.security.*;org.apache.xerces.* # Use or not use \"verbose mode\" when building callgraph # Default: false; Recommended: set it to true when debugging # Soot options: -verbose -debug -debug-resolver # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#phase_5_2 vulas.reach.soot.verbose = false # Use or not use \"application mode\" when building callgraph # Soot option: -app # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#section_2 vulas.reach.soot.appMode = false # Allow or not allow phantom references (Recommended: false) # Soot option: -allow-phantom-refs # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#section_2 vulas.reach.soot.allowPhantom = true # No class body for excluded packages # Soot option: -no-bodies-for-excluded # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#section_2 vulas.reach.soot.nobodyForX = true # Use soot spark or not; # if yes, three options could be set: spark.otf (default true); spark.vta (default false); spark.rta (default false). # Soot option: -p cg.spark ... # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#phase_5_2 vulas.reach.soot.spark = true vulas.reach.soot.spark.otf = true vulas.reach.soot.spark.vta = false vulas.reach.soot.spark.rta = false # Whether and how to generate a 'DummyMainMethod' used as an entrypoint for the callgraph construction: # | Option | Consequence | # |-------------------------------------------------------------------- |------------------------------------------------------------------------------------------------------| # | none (default) | no 'DummyMainMethod' is generated (default) | # | soot.jimple.infoflow.entryPointCreators.SequentialEntryPointCreator | a 'DummyMainMethod' that invokes all entrypoints is generated | # | soot.jimple.infoflow.entryPointCreators.DefaultEntryPointCreator | a 'DummyMainMethod' in which all entrypoints are generated (random order) | # | com.sap.psr.vulas.cg.soot.CustomEntryPointCreator | same as DefaultEntryPointCreated + for abstract classes/interface a dummy implementation is generated | vulas.reach.soot.entrypointGenerator = none Dynamic instrumentation (JUnit) \u00b6 Objective Collect method traces during the execution of JUnit tests. Information about traced methods will be compared with methods subject to known vulnerabilities. Limitations Python is not supported Result In the vulnerability-assessment-tool frontend, tab \"Vulnerabilities\", the column \"Dynamic Analysis\" is populated for all libraries subject to known vulnerabilities. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of actual executions (if any). In the vulnerability-assessment-tool frontend, tab \"Test coverage\", the number of traced vs. the number of total methods is shown per Java package of the application. How does it work vulnerability-assessment-tool collects runtime information during application execution, most importantly whether a vulnerable method has been called and the corresponding call stack. In order to collect this information, the byte code of the application and all its dependencies has to be changed, which can be achieved either dynamically or statically: In case of dynamic instrumentation , the byte code of a given Java class is changed at the time the class definition is loaded for the first time, e.g., during the execution of JUnit tests or integration tests. vulnerability-assessment-tool injects statements in order to save the timestamp of every method invocation as well as stack trace information. Per default, this information is saved in folder target/vulas/upload and uploaded using the goal vulas:upload . To that end, vulnerability-assessment-tool must be registered using the JVM option -javaagent . In case of JUnit tests, the agent is registered by the Maven goal prepare-vulas-agent . In case of static instrumentation , the byte code of classes residing in the file system is changed, e.g., the WAR file of a deployable Web application. This is done with help of the goal vulas:instr (see below). Run as follows Maven mvn -Dvulas vulas:prepare-vulas-agent test vulas:upload Configure as follows # Byte code instrumentor(s) to be used (multiple ones to be separated by comma) # # Possible values: # com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor: Collects exactly one timestamp for every invoked vulnerable method (no call stack) # com.sap.psr.vulas.monitor.trace.SingleStackTraceInstrumentor: Collects at most \"vulas.core.instr.maxStacktraces\" call stack for every invoked vulnerable method # com.sap.psr.vulas.monitor.trace.StackTraceInstrumentor: Collects all call stacks for every invoked vulnerable method # com.sap.psr.vulas.monitor.touch.TouchPointInstrumentor: Collects so-called touch points, i.e., calls from an app method to a library method # # Default: com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor # # Note: # The above list of possible values is ordered ascending after performance impact and memory consumption, # i.e., the SingleTraceInstrumentor has the least impact on performance and memory consumption vulas.core.instr.instrumentorsChoosen = com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor # Max. number of stacktraces collected per instrumented vulnerable method # Default: 10 # Note: Only applies to SingleStackTraceInstrumentor vulas.core.instr.maxStacktraces = 10 # JARs in the following directories (or its subdirs) will not be instrumented #vulas.core.instr.blacklist.dirs = # Constructs of dependencies having one of the following scope(s) will not be instrumented (multiple ones to be separated by comma) # Default: test, provided # Note: Only applies to vulnerability-assessment-tool Maven plugin; in case of vulnerability-assessment-tool CLI, all dependencies have scope RUNTIME vulas.core.instr.blacklist.jars.ignoreScopes = test, provided # User-provided blacklist: Constructs of dependencies whose filename matches one of the following regular expressions will not be instrumented (multiple ones to be separated by comma) # Default: - # Note: Those are on top of \"vulas.core.instr.blacklist.jars\" vulas.core.instr.blacklist.jars.custom = # User-provided Java packages whose constructs are not instrumented (multiple ones to be separated by comma) # Default: - # Note: Those are on top of \"vulas.core.instr.blacklist.classes.jre\" and \"vulas.core.instr.blacklist.classes\" vulas.core.instr.blacklist.classes.custom = # If true, bytecode and instrumentation code will be written to tmpDir vulas.core.instr.writeCode = false # JARs for which no traces and no archive information will be uploaded (e.g., from vulnerability-assessment-tool itself) # Multiple entries are separated by comma, each entry is a regex vulas.core.monitor.blacklist.jars = lang-java-.*\\.jar,vulas-core-.*\\.jar,surefire-.*\\.jar,junit-.*\\.jar,org.jacoco.agent.*\\.jar # Enables or disables the periodic upload of collected traces to the backend # Default: true # Note: Set to FALSE in case of JUnit tests vulas.core.monitor.periodicUpload.enabled = true # Interval (in millisecs) between periodic uploads # Default: 300000 (5 min) vulas.core.monitor.periodicUpload.interval = 300000 # Max. number of traces uploaded by each periodic upload # Default: 1000 vulas.core.monitor.periodicUpload.batchSize = 1000 # Max number of items (traces, paths, touch points, etc.) collected # Default: -1 (no limit) vulas.core.monitor.maxItems = -1 Dynamic instrumentation (JVM) \u00b6 Objective Collect method traces during the actual execution of the application. Information about traced methods will be compared with methods subject to known vulnerabilities. Limitations Python is not supported Result Same as in previous section How does it work By registering a Java agent at JVM startup, vulnerability-assessment-tool changes the bytecode of every Java class loaded at runtime. For example, it injects Java statements in order to save the timestamp of every method invocation as well as stack trace information. This information is periodically uploaded to the vulnerability-assessment-tool backend. Run as follows Download the file lang-java-3.1.6-jar-with-dependencies.jar to your computer (CLI users can take it from the folder ./instr ). Add the following arguments to the Java runtime (and replace line breaks by a single space characters). -javaagent:lang-java-3.1.6-jar-with-dependencies.jar -Dvulas.shared.backend.serviceUrl=http://localhost:8033/backend/ -Dvulas.core.backendConnection=READ_WRITE -Dvulas.core.monitor.periodicUpload.enabled=true -Dvulas.core.appContext.group=<GROUP> -Dvulas.core.appContext.artifact=<ARTIFACT> -Dvulas.core.appContext.version=<VERSION> -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor -Dvulas.core.space.token=<WORKSPACE-TOKEN> -noverify Start the application and perform some application-specific tests and workflows. Example In case of Tomcat 8.x, one needs to (1) copy lang-java-3.1.6-jar-with-dependencies.jar into the folder ./bin and (2) specify the variable CATALINA_OPTS as follows in the file ./bin/setenv.bat . Do not forget to specify <GROUP> , <ARTIFACT> , <VERSION> and <WORKSPACE-TOKEN> for the application under analysis. Note: The use of setenv.bat does not work if Tomcat is run as Windows service. CLI set \"CATALINA_OPTS=-javaagent:lang-java-3.1.6-jar-with-dependencies.jar -Dvulas.shared.backend.serviceUrl=http://localhost:8033/backend/-Dvulas.core.backendConnection=READ_WRITE -Dvulas.core.monitor.periodicUpload.enabled=true -Dvulas.core.appContext.group=<GROUP> -Dvulas.core.appContext.artifact=<ARTIFACT> -Dvulas.core.appContext.version=<VERSION> -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor -Dvulas.core.space.token=<WORKSPACE-TOKEN> -noverify\" Static instrumentation (instr) \u00b6 Objective Modify an existing JAR (WAR) created by mvn package so that traces will be collected once the JAR is executed (the WAR is deployed in a Web application container such as Tomcat). Note: In contrast to what is described in the previous section \"Integration Tests\", vulas:instr will not result in the collection of traces for Tomcat itself. Prerequisite An application's JAR or WAR, e.g., as created with mvn package in folder target . Limitations Python is not supported Result A new JAR/WAR with suffix -vulas-instr will be created in folder target/vulas/target . How does it work The bytecode of all the Java classes found in the JAR (WAR) will be modified as to collect information about, for instance, method execution and stack traces. This information will be uploaded to the backend if the JAR (WAR) is executed. Note: The modified code in the new JAR with suffix -vulas-instr can be inspected with decompilers such as JD-GUI . Run as follows Maven mvn package mvn -Dvulas vulas:instr Troubleshooting The console shows compilation errors, e.g., cannot find javax.servlet.http.HttpServletRequest . The reason is that all application dependencies are re-compiled, and it can happen that some of the classes do have dependency requirements not met by the application. This can be overcome by identifying the respective JAR file and downloading it to the folder target/vulas/lib . Reachable from traces (t2c) \u00b6 Objective Understand whether vulnerable methods can be potentially reached from traced methods. Prerequisite Traces must have been collected during JUnit or integration tests (see above) Limitations Python is not supported Java 9 and later versions are not supported by the underlying frameworks Result In the vulnerability-assessment-tool frontend, tab \"Vulnerabilities\", the column \"Static Analysis\" is populated for all libraries subject to known vulnerabilities. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). How does it work In contrast to the goal a2c , the callgraph is built starting from all methods that were previously traced. As such, the call graph construction overcomes weaknesses of static source analysis related to the use of reflection and control inversion. What remains the same is that the resulting graph is traversed in order to see whether and from where methods with known vulnerabilities can be reached. Run as follows CLI java -jar vulas-cli-jar-with-dependencies.jar -goal t2c Maven mvn -Dvulas vulas:t2c Configure as follows # Limits the analysis to certain bugs (multiple values separated by comma) # If empty, all relevant bugs retrieved from backend will be considered # Default: empty vulas.reach.bugs = # Analysis framework to be used # Possible values: wala, soot vulas.reach.fwk = wala # Regex to filter entry points (semicolon separated) vulas.reach.constructFilter = # All packages to be excluded from call graph construction, packages # are separated by semicolon e.g. [java/.*;sun/.*]. Defaults for the different # analysis frameworks are provided in the respective configuration files. --> vulas.reach.excludePackages = # All JAR files to be excluded from call graph construction (multiple entries to be separated by comma) # # Default: WebServicesAgent.jar (from Wily Introscope, an app perf monitoring tool that has invalid manifest header fields creating problems for Wala) vulas.reach.excludeJars = WebServicesAgent.jar # Dir to search for app source files (only vulas:a2c) # If empty, they will be fetched from backend vulas.reach.sourceDir = # Timeout for reachability analysis (in mins) # Default: 120 mins vulas.reach.timeout = 120 # Max number of paths uploaded for a reachable change list element vulas.reach.maxPathPerChangeListElement = 10 # Whether or not to collect touch points # Default: true vulas.reach.identifyTouchpoints = true # Whether to search for the shortest path(s) from entry points to vulnerable constructs, or to quit after the first path found # Default: true vulas.reach.searchShortest = true Upload analysis files (upload) \u00b6 Objective Uploads analysis data in folder vulas.core.uploadDir to the backend. Such data is only written if the parameter vulas.core.backendConnection is set to OFFLINE or READ_ONLY . By default, this is only the case for the instrumentation of JUnit or integration tests. Configure as follows # When true, serialized HTTP requests will be deleted after the upload succeeded (incl. the JSON files) # Default: true vulas.core.upload.deleteAfterSuccess = true Run as follows CLI java -Dvulas.core.appContext.group = <GROUP> -Dvulas.core.appContext.artifact = <ARTIFACT> -Dvulas.core.appContext.version = 3 .1.6 -jar vulas-cli-jar-with-dependencies.jar -goal upload Maven mvn -Dvulas vulas:upload Create result report (report) \u00b6 Objective Creates result reports in HTML, XML and JSON format (on the basis of analysis results downloaded from the vulnerability-assessment-tool backend). Additionally, the Maven and Gradle plugins can be configured to throw a build exception in order break Jenkins jobs and pipelines in case vulnerable code is present (or reachable/executed). The HTML report can be copied into a Jenkins dashboard using the HTML Publisher Plugin (see automation for a configuration example). Multi-module Maven projects The report goal should be called in a separate build step, e.g., mvn -Dvulas vulas:report . It must NOT be called together with other goals, e.g., mvn -Dvulas compile vulas:app vulas:report , because the build may fail before app and other goals are executed for all the modules. Alternatively, you can use the Maven option --fail-at-end (see here for more info). Result A summary report is written to disk (in HTML, XML and JSON format). For Maven, the target directory of the different files is \"target/vulas/report\", for Gradle it is \"build/vulas/report\". For CLI, the exact location is printed to the console. How does it work Identified vulnerabilities including any information gathered during static and dynamic analysis will be downloaded from the backend. Configure as follows # A vulnerability in blacklisted scopes will not cause an exception (multiple scopes to be separated by comma) # Default: test, provided # Note: For CLI, all dependencies are considered as RUNTIME dependencies vulas.report.exceptionScopeBlacklist = TEST, PROVIDED # Specified vulnerabilities will not cause a build exception (multiple bugs to be separated by comma) # Default: - vulas.report.exceptionExcludeBugs = <vuln-id> # Explanation why the given vulnerability is not relevant/exploitable in the specific application context # Default: - vulas.report.exceptionExcludeBugs.<vuln-id> = Not exploitable because ... # Determines whether un-assessed vulnerabilities (e.g. vulnerabilities marked with an orange hourglass symbol) throw a build exception. Un-assessed vulns are those where # the method signature(s) of a bug appear in an archive, however, it is yet unclear whether the methods # exist in the fixed or vulnerable version. Those findings are marked with a question mark in the frontend. # # Possible values: # all: All un-assessed vulns will be ignored # known: Only un-assessed vulns in archives known to Maven Central will be ignored # off: Never ignore # # Default: all vulas.report.exceptionExcludeUnassessed = all # Specifies whether a build exception is thrown when vulnerable code is included, potentially # reachable, actually reached or not at all # Possible values: noException < dependsOn < potentiallyExecutes < actuallyExecutes # noException : no build exception even if vulnerable code is included # dependsOn : exception raised when vulnerable code is included # potentiallyExecutes : exception raised when vulnerable code is potentially executed (result of static analyse) # actuallyExecutes : exception raised when vulnerable code is executed (result of dynamic analyse) # # Default: dependsOn vulas.report.exceptionThreshold = dependsOn # Directory to where the reports (JSON, XML, HTML) will be written to # Default: # CLI: - # MVN: ${project.build.directory}/vulas/report vulas.report.reportDir = Run as follows CLI java -Dvulas.core.appContext.group = <GROUP> -Dvulas.core.appContext.artifact = <ARTIFACT> -Dvulas.core.appContext.version = <VERSION> -jar vulas-cli-jar-with-dependencies.jar -goal report Maven mvn -Dvulas vulas:report Gradle ./gradlew vulasReport Exemptions The settings vulas.report.exceptionExcludeBugs and vulas.report.exceptionExcludeBugs.<vuln-id> can be used to capture the results of an audit or assessment by developers in regards to whether a vulnerability is problematic in a given application context. Exempted bugs do not result in build exceptions and are also shown in the apps Web frontend. Build exceptions Other settings to fine-tune the threshold for build exceptions are as follows: vulas.report.exceptionScopeBlacklist can be used to exclude certain Maven scopes (default: test) vulas.report.exceptionThreshold can be used to specify whether a build exception is thrown when vulnerable code is included, potentially reachable, actually reached or not at all (values: noException , dependsOn , potentiallyExecutes , actuallyExecutes ; default: actuallyExecutes ) Clean and delete apps (clean) \u00b6 Objective Deletes application-specific data in the backend, e.g., traces collected during JUnit tests, application constructs and dependencies collected through the app goal. Right after executing clean for a given application, the apps Web frontend will be empty for the respective application. Configure as follows # When true, all but the latest X app versions will be deleted (latest according to the application creation date). # The value of X is configured with the option 'vulas.core.clean.purgeVersions.keepLast', see below. # Default: false vulas.core.clean.purgeVersions = false # Specifies X, i.e., the number of application versions to be kept if purgeVersions is set to true. # Set this to 0 to delete all versions. # Default: 3 vulas.core.clean.purgeVersions.keepLast = 3 # When true, the history of past goal executions will be deleted (NOTE: this does not delete the scan results themselves! # you may want to use the two directives above to purge scan results.) # The default value is recommended, in normal scenarios you should leave this to false. # Default: false vulas.core.clean.goalHistory = false Run as follows to clean the current version : CLI java -jar vulas-cli-jar-with-dependencies.jar -goal clean Maven mvn -Dvulas vulas:clean Run as follows to delete an application including all its versions : CLI java -Dvulas.core.clean.purgeVersions = true -Dvulas.core.clean.purgeVersions.keepLast = 0 -jar vulas-cli-jar-with-dependencies.jar -goal clean Maven mvn -Dvulas -Dvulas.core.clean.purgeVersions = true -Dvulas.core.clean.purgeVersions.keepLast = 0 vulas:clean Critical Maven will fail to delete an application if a corresponding <module> does not exit any longer in the pom.xml . The CLI must be used in these cases and the Maven coordinates (GAV) of the item to be cleaned shall be provided as system properties when calling the CLI. For example, if you want to delete an application with GAV myGroup:myArtifact:myVersion , the following command line should be used java -Dvulas.core.clean.purgeVersions = true -Dvulas.core.clean.purgeVersions.keepLast = 0 -Dvulas.core.appContext.group = myGroup -Dvulas.core.appContext.artifact = myArtifact -Dvulas.core.appContext.version = myVersion -jar vulas-cli-jar-with-dependencies.jar -goal clean Clean workspaces (cleanspace) \u00b6 Objective Deletes all applications of the given space. Run as follows CLI java -jar vulas-cli-jar-with-dependencies.jar -goal cleanSpace Maven mvn -Dvulas vulas:cleanSpace","title":"Analysis"},{"location":"user/manuals/analysis/#analysis-manual","text":"","title":"Analysis Manual"},{"location":"user/manuals/analysis/#overview","text":"The various client-side tools offer so-called goals in order to analyze applications and interact with the backend. The following goals perform some sort of application analysis: app : Creates a method-level bill of material of an application and all its dependencies. a2c : Builds a call graph (starting from app methods) and checks whether vulnerable code is potentially executable (reachable). test : This is not an actual goal implemented by any of the clients, but describes the collection of execution traces by a so-called Java agent that dynamically instruments Java bytecode during JUnit and integration tests. instr : Produces a modified version of Java archives ( static instrumentation ) that can be deployed/executed in order to collect traces of actual method executions. t2c : Builds a call graph (starting from traced methods) and checks whether vulnerable code is potentially reachable from those. The following goals are related to data management and reporting: upload : Uploads analysis data previously written to disk to the backend report : Downloads analysis data from the backend to the client, produces a result report (HTML, XML, JSON), and throws a build exception in order to break Jenkins jobs clean : Cleans the analysis data of a single app in the backend cleanspace : Cleans an entire workspace in the backend Which goals are supported by the different clients, and how-to configure and execute them is explained in the following subsections. Note that all goal executions (including configuration settings and statistics) are shown on the \"History\" tab of the respective applications. Important: Make sure to understand the following before proceeding: app has to be executed before all the other analysis goals in order to detect all application dependencies with vulnerable code. Once it has been run, the assessment of findings can already start, each finding of app shown on the \"Vulnerabilities\" tab corresponds to a dependency of an application on a component with a known security vulnerability. The number of findings will not change when running other analysis goals. Instead, a2c , test and t2c try to collect evidence concerning the potential or actual execution of vulnerable code brought up by app . Assess every finding, no matter whether a2c , test and t2c were able to collect evidence or not. Not finding such evidence does not mean that vulnerabilities cannot be exploited. The absence of proof is not a proof of absence (of exploitable vulnerabilities). Prerequisites: A workspace has been created and its token is known Java 7 or later is installed Maven: The plugin is available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Limitations : The reachability analysis (goals a2c and t2c ) does not work with Java 9, as the underlying analysis frameworks do not support it. Prerequisites A workspace has been created and its token is known Java 7 or later is installed Maven: The vulnerability-assessment-tool Maven plugin must be available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Java 9 support The reachability analysis (goals a2c and t2c ) is not supported with Java 9, due to limitations of the 3 rd -party analysis frameworks that vulnerability-assessment-tool relies upon.","title":"Overview"},{"location":"user/manuals/analysis/#bill-of-material-analysis-app","text":"","title":"Bill of material analysis (app)"},{"location":"user/manuals/analysis/#reachable-from-app-a2c","text":"","title":"Reachable from app (a2c)"},{"location":"user/manuals/analysis/#dynamic-instrumentation-junit","text":"","title":"Dynamic instrumentation (JUnit)"},{"location":"user/manuals/analysis/#dynamic-instrumentation-jvm","text":"","title":"Dynamic instrumentation (JVM)"},{"location":"user/manuals/analysis/#static-instrumentation-instr","text":"","title":"Static instrumentation (instr)"},{"location":"user/manuals/analysis/#reachable-from-traces-t2c","text":"","title":"Reachable from traces (t2c)"},{"location":"user/manuals/analysis/#upload-analysis-files-upload","text":"","title":"Upload analysis files (upload)"},{"location":"user/manuals/analysis/#create-result-report-report","text":"","title":"Create result report (report)"},{"location":"user/manuals/analysis/#clean-and-delete-apps-clean","text":"","title":"Clean and delete apps (clean)"},{"location":"user/manuals/analysis/#clean-workspaces-cleanspace","text":"","title":"Clean workspaces (cleanspace)"},{"location":"user/manuals/assess_and_mitigate/","text":"Assessment and Mitigation Manual \u00b6 The presence of vulnerable open-source code must be assessed . If the vulnerability IS NOT considered exploitable, it can be exempted . If it IS considered exploitable, it has to be mitigated . Assess \u00b6 You can start to assess vulnerability-assessment-tool findings as soon as you ran the app analysis goal. Assessing means to clarify whether the respective vulnerability is exploitable in the given application context. The other analysis goals provide further evidence in regards to whether vulnerable code is executable, which is a prerequisite for being exploitable, but they do not bring up new findings. A finding (table row) in the Vulnerabilities tab represents a tuple (library, vulnerability). Depending on whether the library contains the vulnerable or the fixed code , the column Inclusion of vulnerable code contains one of the following icons: Green exclamation mark : The library version in use contains the fixed code for the respective vulnerability, hence, is not affected. Such historical vulnerabilities do not need to be assessed and mitigated. Red exclamation mark : The library version in use contains the vulnerable code, hence, is affected by the respective vulnerability, and the finding requires assessment. A findings should be mitigated if considered exploitable (see below). A finding can be exempted if it is not considered exploitable. Orange Hourglass : It is unclear whether the library version in use contains the vulnerable or the fixed code. Hourglasses are resolved by the vulnerability-assessment-tool operations team (automatically or manually) by comparing the source or byte code of the library in question with the vulnerable and fixed code. Depending on whether the source or byte code of the library is available, e.g., in Maven Central or PyPi, this can take more or less time. Static and Dynamic Analysis \u00b6 The columns Static Analysis and Dynamic Analysis provide information whether vulnerable code can be potentially executed (according to static call graph construction and analysis), or whether its execution has been observed during the execution of tests. Warning You cannot simply ignore a vulnerability just because no red icon is shown. In other words: We suggest to always look at all vulnerabilities, regardless of whether there are indicators in those two columns. The main reasons are: Deserialization vulnerabilities , whose exploitation does not require that vulnerable code is executed during normal program execution, and the fact that both static and dynamic analyses can also be subject to false-positives and false-negatives. Dependency scope \u00b6 Make sure to understand this important Maven concept, refer to the official documentation for details. Typically, TEST and PROVIDED dependencies are not bundled with your application. In other words, when you or your customers deploy the application, libraries in scope TEST and PROVIDED are not included, therefore, vulnerabilities in these dependencies are less critical for you than those in other scopes (the party operating the platform should address them). Direct vs. transitive dependencies \u00b6 You need to assess vulnerabilities regardless of whether they concern direct or transitive dependencies. The reason is that the exploitability of a vulnerability is independent of this aspect. CVSS score \u00b6 All vulnerabilities shall be assessed, no matter the CVSS score. The severity of open-source vulnerabilities significantly depends on the application-specific context (in which the open-source component is used). Thus, the actual severity can differ significantly from the (context-independent) CVSS base score provided by 3 rd parties such as the Mitre/NVD. Exempt \u00b6 If vulnerable code is NOT considered exploitable in a given application context, the respective finding (or an entire scope) can be exempted. This can be done by specifying additional configuration settings, preferably in a dedicated properties file (e.g., vulas-exemptions.properties ). Keeping exemptions in a dedicated file avoids the risk of making accidental changes to other settings. Storing such a dedicated file in the source code repository of the application under analysis, thus making the file subject to version control, has the advantage of tracking modifications in terms of date and author. The settings required to create exemptions are described in the section report goal . Mitigate \u00b6 If vulnerable code is considered exploitable in a given application context, there are several ways to fix the dependency on the vulnerable open-source component: Remove dependency (ideal) \u00b6 If possible, removing a dependency from your application is the ideal solution. It will not only avoid the dependency on a given library with known vulnerabilities but also reduce (a) the size of your application's deployable artifact and (b) the application's attack surface. The analysis goals a2c , test and t2c can support you in assessing whether or not the removal is possible at all. Running those goals will populate the 2 right-most columns of the table in the Dependencies tab, hence, you will see whether library constructs are potentially executable or actually executed. Direct dependencies can be removed by deleting the respective <dependency> section. Transitive dependencies can be removed by adding an <exclusions> section to the respective direct <dependency> (s), cf. Dependency Exclusions for more details. Update dependency (default) \u00b6 An update is the default solution for fixing a dependency with known-vulnerabilities. It is possible for the majority of vulnerabilities in the vulnerability-assessment-tool Vulnerability Database. Direct dependencies can be updated by declaring a non-vulnerable version in the respective <dependency> section. Transitive dependencies can be updated by two means: Preferably, by updating the direct <dependency> that is responsible for pulling the vulnerable transitive dependency into your project. Use mvn dependency:tree or the IDE of your choice to identify this to-be-updated direct dependency (cf. screenshot, where the transitive dependency ognl:3.0.6 is pulled in through the direct dependency struts2-core:2.3.24 into the application vulas-testapp-webapp:2.3.8). If there's no updated version of the direct dependency available that solves the problem, you need to declare a direct <dependency> on a non-vulnerable version. This will override the version resulting from the use of the direct dependency. However, as this solution breaks the transparency of the dependency resolution mechanism, it is advisable to add a corresponding comment to your pom.xml or build.gradle and revisit the dependency every now and then. Sometimes, the vulnerable dependency is pulled into your project through a component developed by colleagues. In this case, please ask your colleagues to provide a fixed version that avoids pulling in vulnerable open-source. Like this, every other user of the respective component will be able to solve the problem by a simple update. Fixing the library (exceptional) \u00b6 Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the library means to create a fix for the vulnerability within the source code of the open-source library, which requires a deep understanding of the respective library and vulnerability. If you take that road, make sure to create a pull request so that the original open-source developers check and integrate the fix in the standard. If not, you will need to maintain your fix in the forked version of the library, and any further enhancements of the library will need to be merged into this fork. Special case: Uber JARs So-called Uber JARs are one example where the removal or update of a vulnerable dependency is not easily possible. Such Java archives do not only contain the Java classes of the respective component, but also contain (rebundle) the Java classes of its dependencies. Uber JARs enable the distribution of self-contained \"all-in-one\" Java archives. In order to fix such Uber JARs, one has to clone the source code repository of the respective open source component, fix the version of the dependency whose classes will be included in the Uber JAR, and build the component in order to produce a new, fixed Uber JAR of the component containing the non-vulnerable classes of its dependency. Example: The Java component org.springframework.cloud:spring-cloud-cloudfoundry-connector rebundles jackson-databind . In case the latest version of spring-cloud-cloudfoundry-connector contains a vulnerable version of jackson-databind , one has to clone https://github.com/spring-cloud/spring-cloud-connectors/tree/master/spring-cloud-cloudfoundry-connector , edit build.gradle in order to update the version of jackson-databind , and build a fixed Uber JAR to be used by the application. Important : If you create a fix yourself, make sure to contribute such fixes to the original open source project. Fixing the application (exceptional) \u00b6 Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the applications means to introduce a security control in the application that mitigates a problem in a vulnerable library, which requires a deep understanding of the respective vulnerability. Example: Suppose the library in question is vulnerable to XXE processing . If the developers of the respective library do not (cannot) provide a fix, you could introduce a corresponding sanity check in your application, just before XML documents are handed-over to the library. The analysis goals a2c , test and t2c can support you in identifying the application methods that require a safeguard. Ideally, you can see (a subset of) the execution paths that lead from application code to vulnerable library code. See here to learn about the configuration options of the reachability analyses a2c and t2c .","title":"Assessment and Mitigation"},{"location":"user/manuals/assess_and_mitigate/#assessment-and-mitigation-manual","text":"The presence of vulnerable open-source code must be assessed . If the vulnerability IS NOT considered exploitable, it can be exempted . If it IS considered exploitable, it has to be mitigated .","title":"Assessment and Mitigation Manual"},{"location":"user/manuals/assess_and_mitigate/#assess","text":"You can start to assess vulnerability-assessment-tool findings as soon as you ran the app analysis goal. Assessing means to clarify whether the respective vulnerability is exploitable in the given application context. The other analysis goals provide further evidence in regards to whether vulnerable code is executable, which is a prerequisite for being exploitable, but they do not bring up new findings. A finding (table row) in the Vulnerabilities tab represents a tuple (library, vulnerability). Depending on whether the library contains the vulnerable or the fixed code , the column Inclusion of vulnerable code contains one of the following icons: Green exclamation mark : The library version in use contains the fixed code for the respective vulnerability, hence, is not affected. Such historical vulnerabilities do not need to be assessed and mitigated. Red exclamation mark : The library version in use contains the vulnerable code, hence, is affected by the respective vulnerability, and the finding requires assessment. A findings should be mitigated if considered exploitable (see below). A finding can be exempted if it is not considered exploitable. Orange Hourglass : It is unclear whether the library version in use contains the vulnerable or the fixed code. Hourglasses are resolved by the vulnerability-assessment-tool operations team (automatically or manually) by comparing the source or byte code of the library in question with the vulnerable and fixed code. Depending on whether the source or byte code of the library is available, e.g., in Maven Central or PyPi, this can take more or less time.","title":"Assess"},{"location":"user/manuals/assess_and_mitigate/#static-and-dynamic-analysis","text":"The columns Static Analysis and Dynamic Analysis provide information whether vulnerable code can be potentially executed (according to static call graph construction and analysis), or whether its execution has been observed during the execution of tests. Warning You cannot simply ignore a vulnerability just because no red icon is shown. In other words: We suggest to always look at all vulnerabilities, regardless of whether there are indicators in those two columns. The main reasons are: Deserialization vulnerabilities , whose exploitation does not require that vulnerable code is executed during normal program execution, and the fact that both static and dynamic analyses can also be subject to false-positives and false-negatives.","title":"Static and Dynamic Analysis"},{"location":"user/manuals/assess_and_mitigate/#dependency-scope","text":"Make sure to understand this important Maven concept, refer to the official documentation for details. Typically, TEST and PROVIDED dependencies are not bundled with your application. In other words, when you or your customers deploy the application, libraries in scope TEST and PROVIDED are not included, therefore, vulnerabilities in these dependencies are less critical for you than those in other scopes (the party operating the platform should address them).","title":"Dependency scope"},{"location":"user/manuals/assess_and_mitigate/#direct-vs-transitive-dependencies","text":"You need to assess vulnerabilities regardless of whether they concern direct or transitive dependencies. The reason is that the exploitability of a vulnerability is independent of this aspect.","title":"Direct vs. transitive dependencies"},{"location":"user/manuals/assess_and_mitigate/#cvss-score","text":"All vulnerabilities shall be assessed, no matter the CVSS score. The severity of open-source vulnerabilities significantly depends on the application-specific context (in which the open-source component is used). Thus, the actual severity can differ significantly from the (context-independent) CVSS base score provided by 3 rd parties such as the Mitre/NVD.","title":"CVSS score"},{"location":"user/manuals/assess_and_mitigate/#exempt","text":"If vulnerable code is NOT considered exploitable in a given application context, the respective finding (or an entire scope) can be exempted. This can be done by specifying additional configuration settings, preferably in a dedicated properties file (e.g., vulas-exemptions.properties ). Keeping exemptions in a dedicated file avoids the risk of making accidental changes to other settings. Storing such a dedicated file in the source code repository of the application under analysis, thus making the file subject to version control, has the advantage of tracking modifications in terms of date and author. The settings required to create exemptions are described in the section report goal .","title":"Exempt"},{"location":"user/manuals/assess_and_mitigate/#mitigate","text":"If vulnerable code is considered exploitable in a given application context, there are several ways to fix the dependency on the vulnerable open-source component:","title":"Mitigate"},{"location":"user/manuals/assess_and_mitigate/#remove-dependency-ideal","text":"If possible, removing a dependency from your application is the ideal solution. It will not only avoid the dependency on a given library with known vulnerabilities but also reduce (a) the size of your application's deployable artifact and (b) the application's attack surface. The analysis goals a2c , test and t2c can support you in assessing whether or not the removal is possible at all. Running those goals will populate the 2 right-most columns of the table in the Dependencies tab, hence, you will see whether library constructs are potentially executable or actually executed. Direct dependencies can be removed by deleting the respective <dependency> section. Transitive dependencies can be removed by adding an <exclusions> section to the respective direct <dependency> (s), cf. Dependency Exclusions for more details.","title":"Remove dependency (ideal)"},{"location":"user/manuals/assess_and_mitigate/#update-dependency-default","text":"An update is the default solution for fixing a dependency with known-vulnerabilities. It is possible for the majority of vulnerabilities in the vulnerability-assessment-tool Vulnerability Database. Direct dependencies can be updated by declaring a non-vulnerable version in the respective <dependency> section. Transitive dependencies can be updated by two means: Preferably, by updating the direct <dependency> that is responsible for pulling the vulnerable transitive dependency into your project. Use mvn dependency:tree or the IDE of your choice to identify this to-be-updated direct dependency (cf. screenshot, where the transitive dependency ognl:3.0.6 is pulled in through the direct dependency struts2-core:2.3.24 into the application vulas-testapp-webapp:2.3.8). If there's no updated version of the direct dependency available that solves the problem, you need to declare a direct <dependency> on a non-vulnerable version. This will override the version resulting from the use of the direct dependency. However, as this solution breaks the transparency of the dependency resolution mechanism, it is advisable to add a corresponding comment to your pom.xml or build.gradle and revisit the dependency every now and then. Sometimes, the vulnerable dependency is pulled into your project through a component developed by colleagues. In this case, please ask your colleagues to provide a fixed version that avoids pulling in vulnerable open-source. Like this, every other user of the respective component will be able to solve the problem by a simple update.","title":"Update dependency (default)"},{"location":"user/manuals/assess_and_mitigate/#fixing-the-library-exceptional","text":"Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the library means to create a fix for the vulnerability within the source code of the open-source library, which requires a deep understanding of the respective library and vulnerability. If you take that road, make sure to create a pull request so that the original open-source developers check and integrate the fix in the standard. If not, you will need to maintain your fix in the forked version of the library, and any further enhancements of the library will need to be merged into this fork. Special case: Uber JARs So-called Uber JARs are one example where the removal or update of a vulnerable dependency is not easily possible. Such Java archives do not only contain the Java classes of the respective component, but also contain (rebundle) the Java classes of its dependencies. Uber JARs enable the distribution of self-contained \"all-in-one\" Java archives. In order to fix such Uber JARs, one has to clone the source code repository of the respective open source component, fix the version of the dependency whose classes will be included in the Uber JAR, and build the component in order to produce a new, fixed Uber JAR of the component containing the non-vulnerable classes of its dependency. Example: The Java component org.springframework.cloud:spring-cloud-cloudfoundry-connector rebundles jackson-databind . In case the latest version of spring-cloud-cloudfoundry-connector contains a vulnerable version of jackson-databind , one has to clone https://github.com/spring-cloud/spring-cloud-connectors/tree/master/spring-cloud-cloudfoundry-connector , edit build.gradle in order to update the version of jackson-databind , and build a fixed Uber JAR to be used by the application. Important : If you create a fix yourself, make sure to contribute such fixes to the original open source project.","title":"Fixing the library (exceptional)"},{"location":"user/manuals/assess_and_mitigate/#fixing-the-application-exceptional","text":"Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the applications means to introduce a security control in the application that mitigates a problem in a vulnerable library, which requires a deep understanding of the respective vulnerability. Example: Suppose the library in question is vulnerable to XXE processing . If the developers of the respective library do not (cannot) provide a fix, you could introduce a corresponding sanity check in your application, just before XML documents are handed-over to the library. The analysis goals a2c , test and t2c can support you in identifying the application methods that require a safeguard. Ideally, you can see (a subset of) the execution paths that lead from application code to vulnerable library code. See here to learn about the configuration options of the reachability analyses a2c and t2c .","title":"Fixing the application (exceptional)"},{"location":"user/manuals/frontend/","text":"Frontend Manual \u00b6 This guide describe the different views of the apps Web frontend. The sections describing each view can be reached by following the ? icon in the top-right corner of the frontend view itself. Start page \u00b6 The start page is displayed when opening the URL of the vulnerability-assessment-tool Web Frontend (usually following a link looking like http://localhost:8033/apps ) in the browser: The table displayed on the left contains a subset of the applications analyzed by vulnerability-assessment-tool. Each application is identified by a triple (group, artifact, version), but only artifact and version are shown in the table. When selecting an application, the analysis results will be displayed on the right. In case your application is not shown, use the search field on top of the table. It can be used for filtering all applications whose group, artifact or version match the provided search string. Other UI controls highlighted in the screenshot are as follows: Control Description 1 Home Reloads the entire application, no application will be shown on the right 2 Redo Search Re-applies the search criterion 3 Information Information messages to the attention of the user 4 Workspace Identifier of the current workspace - Displayed with Gray background if default workspace and with red background otherwise 5 About Provides information about the application such as version, authors, etc. 6 Help Opens this Wiki page 7 Documentation Provides a link to the Documentation 8 Workspace Creation Tools to create a new workspace 9 Settings Provides the possibility to connect to another backend for loading application analyses (expert user only) and to select a workspace to display 10 Reload Reloads all the applications (use if you want to see the analysis results of an application that did not exist before) Vulnerabilities \u00b6 Objective of view: Provide an overview about vulnerable Open-Source dependencies of an application, together with the information whether vulnerable code of such dependencies (e.g. methods) are potentially or actually executable in the context of the application. UI controls highlighted in the screenshot are as follows: 1 Reset table Removes filters and groups from the table 2 Reload data Reloads the app-specific analysis results from the database (use if you executed vulnerability-assessment-tool goals and want to see its analysis results in the frontend). 3 Toggle historical vulnerabilities Shows and hides the display of historical vulnerabilities, e.g., vulnerabilities that existed in a previous version of the archive. Note: Historical vulnerabilities do not require any action as they do not represent a threat to application security. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 4 Toggle unconfirmed vulnerabilities Shows and hides the display of unconfirmed vulnerabilities, i.e. vulnerabilities which have not yet been confirmed by vulnerability-assessment-tool. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 5 Help Link to the frontend vulnerabilities help page (e.g. this page) 6 Reload application data Objective of table: same as objective of view Data shown: Each row corresponds to a vulnerability in a dependency, e.g., multiple vulnerabilities in the same dependency appear in separate table rows. The three columns to the right show whether vulnerable code is included, whether it is potentially reachable or if it was actually reached (executed) at application runtime. Click on a row in order to open the vulnerability details view Data collected by goal(s): vulas:app (to populate the table rows), vulas:a2c and vulas:t2c to populate the column 'Static Analysis', JUnit and Integration tests to populate the column 'Dynamic Analysis' Empty if: An application has no vulnerable dependencies or no dependencies at all Column Description Dependency Scope (Direct / Transitive) When using the vulnerability-assessment-tool Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as \"transitive\". When using the vulnerability-assessment-tool CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability The identifier of the vulnerability, typically a CVE identifier as used in the NVD. The CVSS score is shown for all vulnerabilities present in the NVD (note that only CVSS v2 is supported), n/a for all others. Inclusion of vulnerable Code Indicates whether the dependency contains vulnerable code. The library version is confirmed to contain vulnerable code The library version is confirmed to contain fixed code (a so-called \"historical vulnerability\") It is unknown whether the library version contains the vulnerable or the fixed code. Note: The vulnerability-assessment-tool admin team will be automatically notified about such cases in order to take a decision Static Analysis: Potential execution of vulnerable code Indicates whether vulnerable code (e.g., methods) are potentially reachable (executable) according to the results of the static source code analysis (performed during vulas:a2c and vulas:t2c). Vulnerable code is potentially reachable, i.e., the application can be executed in such a way that the vulnerable code is reached. Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is found reachable. Library code is reachable, i.e., part of the call graph, but none of the vulnerable code. No library reachable or reachability analysis not performed Dynamic Analysis: Actual execution of vulnerable Code Vulnerable code is executed Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is executed. Library code is executed, but none of the vulnerable code No library code executed or no tests have been performed Vulnerabilities Details \u00b6 Objective of Page: Provide detailed information about the vulnerability, the source code repository of the Open-Source project and the constructs (e.g., methods) that have been touched by the Open-Source developers in order to fix the vulnerability. UI controls highlighted in the screenshot are as follows: Control Description 1 Help Link to the documentation page for Vulnerabilities Details (e.g. this page) 2 Exploit database Opens the search page of the Exploit Database in a new browser window, in order to let you search for exploits for the given vulnerability . Note: You need to manually complete the Captcha in order to start the search. 3 NVD (National Vulnerability Database) Opens a link with more vulnerability information in a new browser window. In most of the cases, it is a page from the NVD. 4 Google Trends Shows whether the given vulnerability was a popular Google search term (thus, received a lot of public interest) over the course of the last 30 days (click to see other time ranges). Objective of table: Provide information whether individual vulnerable constructs (methods or constructors) are contained in the respective library, and whether they are potentially or actually reachable. Data shown: All constructs (methods or constructors) that have been added, modified or deleted by the developers of the Open-Source library in order to fix the respective vulnerability. Data collected by goal(s): Table rows are taken from the bug database, which is maintained by the vulnerability-assessment-tool admin team. The three columns to the right are populated by vulas:app (column 'Contained'), vulas:a2c and vulas:t2c (column 'Reachable'), as well as through the execution of tests (column 'Traced') Empty if: Vulnerabilities that have no known fix or whose fix concerns non-Java files, e.g., XML configuration files. The two right-most columns are empty if the goals vulas:a2c or vulas:t2c have not been executed, or if no tests have been performed Column Description Change Indicates whether the given construct has been ADDed, MODified or DELeted as part of the respective commit (revision) Revision Commit identifier Type Class or Constructor Qualified construct Name (Path) The fully qualified name of the construct, i.e., including package name, class name(s) and parameter types Example: com.acme.Foo$Bar.go(String) , whereby com.acme is a package, Foo and Bar classes and go(String) a method name including a String parameter Contained Indicates whether the respective construct is part of the Java archive or not Note: Very often, the commits of the Open-Source developers also contain changes to their JUnit test classes. Those classes are typically not contained in the released Java archive Reachable Indicates whether the respective construct is part of the call graph built during the vulnerability-assessment-tool goals a2c and t2c Click on the icon in order to see the actual call graph leading to the respective vulnerable code It is part of the call graph It is not part of the call graph (but others constructs of the archive are) No construct of the respective archive is part of the call graph Traced Indicates whether the respective construct has been executed during JUnit or integration tests Click on the icon in order to see the actual call graph leading to the respective vulnerable code It has been executed. In this case, the tooltip contains information about the timestamp of the execution, the number of calls and the goal identifier It has not been executed (but others constructs of the archive have been) No construct of the respective archive has been executed Vulnerable Code Call Graph \u00b6 Objective of graph: Provide information on paths leading to vulnerable methods Data shown: The vulnerable methods are shown as red nodes, while methods part of the application are shown as green nodes. Black edges result from the static source code analysis, while red edges have been collected during test execution. The fully qualified name of methods and constructors as well as archive information is shown when hovering over nodes. Data collected by goal(s): a2c and t2c (black edges), JUnit and integration tests (red edges) Empty if: No paths to vulnerable methods were found UI controls highlighted in the screenshot are as follows: Control Description 1 Collapse graph on library level Collapses all nodes representing methods of the same library into one node. 2 Collapse graph on package level Collapses all nodes representing methods of the same package into one node. 3 Collapse graph on class level Collapses all nodes representing methods of the same class into one node. 4 Expand all Shows the original graph. 5 Collapse nodes Collapses all nodes 6 Help/Documentation Opens the documentation to this page 7 NVD (National vulnerability Database) Opens the NVD for the respective vulnerability in a new browser window. Dependencies \u00b6 Objective of view: Provide an overview about all dependencies of the application, no matter whether they contain vulnerabilities or not Objective of table: Same as objective of view Data shown: All dependencies of the application. Click on a dependency's filename in order to open the dependencies details view Data collected by goal(s): vulas:app and test Empty if: An application has no dependencies at all The content of the table can be detailed as follow: Details Description Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Dependency Scope When using the vulnerability-assessment-tool Maven plugin, the scope corresponds to the Maven scope (see here for more information). When using the vulnerability-assessment-tool CLI, the scope is always 'Runtime'. Direct / Transitive Direct dependencies are declared/required by the application itself, e.g., because the application makes use of a dependency's API. Transitive dependencies are declared/required not by the application but by its dependencies, e.g., because a dependency makes use of another dependency's API. When using the vulnerability-assessment-tool Maven plugin, dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the vulnerability-assessment-tool CLI, the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. SHA1 known to Maven Central true if the SHA1 of the JAR is known to Maven Central , false if not. Dependency declared in POM true if the dependency information was read from the application's POM file using the vulnerability-assessment-tool Maven plugin, false if not. Library constructs potentially executable Number of library constructs potentially reachable (executable), according to the results of the static source code analysis (vulnerability-assessment-tool goals a2c and t2c). This screen provides several additional controls: Control Description 1 Help/Documentation Opens the documentation to this page 2 Reload App Data Reloads the content of the page The following information are displayed on the top of the main table: Name Description Archives Total The total number of archives/files which are dependencies of the application. Archives Traced The number of archives which were traced during the execution of the test goal Total Number of Traces The total number of traces which were generated during the execution of the test goal Dependencies Details \u00b6 Objective of Page: Provide detailed information about a given dependency, including information about the application-specific use and update possibilities. UI controls highlighted in the screenshot are as follows: Control Description 1 Maven Central Shows all versions of the given artifact in Maven Central Example: If the dependency shown is (commons-collections, commons-collections, 3.2.1), all versions of (commons-collections, commons-collections) known to Maven Central will be shown. 2 Help/Documentation Opens the documentation to this page At the top of the view, the following information are provided: Name Description Digest The unique id of the library (for example its SHA1) Digest verified true if the library id could be verified against the library repository, false if not. Dependency Path The path to the dependency. The view contains the following four section: Calls from application to Archive Library size and application-specific use Finding non-vulnerable library versions Archive Properties Calls from application to Archive \u00b6 This section shows direct call interactions between an application and the dependency (independent of any vulnerabilities). This information is useful when deciding about the update of a dependency, e.g., to a more recent version. It is divided into two parts. On the top, a picture presents an overview of these interactions: Name Description Distinct callers The number of distinct constructs in the application which are calling constructs of the library. Distinct callees The number of distinct constructs of the library which are called by constructs of the application. Calls The number of calls from the application to the library Below this picture, details of these interactions are described in a table. Objective of Table:: Shows the details of the interactions between an application and the dependency. Data shown:: Calls of a library method by an application method or vice versa. Data collected by goal(s):: vulas:a2c , vulas:t2c and test . Empty if: Application and library do not directly interact, e.g., as in case of transitive dependencies. None of the goals have been executed. Column Description Caller Fully-qualified name of the calling construct. Caller type **METH**od or **CONS**tructor. Callee Fully-qualified name the called construct. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals vulas:a2c and vulas:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise. Library size and application-specific use \u00b6 Objective of Table: Show the degree of actual and potential use that the application makes of the dependency (independent of any vulnerabilities). Data shown: The absolute number of constructs contains in the library (methods, constructors, etc.) and the number of constructs potentially or actually executable. Data collected by goal(s): vulas:a2c , vulas:t2c and test . Empty if: The dependency is not at all used in the scope of an application or none of the goals have been executed. Column Description Construct Type INIT: Static class initializer CONS: Constructor METH: Method CLASS: Class ENUM: Enumeration PACK: Package countExecutable: INIT + CONS + METH Count Total Absolute number contained in the JAR Count Reachable Number of constructs found reachable during static source code analysis. Count Traced Number of observed constructs during tests Finding non-vulnerable library versions \u00b6 Objective of Table: Support the selection of a more recent, non-vulnerable library version. Data shown: All library versions known to Maven Central, together with the number of vulnerabilities known to vulnerability-assessment-tool. Moreover, the table displays four update metrics computed over the library version currently in use and the respective alternative. Click on a row in order to see details about the removed callees (if any) in the view Calls from application to archive to be modified . Data collected by goal(s): Empty if: Neither the SHA1 nor the Maven identifier (group, artifact, version) of the dependency is known to Maven Central. In this case it is not possible to retrieve alternative versions. Column Description Library Id The Maven identifier in the format group : artifact : version. Count vulnerabilities The number of vulnerabilities known by vulnerability-assessment-tool. Callee stability The share of library callees that exist with the same signature (cf. table 'Calls from application to archive'). Example: If the application directly calls two methods in the current archive and one of those is not any longer present, the callee stability would be '1 out of 2 ( 50% )'. Note: Can be 0 if there are no direct calls between application and library. Dev. effort (calls to modify) The share of application calls that require a modification due to missing callees (cf. table 'Calls from application to archive'). Example: If the application calls a given library method from two of its methods and the library method is no longer present, the development effort would be '2 out of 2 ( 100% )'. Note: Can be 0 if there are no direct calls between application and library (or the respective goals were not run). Reachable body stability The number of reachable constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library (cf. table 'Library size and application-specific use'). Note: Can be 0 if none of the library constructs is reachable from the application (or the respective goals were not run). Overall body stability The number of constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library. Note: This metric is independent of the application-specific use of the library. Archive Properties \u00b6 Objective of Table:: Provide meta-information about the dependency, e.g., its version. Data shown:: All entries of the Manifest file ('META-INF/MANIFEST.MF' in the JAR). Data collected by goal(s):: vulas:app . Empty if: The dependency has no MANIFEST.MF file or it does not contain any entries. Column Description Property Name The name of the Manifest file entry, e.g., 'Built-By'. Property Value The value of the Manifest file entry, e.g., 'Foo'. Callers to be modified \u00b6 Objective of page: Support the developer in updating a dependency to a more recent release by showing him all application methods that require modification. Data shown: All application calls that require a modification because of the fact that a callee method is no more available in the selected library version. Data collected by goal(s): vulas:a2c , vulas:t2c and tests Empty if: Either because there exist no direct method invocations from application to library or all of the callee methods still exist in the selected library version. On the top of the screen some metrics are provided: Name Description Calls to modify The number of calls to be modified in order to use this library version. Distinct callers to modify The number of constructors be modified/updated in the application in order to use this library version. Callees deleted The number of constructs of currently used library (by the application) which no longer exist in this new version of the library. These information are followed by a table providing the details: Name Description Caller the name of the construct of the application calling the library. Callee type The type of the called construct in the library. Callee The name of the called construct in the library. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals vulas:a2c and vulas:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise. Application Statistics \u00b6 Objective of page: Provide an overview about : the application and its dependencies, the application test coverage. Two tables are presented in this page: Dependencies Objective of table: Show statistics about the constructs of the application and its dependencies (methods, functions, packages, classes...). Please notice that these information are excluding the dependencies in the scopes TEST and PROVIDED . In the header of the table user can see the total number of dependencies which were considered. Column Description Construct Type The Types of analyzed constructs. Application The number of constructs (of type defined in column \"Construct Type\") in the application. Total (App + Dependencies) The total number of constructs (of type defined in column \"Construct Type\") of all the project, e.g. application code + dependencies Percentage (app/total) The percentage of code of the application compared to the total code of the project (application + dependencies). Application The second section of this page presents 2 metrics and a table: Name Description Executable application constructs (total) The total number of executable constructs of the application. Executable application constructs (traced) The number of executable constructs of the application which have been traced. Objective of table: Same as objective of view. Data shown: The number of traced constructs per application package. Data collected by goal(s): JUnit and integration tests. Empty if: No tests have been run. Column Description Application Packages Java package of the application. Constructors (traced / total) Number of constructors of classes in the respective package that were traced during tests. Total number of constructors of classes in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise default constructors or constructors with synthetic parameters Methods (traced / total) Number of methods of classes in the respective package that were traced during tests. Total number of methods of classes in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise synthetic methods such as access methods. Functions (traced/total) Number of functions in the respective package that were traced during tests. Total number of functions in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise synthetic functions such as access functions. Static Initializers (traced/total) Number of static analyzers in the respective package that were traced during tests. Total number of static analyzers in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise synthetic functions such as access functions. Test Coverage Percentage of traced constructs (methods, constructors, modules, functions, static initializers). History \u00b6 Objective of view: Provide an overview about goal executions for a given application. Objective of table: Same as objective of view. Data shown: Each row corresponds to one vulnerability-assessment-tool goal execution, click on a row in order to see detailed goal information. Data collected by goal(s): All. Empty if: No goals have been executed. Column Description Status Empty on success, error message in case of failures Goal Goal executed, see here for the list of all goals Started at Start date and time of the goal execution Runtime Total duration of the goal execution in minutes JVM Max.Memory (MB) Max. memory available for the JVM Max. Memory used (MB) Max. memory used by the JVM AVG. Memory used (MB) Average memory used by the JVM vulnerability-assessment-tool Release Release of vulnerability-assessment-tool used By clicking on one item of the list, user will then be able to see the details of the goal execution . History Details \u00b6 Objective of view: Provide detailed information about a given vulnerability-assessment-tool goal execution, mainly for root cause analysis of problems. This view presents the following metrics: Name Description Goal Execution ID Unique ID associated to the goal execution. Started At The date/time when this goal was executed on the client. The view also contains the following three tables: Goal statistics Goal configuration System information Goal statistics Data shown: Statistics collected at goal runtime. Data collected by goal(s): All. Empty if: Should never be empty. Column >Description Property Name Name of the metric. Property Value Value of the metric. Goal configuration Data shown: Configuration settings used for the goal execution. Data collected by goal(s): All. Empty if: Should never be empty. Column Description Property Name Name of the configuration setting. Property Value Value of the configuration setting. System information Data shown: Java system properties and environment variables collected on the client during the goal execution. The configuration settings vulas.shared.sys and vulas.shared.env determine which information is collected: # Comma-separated list of environment variables gathered during goal execution and transferred to the backend # A given environment variable is considered if its name equals one of the values (case-insensitive) # # Default: 18 variables vulas.shared.env = PROCESSOR_IDENTIFIER, NUMBER_OF_PROCESSORS, PROCESSOR_LEVEL, PROCESSOR_ARCHITECTURE, PROCESSOR_REVISION, \\ JAVA_HOME, COMPUTERNAME, \\ MAVEN_PROJECTBASEDIR, MAVEN_HOME, MAVEN_CONFIG, MAVEN_OPTS, \\ BUILD_URL, BUILD_TAG, BUILD_TIMESTAMP, BUILD_DISPLAY_NAME, BUILD_ID, BUILD_NUMBER, BUILD_VERSION # Extension of the above list # Default: - #vulas.shared.env.custom # Comma-separated list of system property namespaces gathered during goal execution and transferred to the backend # A given system property is considered if it starts with one of those namespaces (case-insensitive) # # Default: 6 patterns vulas.shared.sys = user., os., java., runtime., maven., sun. # Extension of the above list # Default: - #vulas.shared.sys.custom Data collected by goal(s): All. Empty if: Should never be empty. Column >Description Property Name Name of the system/environment setting. Property Value Value of the system/environment setting. Search \u00b6 Objective of view: Search for constructs in application dependencies. Objective of table: Same as objective of view. Data shown: Archives that contain one or more constructs (methods, classes, packages, etc.) that match the search expression. Data collected by goal(s): N/a. Empty if: If the search did not yield a result. Mitigation \u00b6 Objective of view: Get an overview about vulnerable archives that require a fix. Objective of table: Same as objective of view. Data shown: Archives that have one or more known vulnerabilities, click on a row in order to see update proposals and metrics in the dependencies details view . Data collected by goal(s): vulas:app . Empty if: An application has no vulnerable dependencies. Column Description Dependency scope (Direct/Transitive) When using the vulnerability-assessment-tool Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the vulnerability-assessment-tool CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability # Number of known vulnerabilities of a dependency.","title":"Frontend"},{"location":"user/manuals/frontend/#frontend-manual","text":"This guide describe the different views of the apps Web frontend. The sections describing each view can be reached by following the ? icon in the top-right corner of the frontend view itself.","title":"Frontend Manual"},{"location":"user/manuals/frontend/#start-page","text":"The start page is displayed when opening the URL of the vulnerability-assessment-tool Web Frontend (usually following a link looking like http://localhost:8033/apps ) in the browser: The table displayed on the left contains a subset of the applications analyzed by vulnerability-assessment-tool. Each application is identified by a triple (group, artifact, version), but only artifact and version are shown in the table. When selecting an application, the analysis results will be displayed on the right. In case your application is not shown, use the search field on top of the table. It can be used for filtering all applications whose group, artifact or version match the provided search string. Other UI controls highlighted in the screenshot are as follows: Control Description 1 Home Reloads the entire application, no application will be shown on the right 2 Redo Search Re-applies the search criterion 3 Information Information messages to the attention of the user 4 Workspace Identifier of the current workspace - Displayed with Gray background if default workspace and with red background otherwise 5 About Provides information about the application such as version, authors, etc. 6 Help Opens this Wiki page 7 Documentation Provides a link to the Documentation 8 Workspace Creation Tools to create a new workspace 9 Settings Provides the possibility to connect to another backend for loading application analyses (expert user only) and to select a workspace to display 10 Reload Reloads all the applications (use if you want to see the analysis results of an application that did not exist before)","title":"Start page"},{"location":"user/manuals/frontend/#vulnerabilities","text":"Objective of view: Provide an overview about vulnerable Open-Source dependencies of an application, together with the information whether vulnerable code of such dependencies (e.g. methods) are potentially or actually executable in the context of the application. UI controls highlighted in the screenshot are as follows: 1 Reset table Removes filters and groups from the table 2 Reload data Reloads the app-specific analysis results from the database (use if you executed vulnerability-assessment-tool goals and want to see its analysis results in the frontend). 3 Toggle historical vulnerabilities Shows and hides the display of historical vulnerabilities, e.g., vulnerabilities that existed in a previous version of the archive. Note: Historical vulnerabilities do not require any action as they do not represent a threat to application security. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 4 Toggle unconfirmed vulnerabilities Shows and hides the display of unconfirmed vulnerabilities, i.e. vulnerabilities which have not yet been confirmed by vulnerability-assessment-tool. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 5 Help Link to the frontend vulnerabilities help page (e.g. this page) 6 Reload application data Objective of table: same as objective of view Data shown: Each row corresponds to a vulnerability in a dependency, e.g., multiple vulnerabilities in the same dependency appear in separate table rows. The three columns to the right show whether vulnerable code is included, whether it is potentially reachable or if it was actually reached (executed) at application runtime. Click on a row in order to open the vulnerability details view Data collected by goal(s): vulas:app (to populate the table rows), vulas:a2c and vulas:t2c to populate the column 'Static Analysis', JUnit and Integration tests to populate the column 'Dynamic Analysis' Empty if: An application has no vulnerable dependencies or no dependencies at all Column Description Dependency Scope (Direct / Transitive) When using the vulnerability-assessment-tool Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as \"transitive\". When using the vulnerability-assessment-tool CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability The identifier of the vulnerability, typically a CVE identifier as used in the NVD. The CVSS score is shown for all vulnerabilities present in the NVD (note that only CVSS v2 is supported), n/a for all others. Inclusion of vulnerable Code Indicates whether the dependency contains vulnerable code. The library version is confirmed to contain vulnerable code The library version is confirmed to contain fixed code (a so-called \"historical vulnerability\") It is unknown whether the library version contains the vulnerable or the fixed code. Note: The vulnerability-assessment-tool admin team will be automatically notified about such cases in order to take a decision Static Analysis: Potential execution of vulnerable code Indicates whether vulnerable code (e.g., methods) are potentially reachable (executable) according to the results of the static source code analysis (performed during vulas:a2c and vulas:t2c). Vulnerable code is potentially reachable, i.e., the application can be executed in such a way that the vulnerable code is reached. Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is found reachable. Library code is reachable, i.e., part of the call graph, but none of the vulnerable code. No library reachable or reachability analysis not performed Dynamic Analysis: Actual execution of vulnerable Code Vulnerable code is executed Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is executed. Library code is executed, but none of the vulnerable code No library code executed or no tests have been performed","title":"Vulnerabilities"},{"location":"user/manuals/frontend/#vulnerabilities-details","text":"Objective of Page: Provide detailed information about the vulnerability, the source code repository of the Open-Source project and the constructs (e.g., methods) that have been touched by the Open-Source developers in order to fix the vulnerability. UI controls highlighted in the screenshot are as follows: Control Description 1 Help Link to the documentation page for Vulnerabilities Details (e.g. this page) 2 Exploit database Opens the search page of the Exploit Database in a new browser window, in order to let you search for exploits for the given vulnerability . Note: You need to manually complete the Captcha in order to start the search. 3 NVD (National Vulnerability Database) Opens a link with more vulnerability information in a new browser window. In most of the cases, it is a page from the NVD. 4 Google Trends Shows whether the given vulnerability was a popular Google search term (thus, received a lot of public interest) over the course of the last 30 days (click to see other time ranges). Objective of table: Provide information whether individual vulnerable constructs (methods or constructors) are contained in the respective library, and whether they are potentially or actually reachable. Data shown: All constructs (methods or constructors) that have been added, modified or deleted by the developers of the Open-Source library in order to fix the respective vulnerability. Data collected by goal(s): Table rows are taken from the bug database, which is maintained by the vulnerability-assessment-tool admin team. The three columns to the right are populated by vulas:app (column 'Contained'), vulas:a2c and vulas:t2c (column 'Reachable'), as well as through the execution of tests (column 'Traced') Empty if: Vulnerabilities that have no known fix or whose fix concerns non-Java files, e.g., XML configuration files. The two right-most columns are empty if the goals vulas:a2c or vulas:t2c have not been executed, or if no tests have been performed Column Description Change Indicates whether the given construct has been ADDed, MODified or DELeted as part of the respective commit (revision) Revision Commit identifier Type Class or Constructor Qualified construct Name (Path) The fully qualified name of the construct, i.e., including package name, class name(s) and parameter types Example: com.acme.Foo$Bar.go(String) , whereby com.acme is a package, Foo and Bar classes and go(String) a method name including a String parameter Contained Indicates whether the respective construct is part of the Java archive or not Note: Very often, the commits of the Open-Source developers also contain changes to their JUnit test classes. Those classes are typically not contained in the released Java archive Reachable Indicates whether the respective construct is part of the call graph built during the vulnerability-assessment-tool goals a2c and t2c Click on the icon in order to see the actual call graph leading to the respective vulnerable code It is part of the call graph It is not part of the call graph (but others constructs of the archive are) No construct of the respective archive is part of the call graph Traced Indicates whether the respective construct has been executed during JUnit or integration tests Click on the icon in order to see the actual call graph leading to the respective vulnerable code It has been executed. In this case, the tooltip contains information about the timestamp of the execution, the number of calls and the goal identifier It has not been executed (but others constructs of the archive have been) No construct of the respective archive has been executed","title":"Vulnerabilities Details"},{"location":"user/manuals/frontend/#vulnerable-code-call-graph","text":"Objective of graph: Provide information on paths leading to vulnerable methods Data shown: The vulnerable methods are shown as red nodes, while methods part of the application are shown as green nodes. Black edges result from the static source code analysis, while red edges have been collected during test execution. The fully qualified name of methods and constructors as well as archive information is shown when hovering over nodes. Data collected by goal(s): a2c and t2c (black edges), JUnit and integration tests (red edges) Empty if: No paths to vulnerable methods were found UI controls highlighted in the screenshot are as follows: Control Description 1 Collapse graph on library level Collapses all nodes representing methods of the same library into one node. 2 Collapse graph on package level Collapses all nodes representing methods of the same package into one node. 3 Collapse graph on class level Collapses all nodes representing methods of the same class into one node. 4 Expand all Shows the original graph. 5 Collapse nodes Collapses all nodes 6 Help/Documentation Opens the documentation to this page 7 NVD (National vulnerability Database) Opens the NVD for the respective vulnerability in a new browser window.","title":"Vulnerable Code Call Graph"},{"location":"user/manuals/frontend/#dependencies","text":"Objective of view: Provide an overview about all dependencies of the application, no matter whether they contain vulnerabilities or not Objective of table: Same as objective of view Data shown: All dependencies of the application. Click on a dependency's filename in order to open the dependencies details view Data collected by goal(s): vulas:app and test Empty if: An application has no dependencies at all The content of the table can be detailed as follow: Details Description Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Dependency Scope When using the vulnerability-assessment-tool Maven plugin, the scope corresponds to the Maven scope (see here for more information). When using the vulnerability-assessment-tool CLI, the scope is always 'Runtime'. Direct / Transitive Direct dependencies are declared/required by the application itself, e.g., because the application makes use of a dependency's API. Transitive dependencies are declared/required not by the application but by its dependencies, e.g., because a dependency makes use of another dependency's API. When using the vulnerability-assessment-tool Maven plugin, dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the vulnerability-assessment-tool CLI, the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. SHA1 known to Maven Central true if the SHA1 of the JAR is known to Maven Central , false if not. Dependency declared in POM true if the dependency information was read from the application's POM file using the vulnerability-assessment-tool Maven plugin, false if not. Library constructs potentially executable Number of library constructs potentially reachable (executable), according to the results of the static source code analysis (vulnerability-assessment-tool goals a2c and t2c). This screen provides several additional controls: Control Description 1 Help/Documentation Opens the documentation to this page 2 Reload App Data Reloads the content of the page The following information are displayed on the top of the main table: Name Description Archives Total The total number of archives/files which are dependencies of the application. Archives Traced The number of archives which were traced during the execution of the test goal Total Number of Traces The total number of traces which were generated during the execution of the test goal","title":"Dependencies"},{"location":"user/manuals/frontend/#dependencies-details","text":"Objective of Page: Provide detailed information about a given dependency, including information about the application-specific use and update possibilities. UI controls highlighted in the screenshot are as follows: Control Description 1 Maven Central Shows all versions of the given artifact in Maven Central Example: If the dependency shown is (commons-collections, commons-collections, 3.2.1), all versions of (commons-collections, commons-collections) known to Maven Central will be shown. 2 Help/Documentation Opens the documentation to this page At the top of the view, the following information are provided: Name Description Digest The unique id of the library (for example its SHA1) Digest verified true if the library id could be verified against the library repository, false if not. Dependency Path The path to the dependency. The view contains the following four section: Calls from application to Archive Library size and application-specific use Finding non-vulnerable library versions Archive Properties","title":"Dependencies Details"},{"location":"user/manuals/frontend/#calls-from-application-to-archive","text":"This section shows direct call interactions between an application and the dependency (independent of any vulnerabilities). This information is useful when deciding about the update of a dependency, e.g., to a more recent version. It is divided into two parts. On the top, a picture presents an overview of these interactions: Name Description Distinct callers The number of distinct constructs in the application which are calling constructs of the library. Distinct callees The number of distinct constructs of the library which are called by constructs of the application. Calls The number of calls from the application to the library Below this picture, details of these interactions are described in a table. Objective of Table:: Shows the details of the interactions between an application and the dependency. Data shown:: Calls of a library method by an application method or vice versa. Data collected by goal(s):: vulas:a2c , vulas:t2c and test . Empty if: Application and library do not directly interact, e.g., as in case of transitive dependencies. None of the goals have been executed. Column Description Caller Fully-qualified name of the calling construct. Caller type **METH**od or **CONS**tructor. Callee Fully-qualified name the called construct. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals vulas:a2c and vulas:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise.","title":"Calls from application to Archive"},{"location":"user/manuals/frontend/#library-size-and-application-specific-use","text":"Objective of Table: Show the degree of actual and potential use that the application makes of the dependency (independent of any vulnerabilities). Data shown: The absolute number of constructs contains in the library (methods, constructors, etc.) and the number of constructs potentially or actually executable. Data collected by goal(s): vulas:a2c , vulas:t2c and test . Empty if: The dependency is not at all used in the scope of an application or none of the goals have been executed. Column Description Construct Type INIT: Static class initializer CONS: Constructor METH: Method CLASS: Class ENUM: Enumeration PACK: Package countExecutable: INIT + CONS + METH Count Total Absolute number contained in the JAR Count Reachable Number of constructs found reachable during static source code analysis. Count Traced Number of observed constructs during tests","title":"Library size and application-specific use"},{"location":"user/manuals/frontend/#finding-non-vulnerable-library-versions","text":"Objective of Table: Support the selection of a more recent, non-vulnerable library version. Data shown: All library versions known to Maven Central, together with the number of vulnerabilities known to vulnerability-assessment-tool. Moreover, the table displays four update metrics computed over the library version currently in use and the respective alternative. Click on a row in order to see details about the removed callees (if any) in the view Calls from application to archive to be modified . Data collected by goal(s): Empty if: Neither the SHA1 nor the Maven identifier (group, artifact, version) of the dependency is known to Maven Central. In this case it is not possible to retrieve alternative versions. Column Description Library Id The Maven identifier in the format group : artifact : version. Count vulnerabilities The number of vulnerabilities known by vulnerability-assessment-tool. Callee stability The share of library callees that exist with the same signature (cf. table 'Calls from application to archive'). Example: If the application directly calls two methods in the current archive and one of those is not any longer present, the callee stability would be '1 out of 2 ( 50% )'. Note: Can be 0 if there are no direct calls between application and library. Dev. effort (calls to modify) The share of application calls that require a modification due to missing callees (cf. table 'Calls from application to archive'). Example: If the application calls a given library method from two of its methods and the library method is no longer present, the development effort would be '2 out of 2 ( 100% )'. Note: Can be 0 if there are no direct calls between application and library (or the respective goals were not run). Reachable body stability The number of reachable constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library (cf. table 'Library size and application-specific use'). Note: Can be 0 if none of the library constructs is reachable from the application (or the respective goals were not run). Overall body stability The number of constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library. Note: This metric is independent of the application-specific use of the library.","title":"Finding non-vulnerable library versions"},{"location":"user/manuals/frontend/#archive-properties","text":"Objective of Table:: Provide meta-information about the dependency, e.g., its version. Data shown:: All entries of the Manifest file ('META-INF/MANIFEST.MF' in the JAR). Data collected by goal(s):: vulas:app . Empty if: The dependency has no MANIFEST.MF file or it does not contain any entries. Column Description Property Name The name of the Manifest file entry, e.g., 'Built-By'. Property Value The value of the Manifest file entry, e.g., 'Foo'.","title":"Archive Properties"},{"location":"user/manuals/frontend/#callers-to-be-modified","text":"Objective of page: Support the developer in updating a dependency to a more recent release by showing him all application methods that require modification. Data shown: All application calls that require a modification because of the fact that a callee method is no more available in the selected library version. Data collected by goal(s): vulas:a2c , vulas:t2c and tests Empty if: Either because there exist no direct method invocations from application to library or all of the callee methods still exist in the selected library version. On the top of the screen some metrics are provided: Name Description Calls to modify The number of calls to be modified in order to use this library version. Distinct callers to modify The number of constructors be modified/updated in the application in order to use this library version. Callees deleted The number of constructs of currently used library (by the application) which no longer exist in this new version of the library. These information are followed by a table providing the details: Name Description Caller the name of the construct of the application calling the library. Callee type The type of the called construct in the library. Callee The name of the called construct in the library. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals vulas:a2c and vulas:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise.","title":"Callers to be modified"},{"location":"user/manuals/frontend/#application-statistics","text":"Objective of page: Provide an overview about : the application and its dependencies, the application test coverage. Two tables are presented in this page:","title":"Application Statistics"},{"location":"user/manuals/frontend/#history","text":"Objective of view: Provide an overview about goal executions for a given application. Objective of table: Same as objective of view. Data shown: Each row corresponds to one vulnerability-assessment-tool goal execution, click on a row in order to see detailed goal information. Data collected by goal(s): All. Empty if: No goals have been executed. Column Description Status Empty on success, error message in case of failures Goal Goal executed, see here for the list of all goals Started at Start date and time of the goal execution Runtime Total duration of the goal execution in minutes JVM Max.Memory (MB) Max. memory available for the JVM Max. Memory used (MB) Max. memory used by the JVM AVG. Memory used (MB) Average memory used by the JVM vulnerability-assessment-tool Release Release of vulnerability-assessment-tool used By clicking on one item of the list, user will then be able to see the details of the goal execution .","title":"History"},{"location":"user/manuals/frontend/#history-details","text":"Objective of view: Provide detailed information about a given vulnerability-assessment-tool goal execution, mainly for root cause analysis of problems. This view presents the following metrics: Name Description Goal Execution ID Unique ID associated to the goal execution. Started At The date/time when this goal was executed on the client. The view also contains the following three tables: Goal statistics Goal configuration System information","title":"History Details"},{"location":"user/manuals/frontend/#search","text":"Objective of view: Search for constructs in application dependencies. Objective of table: Same as objective of view. Data shown: Archives that contain one or more constructs (methods, classes, packages, etc.) that match the search expression. Data collected by goal(s): N/a. Empty if: If the search did not yield a result.","title":"Search"},{"location":"user/manuals/frontend/#mitigation","text":"Objective of view: Get an overview about vulnerable archives that require a fix. Objective of table: Same as objective of view. Data shown: Archives that have one or more known vulnerabilities, click on a row in order to see update proposals and metrics in the dependencies details view . Data collected by goal(s): vulas:app . Empty if: An application has no vulnerable dependencies. Column Description Dependency scope (Direct/Transitive) When using the vulnerability-assessment-tool Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the vulnerability-assessment-tool CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability # Number of known vulnerabilities of a dependency.","title":"Mitigation"},{"location":"user/manuals/report/","text":"Report Manual \u00b6 Introduction \u00b6 The reports are generated after the execution of the report goal. They are generated in three different formats (JSON, XML and HTML). See the report goal documentation section . We will mainly present the HTML version in this documentation. Reports come with the advantage of having an aggregate view on a set of modules. They can mainly be divided into two parts. Report Header \u00b6 The report header contains general information about the scanned module(s). It provides: The date & time the report was created. The information if the report is an aggregated report or not. The list of projects/modules included in this report. The settings used to generate the report (in the \"Plugin Configuration\" section). The conclusion of the exceution of the \"report\" goal. It is displayed in red when the relevant vulnerabilities were found. Relevant is to be understood as relevant againts the provided settings for the scan, e.g. considering the different settings provided by the user. Report Core \u00b6 The report \"core\" contains the list of findings. This part is basically was can be seen when opening the Frontend. Please notice that the \"core\" section could be empty in case no vulnerability could be identified into the scanned project(s). This list contains the complete list of vulnerabilities identified in the scanned project(s), including assessed and mitigated ones. CVEs listed with a red background color and for which the text in the \"Applications including vulnerable code\" column is red are vulnerabilities impacting the scanned project(s). CVEs with a white background and for which the text in the \"Applications including vulnerable code\" column is greyed out are assessed vulnerabilities.","title":"Report"},{"location":"user/manuals/report/#report-manual","text":"","title":"Report Manual"},{"location":"user/manuals/report/#introduction","text":"The reports are generated after the execution of the report goal. They are generated in three different formats (JSON, XML and HTML). See the report goal documentation section . We will mainly present the HTML version in this documentation. Reports come with the advantage of having an aggregate view on a set of modules. They can mainly be divided into two parts.","title":"Introduction"},{"location":"user/manuals/report/#report-header","text":"The report header contains general information about the scanned module(s). It provides: The date & time the report was created. The information if the report is an aggregated report or not. The list of projects/modules included in this report. The settings used to generate the report (in the \"Plugin Configuration\" section). The conclusion of the exceution of the \"report\" goal. It is displayed in red when the relevant vulnerabilities were found. Relevant is to be understood as relevant againts the provided settings for the scan, e.g. considering the different settings provided by the user.","title":"Report Header"},{"location":"user/manuals/report/#report-core","text":"The report \"core\" contains the list of findings. This part is basically was can be seen when opening the Frontend. Please notice that the \"core\" section could be empty in case no vulnerability could be identified into the scanned project(s). This list contains the complete list of vulnerabilities identified in the scanned project(s), including assessed and mitigated ones. CVEs listed with a red background color and for which the text in the \"Applications including vulnerable code\" column is red are vulnerabilities impacting the scanned project(s). CVEs with a white background and for which the text in the \"Applications including vulnerable code\" column is greyed out are assessed vulnerabilities.","title":"Report Core"},{"location":"user/manuals/setup/","text":"Setup and Configuration Manual \u00b6 Workspace \u00b6 A workspace acts as a container to group the results of several application analyses. In that context, please note that each module of a multi-module Maven project appears as a separate application in the vulnerability-assessment-tool Web frontend. Before using workspaces, you need to create one using the vulnerability-assessment-tool Web frontend (see below); you will obtain a token that you will need to pass as a configuration parameter when performing scans. Create workspace(s) (once) \u00b6 You need to create a workspace once using the vulnerability-assessment-tool Web frontend. Use the \"create workspace\" icon in the lower-left corner toolbar of the apps Web frontend to do so. A workspace has the following properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL). Export results : AGGREGATED : Findings are aggregated on workspace-level, one item for the entire workspace will be exported DETAILED : Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF : No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s). Use the generated token (during application analysis) \u00b6 The workspace token generated at previous step has to be used as value for the configuration setting vulas.core.space.token . This information is mandatory during the scans as it allows the user's data to be uploaded to the correct place/workspace in the vulnerability-assessment-tool backend. See here for more information regarding the configuration of vulnerability-assessment-tool clients. Choose a workspace (in the apps Web frontend) \u00b6 Use the configuration icon in the lower-left corner in order to select a workspace. You can search for public workspaces by typing their name in the \"Space\" field. You can copy&paste the token of a private workspace into the input field in order to select it. Additional fields \"Backend URL\" and \"Artifact Analyzer URL\" can be used to connect the frontend to another backend (than the default running on the same host). Generally, this must not be changed by the users. Once you have selected a workspace, press \"Save\" button. The list of applications of that workspace will be automatically loaded on the left list menu of the frontend. Edit a workspace (in the apps Web frontend) \u00b6 In order to edit a workspace, press the same button as to choose a workspace and perform the following steps: Enter the name/token id of the workspace to edit in the \"Space\" field and eventually select one of the entries provided in the drop down list. press the \"Edit Space\" button at the bottom. Once this button is clicked, all the editable property-fields of the workspace are displayed. update/change the data of your workspace as per your expectations. Press the \"Save\" button to save your modifications, press the \"close\" button to revert your changes. Export Analysis Results \u00b6 The following REST API can be used to export findings (information about vulnerable dependencies) to JSON, either for entire workspaces or for single applications. For aggregated workspaces, call HTTP GET http://localhost:8033/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)/vulndeps . For single applications, call HTTP GET http://localhost:8033/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)%20<group>:<artifact>:<version>/vulndeps The API returns an array of JSON elements having the following data model: Property Description Possible Values projectId Identifies the affected application and dependency ( <app-GAV> > <dep-filename> ) type Identifier of vulnerability in vulnerability-assessment-tool knowledge base scope Scope of the dependency see official Maven documentation priority Priority of the finding 3 in case of dependencies with scope TEST and PROVIDED, 1 otherwise exemptionReason Assessment description (if any), see report goal for more information on how-to assess and exempt findings state Assessment result (if any) 1 (secure-by-design) in case of dependencies with scope TEST and PROVIDED, 4 (mitigated) in case the bug has been exempted, 2 (true-positive) otherwise status Indicates whether the finding has been assessed 1 (audited) in case state is 1 or 4, -1 (non-audited) otherwise count Number of findings of type type in project Always 1 snapshotDate Date of most recent goal execution of the application (any goal) Setup \u00b6 Maven \u00b6 The plugin for Maven can be used with or without adding a <profile> section to the pom.xml . With profile , the execution of goals is more concise (readable), e.g., mvn -Dvulas compile vulas:app . A sample profile can be found here , just copy&paste it into the <profiles> section of your pom.xml . In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file. Once added, run mvn -Dvulas versions:display-property-updates every now and then to check whether there are new plugin versions available. If so, manually update the property vulas.version in the vulnerability-assessment-tool profile. Without profile , the execution of goals requires the use of the plugin's fully qualified name, e.g., mvn compile com.sap.research.security.vulas:plugin-maven:3.1.6:app . Moreover, you need to specify the following mandatory configuration settings. As described here , there are several ways of doing so, however, a file as follows is very common: vulas-custom.properties vulas.core.space.token = <YOUR WORKSPACE TOKEN> vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ It is possible to include/exclude modules of a multi-module Maven project using the following configuration parameters: # Options to include and exclude Maven artifacts (modules) during the processing of an aggregator project. # If includes is provided, the other parameters are ignored. In other words, excludes and ignorePoms will # only be evaluated if includes is empty. # # Important: Those options are ignored in case of the report goal, thus, report will be run on all modules. # In particular, running report on a module with packaging POM will create an aggregated report for all its # submodules. # # One has to provide the artifactId (not the module name), and multiple values for includes and excludes must # be separated by comma. # # Defaults: # includes = - # excludes = - # ignorePoms = false vulas.maven.includes = vulas.maven.excludes = vulas.maven.ignorePoms = false Gradle \u00b6 The plugin for Gradle requires changes of the following files: build.gradle buildscript { repositories { maven { url '<PACKAGE-REPO>' } mavenCentral() } dependencies { classpath('com.sap.research.security.vulas:plugin-gradle:3.1.6') { changing = true } } } allprojects { apply plugin: \"vulas\" } gradle.properties // Used to identify the scan in the apps Web frontend group = ### group - EDIT THIS ### version = ### version - EDIT THIS ### // Replace token of test space vulas.core.space.token = ### workspace token - EDIT THIS ### vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the analysis goals vulasApp , vulasA2C etc. are listed among \"Other tasks\" when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here . Command-line interface \u00b6 Create a new folder, download the latest ZIP archive vulas-cli-3.1.6.zip from Releases and extract it into the newly created folder. This folder will then contain the following items: Folder/File Description ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. Important : (1) Single java and class files are always considered as application code, no matter the package prefix configured with vulas.core.app.appPrefixes . (2) JARs are always considered as application dependency unless they only contain methods starting with the configured package prefix. (3) Nested JARs must be extracted, WARs can stay as-is. ./vulas-cli-<version>-jar-with-dependencies.jar An executable JAR used to run the different vulnerability-assessment-tool goals. ./instr/lang-java-<version>-jar-with-dependencies.jar Used to instrument Java runtimes. ./vulas-custom.properties.sample Configuration settings for vulnerability-assessment-tool. Important : (1) Rename the file to vulas-custom.properties . (2) Specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. (3) Specify how vulnerability-assessment-tool identifies your application code (either using vulas.core.app.appPrefixes or vulas.core.app.appJarNames , see below for more information). (4) Specify the workspace token vulas.core.space.token . Identification of application code : You can use vulas.core.app.appPrefixes or vulas.core.app.appJarNames to tell vulnerability-assessment-tool how to identify the code of your application, which is important for the call graph construction during the a2c reachability analysis. This analysis is not complete if not all the relevant application methods are used as entry points for the call graph construction. As such, the potential execution of vulnerable open-source methods may be missed. A good indicator to see whether specification is correct is to see whether there are items in the Dependencies tab that are created by you (or your organization), or whether there are open-source packages mentioned in the table on the Statistics tab. # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames = Configuration \u00b6 Layered configuration principle \u00b6 The client-side analysis tools can be configured in different ways. At runtime, the following layers are combined in order to establish the effective configuration (which is printed to console upon goal execution). Java system properties : Can be specified when running java or mvn , each setting must be prefixed with -D Property files in file system : Can be specified by adding property file(s) in the folder where vulnerability-assessment-tool is executed (or any of its subfolders). The file name must adhere to the format vulas-*.properties , and its entries must be specified according to the Java spec Plugin configuration : Maven: Can be specified in the <layeredConfiguration> section of the Maven plugin Gradle: todo Environment variables : Can be specified using export (nix) and set (Windows) Property files in JAR files : Default values for many settings are set within vulnerability-assessment-tool JAR files General settings \u00b6 The following settings, however, have to be present for every goal execution: vulas.core.space.token : The token of the workspace to be used for the analysis vulas.core.appContext.group , vulas.core.appContext.artifact and vulas.core.appContext.version : Altogether, they uniquely identify an application within a space. Depending on the client used, one or more of them are automatically inferred, e.g., using data from pom.xml or build.gradle . vulas.shared.backend.serviceUrl : The URL of the backend service to which clients upload analysis results. Check setup \u00b6 Proceed as follows to check whether the vulnerability-assessment-tool setup and goal execution works: On the client , after executing a specific vulnerability-assessment-tool goal on your application, a log entry similar to the one below should be printed to the console. It is used to upload goal-related information to the vulnerability-assessment-tool backend, e.g., the vulnerability-assessment-tool version used or the average memory consumption. In this example, information related to a goal execution for an application with GAV com.acme.foo:vulas-testapp-webapp:3.0.9-MVN was uploaded to http://localhost:8033/backend/ , workspace 123456789 . The successful upload is indicated by the HTTP response code 201 . [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST [uri=http://localhost:8033/backend/apps/com.acme.foo/vulas-testapp-webapp/3.0.9-MVN/goals, size=23,50 KB, tenant=123456789, space=123456789] [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST completed with response code [201] in [03.019 ms] (proxy=false) In the apps Web frontend at http://localhost:8033/apps , there are several tabs to be checked: On the Dependencies tab, one should see all application dependencies. In particular, there should be no archives belonging to the application under analysis (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the Statistics tab, one should see all packages belonging to the application. In particular, there should be no packages belonging to 3 rd party / open-source libraries (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the History tab, one should see table entries for all goal executions that happened on the client.","title":"Configuration"},{"location":"user/manuals/setup/#setup-and-configuration-manual","text":"","title":"Setup and Configuration Manual"},{"location":"user/manuals/setup/#workspace","text":"A workspace acts as a container to group the results of several application analyses. In that context, please note that each module of a multi-module Maven project appears as a separate application in the vulnerability-assessment-tool Web frontend. Before using workspaces, you need to create one using the vulnerability-assessment-tool Web frontend (see below); you will obtain a token that you will need to pass as a configuration parameter when performing scans.","title":"Workspace"},{"location":"user/manuals/setup/#create-workspaces-once","text":"You need to create a workspace once using the vulnerability-assessment-tool Web frontend. Use the \"create workspace\" icon in the lower-left corner toolbar of the apps Web frontend to do so. A workspace has the following properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL). Export results : AGGREGATED : Findings are aggregated on workspace-level, one item for the entire workspace will be exported DETAILED : Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF : No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s).","title":"Create workspace(s) (once)"},{"location":"user/manuals/setup/#use-the-generated-token-during-application-analysis","text":"The workspace token generated at previous step has to be used as value for the configuration setting vulas.core.space.token . This information is mandatory during the scans as it allows the user's data to be uploaded to the correct place/workspace in the vulnerability-assessment-tool backend. See here for more information regarding the configuration of vulnerability-assessment-tool clients.","title":"Use the generated token (during application analysis)"},{"location":"user/manuals/setup/#choose-a-workspace-in-the-apps-web-frontend","text":"Use the configuration icon in the lower-left corner in order to select a workspace. You can search for public workspaces by typing their name in the \"Space\" field. You can copy&paste the token of a private workspace into the input field in order to select it. Additional fields \"Backend URL\" and \"Artifact Analyzer URL\" can be used to connect the frontend to another backend (than the default running on the same host). Generally, this must not be changed by the users. Once you have selected a workspace, press \"Save\" button. The list of applications of that workspace will be automatically loaded on the left list menu of the frontend.","title":"Choose a workspace (in the apps Web frontend)"},{"location":"user/manuals/setup/#edit-a-workspace-in-the-apps-web-frontend","text":"In order to edit a workspace, press the same button as to choose a workspace and perform the following steps: Enter the name/token id of the workspace to edit in the \"Space\" field and eventually select one of the entries provided in the drop down list. press the \"Edit Space\" button at the bottom. Once this button is clicked, all the editable property-fields of the workspace are displayed. update/change the data of your workspace as per your expectations. Press the \"Save\" button to save your modifications, press the \"close\" button to revert your changes.","title":"Edit a workspace (in the apps Web frontend)"},{"location":"user/manuals/setup/#export-analysis-results","text":"The following REST API can be used to export findings (information about vulnerable dependencies) to JSON, either for entire workspaces or for single applications. For aggregated workspaces, call HTTP GET http://localhost:8033/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)/vulndeps . For single applications, call HTTP GET http://localhost:8033/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)%20<group>:<artifact>:<version>/vulndeps The API returns an array of JSON elements having the following data model: Property Description Possible Values projectId Identifies the affected application and dependency ( <app-GAV> > <dep-filename> ) type Identifier of vulnerability in vulnerability-assessment-tool knowledge base scope Scope of the dependency see official Maven documentation priority Priority of the finding 3 in case of dependencies with scope TEST and PROVIDED, 1 otherwise exemptionReason Assessment description (if any), see report goal for more information on how-to assess and exempt findings state Assessment result (if any) 1 (secure-by-design) in case of dependencies with scope TEST and PROVIDED, 4 (mitigated) in case the bug has been exempted, 2 (true-positive) otherwise status Indicates whether the finding has been assessed 1 (audited) in case state is 1 or 4, -1 (non-audited) otherwise count Number of findings of type type in project Always 1 snapshotDate Date of most recent goal execution of the application (any goal)","title":"Export Analysis Results"},{"location":"user/manuals/setup/#setup","text":"","title":"Setup"},{"location":"user/manuals/setup/#maven","text":"The plugin for Maven can be used with or without adding a <profile> section to the pom.xml . With profile , the execution of goals is more concise (readable), e.g., mvn -Dvulas compile vulas:app . A sample profile can be found here , just copy&paste it into the <profiles> section of your pom.xml . In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file. Once added, run mvn -Dvulas versions:display-property-updates every now and then to check whether there are new plugin versions available. If so, manually update the property vulas.version in the vulnerability-assessment-tool profile. Without profile , the execution of goals requires the use of the plugin's fully qualified name, e.g., mvn compile com.sap.research.security.vulas:plugin-maven:3.1.6:app . Moreover, you need to specify the following mandatory configuration settings. As described here , there are several ways of doing so, however, a file as follows is very common: vulas-custom.properties vulas.core.space.token = <YOUR WORKSPACE TOKEN> vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ It is possible to include/exclude modules of a multi-module Maven project using the following configuration parameters: # Options to include and exclude Maven artifacts (modules) during the processing of an aggregator project. # If includes is provided, the other parameters are ignored. In other words, excludes and ignorePoms will # only be evaluated if includes is empty. # # Important: Those options are ignored in case of the report goal, thus, report will be run on all modules. # In particular, running report on a module with packaging POM will create an aggregated report for all its # submodules. # # One has to provide the artifactId (not the module name), and multiple values for includes and excludes must # be separated by comma. # # Defaults: # includes = - # excludes = - # ignorePoms = false vulas.maven.includes = vulas.maven.excludes = vulas.maven.ignorePoms = false","title":"Maven"},{"location":"user/manuals/setup/#gradle","text":"The plugin for Gradle requires changes of the following files: build.gradle buildscript { repositories { maven { url '<PACKAGE-REPO>' } mavenCentral() } dependencies { classpath('com.sap.research.security.vulas:plugin-gradle:3.1.6') { changing = true } } } allprojects { apply plugin: \"vulas\" } gradle.properties // Used to identify the scan in the apps Web frontend group = ### group - EDIT THIS ### version = ### version - EDIT THIS ### // Replace token of test space vulas.core.space.token = ### workspace token - EDIT THIS ### vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the analysis goals vulasApp , vulasA2C etc. are listed among \"Other tasks\" when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here .","title":"Gradle"},{"location":"user/manuals/setup/#command-line-interface","text":"Create a new folder, download the latest ZIP archive vulas-cli-3.1.6.zip from Releases and extract it into the newly created folder. This folder will then contain the following items: Folder/File Description ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. Important : (1) Single java and class files are always considered as application code, no matter the package prefix configured with vulas.core.app.appPrefixes . (2) JARs are always considered as application dependency unless they only contain methods starting with the configured package prefix. (3) Nested JARs must be extracted, WARs can stay as-is. ./vulas-cli-<version>-jar-with-dependencies.jar An executable JAR used to run the different vulnerability-assessment-tool goals. ./instr/lang-java-<version>-jar-with-dependencies.jar Used to instrument Java runtimes. ./vulas-custom.properties.sample Configuration settings for vulnerability-assessment-tool. Important : (1) Rename the file to vulas-custom.properties . (2) Specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. (3) Specify how vulnerability-assessment-tool identifies your application code (either using vulas.core.app.appPrefixes or vulas.core.app.appJarNames , see below for more information). (4) Specify the workspace token vulas.core.space.token . Identification of application code : You can use vulas.core.app.appPrefixes or vulas.core.app.appJarNames to tell vulnerability-assessment-tool how to identify the code of your application, which is important for the call graph construction during the a2c reachability analysis. This analysis is not complete if not all the relevant application methods are used as entry points for the call graph construction. As such, the potential execution of vulnerable open-source methods may be missed. A good indicator to see whether specification is correct is to see whether there are items in the Dependencies tab that are created by you (or your organization), or whether there are open-source packages mentioned in the table on the Statistics tab. # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames =","title":"Command-line interface"},{"location":"user/manuals/setup/#configuration","text":"","title":"Configuration"},{"location":"user/manuals/setup/#layered-configuration-principle","text":"The client-side analysis tools can be configured in different ways. At runtime, the following layers are combined in order to establish the effective configuration (which is printed to console upon goal execution). Java system properties : Can be specified when running java or mvn , each setting must be prefixed with -D Property files in file system : Can be specified by adding property file(s) in the folder where vulnerability-assessment-tool is executed (or any of its subfolders). The file name must adhere to the format vulas-*.properties , and its entries must be specified according to the Java spec Plugin configuration : Maven: Can be specified in the <layeredConfiguration> section of the Maven plugin Gradle: todo Environment variables : Can be specified using export (nix) and set (Windows) Property files in JAR files : Default values for many settings are set within vulnerability-assessment-tool JAR files","title":"Layered configuration principle"},{"location":"user/manuals/setup/#general-settings","text":"The following settings, however, have to be present for every goal execution: vulas.core.space.token : The token of the workspace to be used for the analysis vulas.core.appContext.group , vulas.core.appContext.artifact and vulas.core.appContext.version : Altogether, they uniquely identify an application within a space. Depending on the client used, one or more of them are automatically inferred, e.g., using data from pom.xml or build.gradle . vulas.shared.backend.serviceUrl : The URL of the backend service to which clients upload analysis results.","title":"General settings"},{"location":"user/manuals/setup/#check-setup","text":"Proceed as follows to check whether the vulnerability-assessment-tool setup and goal execution works: On the client , after executing a specific vulnerability-assessment-tool goal on your application, a log entry similar to the one below should be printed to the console. It is used to upload goal-related information to the vulnerability-assessment-tool backend, e.g., the vulnerability-assessment-tool version used or the average memory consumption. In this example, information related to a goal execution for an application with GAV com.acme.foo:vulas-testapp-webapp:3.0.9-MVN was uploaded to http://localhost:8033/backend/ , workspace 123456789 . The successful upload is indicated by the HTTP response code 201 . [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST [uri=http://localhost:8033/backend/apps/com.acme.foo/vulas-testapp-webapp/3.0.9-MVN/goals, size=23,50 KB, tenant=123456789, space=123456789] [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST completed with response code [201] in [03.019 ms] (proxy=false) In the apps Web frontend at http://localhost:8033/apps , there are several tabs to be checked: On the Dependencies tab, one should see all application dependencies. In particular, there should be no archives belonging to the application under analysis (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the Statistics tab, one should see all packages belonging to the application. In particular, there should be no packages belonging to 3 rd party / open-source libraries (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the History tab, one should see table entries for all goal executions that happened on the client.","title":"Check setup"},{"location":"user/support/","text":"Getting help \u00b6 User support \u00b6 If you would like to try vulnerability-assessment-tool and you do not know where to start, our Tutorials provides a gentle, step-by-step walkthrough of your first scan. Also, an extensive documentation of the features, options and configuration settings of the tool can be found in User Guide . If you run into troubles, have a look at the list of Frequently Asked Questions . Bug reports \u00b6 If you encounter a bug while using vulnerability-assessment-tool, you are welcome to open an issue on GitHub giving a detailed description of what happened so that we can diagnose and resolve the problem (please, do search among the currently open issues to check if someone else has already reported the same problem). Receive news \u00b6 You can subscribe to our newsletter in case you want to receive updates by email: Simply write to vulas-news-request@listserv.sap.com with \"subscribe\" in the body.","title":"Getting help"},{"location":"user/support/#getting-help","text":"","title":"Getting help"},{"location":"user/support/#user-support","text":"If you would like to try vulnerability-assessment-tool and you do not know where to start, our Tutorials provides a gentle, step-by-step walkthrough of your first scan. Also, an extensive documentation of the features, options and configuration settings of the tool can be found in User Guide . If you run into troubles, have a look at the list of Frequently Asked Questions .","title":"User support"},{"location":"user/support/#bug-reports","text":"If you encounter a bug while using vulnerability-assessment-tool, you are welcome to open an issue on GitHub giving a detailed description of what happened so that we can diagnose and resolve the problem (please, do search among the currently open issues to check if someone else has already reported the same problem).","title":"Bug reports"},{"location":"user/support/#receive-news","text":"You can subscribe to our newsletter in case you want to receive updates by email: Simply write to vulas-news-request@listserv.sap.com with \"subscribe\" in the body.","title":"Receive news"},{"location":"user/support/faq/","text":"Warning This page provides answers and solutions to frequent questions and problems of vulnerability-assessment-tool end-users. Please review this material carefully before asking support, filing bug reports, or requesting new features. Only if you cannot find an answer to your questions in this page, please see the help to learn how to get support. LIST OF QUESTIONS General questions Why can't I compile my Maven project anymore after I activate the vulnerability-assessment-tool profile? Why does vulnerability-assessment-tool backend refuse HTTP connections established by vulnerability-assessment-tool Maven plugin? Why do all HTTP connections fail from the vulnerability-assessment-tool Maven plugin? Why does my workspace stay empty? What is the cause of the following ERROR: vulas-maven-plugin:3.x.x or one of its dependencies could not be resolved? Why do I get the following message: WARN: App does not exist in backend, goal upload skipped? Why does vulnerability-assessment-tool show vulnerabilities that are seemingly related to other components Understanding the results produced by vulnerability-assessment-tool vulnerability-assessment-tool reported vulnerabilities for which I found no data in NVD. What should I do about them? Why is vulnerability-assessment-tool is not detecting all vulnerabilities of my project? Method-level bill of material (goal app) app : NotFoundException when analyzing JAR files? app : The goal execution takes very long app : The goal execution breaks with a 5xx response code received from the backend app : The goal execution breaks with a java.nio.file.InvalidPathException Reachability Analysis (goals a2c and t2c) a2c : java.lang.OutOfMemoryError a2c : Timeout during reachability analysis a2c : java.io.FileNotFoundException? a2c : Invalid byte code in method? Instrumentation and trace collection (goals test and instr) TEST : java.lang.NoSuchMethodError? TEST : Not all vulnerability-assessment-tool analysis results are uploaded to the backend TEST : How to run -Dvulas test in projects using Mockito? TEST : Byte code instrumentation fails TEST : The forked VM terminated TEST : Incomplete app context TEST : \"Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger\" JUnit tests using Powermock fail when using vulnerability-assessment-tool Python app goal is slow virtualenv problems Other topics report: The HTML result report is not properly rendered inside Jenkins No log messages of the vulnerability-assessment-tool Maven plugin appear on the console. Why? OutOfMemoryError: GC overhead limit exceeded? I get an error saying VerifyError: Inconsistent stackmap frames at branch target. What should I do? General questions \u00b6 Why can't I compile my Maven project anymore after I activate the vulnerability-assessment-tool profile? \u00b6 You may want to check whether there are other <profile> sections that declare dependencies. If so, one of those is probably activated by default. In this case, when using the vulnerability-assessment-tool profile, those other profiles will not be active, hence, there are dependencies missing, which can lead to compile exceptions. To fix, you should activate multiple profiles at once using the -P option, see here for more information. Why does vulnerability-assessment-tool backend refuse HTTP connections established by vulnerability-assessment-tool Maven plugin? \u00b6 The vulnerability-assessment-tool plugins gathers very detailed information about all Java archives required by an application. For example, it collects the method signatures of all methods contained in every JAR. For every archive, identified by its SHA1, this information must be uploaded to and stored by the vulnerability-assessment-tool backend in case it is not yet known. This requirement will cause a lot of uploads when an application is first analyzed, because a lot of dependencies may not be known. Problem: As a result of the above, it can happen that several HTTP POST connection requests are refused by the vulnerability-assessment-tool backend during the vulnerability-assessment-tool Maven plugin execution, which will result in error messages as follows. Copy&paste from console Solution vulnerability-assessment-tool plugin users can simply re-run the vulnerability-assessment-tool goal \"app\" multiple times up until the information for all archives has been uploaded. With each run, more and more archives will be successfully uploaded, up until a point where every archive is known. According to our experience, this is the case after a few runs only ( <5 ). Why do all HTTP connections fail from the vulnerability-assessment-tool Maven plugin? \u00b6 Problem Not a single HTTP connection can be established, which becomes obvious if even the first connection request hangs for several minutes and eventually fails as follows: [INFO] ------------------------------------------------------------------------ [INFO] Building com.at.example.spring-01 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ com.at.example.spring-01 --- [INFO] Deleting C:\\My Documents\\com.at.example.spring-01\\target [INFO] [INFO] --- maven-dependency-plugin:2.10:copy (copy-vulas) @ com.at.example.spring-01 --- [INFO] Configured Artifact: com.sap.research.security.vulas:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Configured Artifact: com.sap.research.security.vulas:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\lib\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\include\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] [INFO] --- vulas-maven-plugin:1.1.0-SNAPSHOT:clean (vulas-clean) @ com.at.example.spring-01 --- [main] INFO com.sap.psr.vulas.GoalExecution - vulnerability-assessment-tool goal execution started [id=CLEAN-1448374577441-14554386, goal=CLEAN, app=(com.at.example:com.at.example.spring-01:jar:0.0.1-SNAPSHOT)] [main] INFO com.sap.psr.vulas.backend.Collector - HTTP request started [url=, user=] [vulas-memo] INFO com.sap.psr.vulas.GoalExecution - Memory consumption (used/avg): [57.75 MB/57.75 MB], JVM (free/total/max): [183.75 MB/241.50 MB/3559.50 MB] [main] ERROR com.sap.psr.vulas.backend.Collector - HTTP request error while calling [], HTTP response written to [C:\\Users\\iXXXXXX\\AppData\\Local\\Temp\\vulas-tmp-8966348801119324800.html] Solution Run the vulnerability-assessment-tool Maven plugin with a different proxy than the default proxy specified in the configuration ( none ). You need to change 2 settings: On the command line, run Maven as follows, whereby <proxy> can be custom_proxy or simply proxy mvn -Dhttp.proxyHost = <proxy> -Dvulas vulas:app In the Maven Surefire plugin, include the -Dhttp.proxyHost system property for the JVM spawned for JUnit tests: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.14 </version> <configuration> <argLine> ... -Dhttp.proxyHost=custom_proxy ... </argLine> </configuration> </plugin> Why does my workspace stay empty? \u00b6 When executing a vulas goal, your workspace is not filled with the results of the scan. Instead of this your results are usually uploaded to the PUBLIC workspace of the vulnerability-assessment-tool Frontend. You first need to insure that you are using at least version 3.0 of vulnerability-assessment-tool. The workspace feature was introduced with vulnerability-assessment-tool 3. By default, if you are running vulnerability-assessment-tool 2.x (and you should not!) all the data are stored in the \"PUBLIC\" workspace in the vulnerability-assessment-tool Frontend. Please notice that the vulnerability-assessment-tool plugin name was changed with vulnerability-assessment-tool 3: it was changed from vulas-maven-plugin to plugin-maven (click here for more details). It is quite usual that developers working with Jenkins/Piper are pointing to an old version of vulnerability-assessment-tool (2.x) because their Jenkins/Piper platform itself points to the old vulnerability-assessment-tool plugin name. A simple update there usually solves the issue. You need to insure that you have correctly indicated to vulnerability-assessment-tool where to upload the results of your scans (e.g. in your workspace). Please click here and here for details about workspaces and how to use them. What is the cause of the following ERROR: vulas-maven-plugin:3.x.x or one of its dependencies could not be resolved ? \u00b6 You are running the execution of a maven goal and are facing an error similar to the following one: [ERROR] Plugin com.sap.research.security.vulas:vulas-maven-plugin:3.0.8 or one of its dependencies could not be resolved: Could not find artifact com.sap.research.security.vulas:vulas-maven-plugin:jar:3.0.8 in mirror1 (url) -> [Help 1] You most probably updated your settings to use Maven 3.x instead of Maven 2.x. The vulnerability-assessment-tool plugin was renamed with vulnerability-assessment-tool 3.x: it was changed from vulas-maven-plugin to plugin-maven . You may need to update your settings accordingly (click here for more details on how to update your settings). Why do I get the following message: WARN: App does not exist in backend, goal upload skipped ? \u00b6 Symptom : The console contains a log message as follows: WARN com.sap.psr.vulas.backend.BackendConnector - App [group=com.acme, artifact=parent, version=1-SNAPSHOT, packaging=pom] does not exist in backend, goal upload skipped Explanation : Information related to the execution of a goal, e.g., execution time or memory consumption, cannot be uploaded as the respective application does not exist in the backend. This is not necessarily a problem, hence, the message is issued as warning. Examples where an application does not exist in the backend are as follows: If an application does neither have any dependencies nor source code, e.g., in folder src/main/java , it will not be uploaded to the backend (depending on configuration parameter vulas.core.app.uploadEmpty , which defaults to false ). In this case, the execution of goal execution information cannot be uploaded. Typical examples of empty applications are Maven aggregator projects ( <packaging>pom</packaging> ). If an application version is analyzed for the first time, the initial execution of the clean goal will also result in this warning message. Why does vulnerability-assessment-tool show vulnerabilities that are seemingly related to other components \u00b6 Symptom : In the Web frontend or in the report, vulnerability-assessment-tool displays findings which seem to be related to others components. Example : In the following screenshot, several CVEs related to jackson-databind are shown for spring-cloud-cloudfoundry-connector . Explanation : vulnerability-assessment-tool detects the presence of vulnerable code, no matter the file name or GAV of a dependency. Sometimes, an archive re-bundles code of other open source projects. Sometimes, re-bundled code is even re-packaged, thus, the Java package namespace is altered. Both of those cases are still detected by vulnerability-assessment-tool. In the previous example, the file spring-cloud-cloudfoundry-connector-2.0.5.RELEASE.jar contains (re-bundles) vulnerable code of jackson-databind . Understanding the results produced by vulnerability-assessment-tool \u00b6 vulnerability-assessment-tool reported vulnerabilities for which I found no data in NVD. What should I do about them? \u00b6 For vulnerabilities that do not come from the NVD we do provide reference links. They are listed in the vulnerability details page accessible clicking on the different rows of the vulnerability main table (see example below). Why is vulnerability-assessment-tool is not detecting all vulnerabilities of my project? \u00b6 If the vulnerability is included in our knowledge base but it is not detected for your application, you can select the checkbox \u201cInclude historical vulnerabilities\u201d in the vulnerability-assessment-tool frontend and hit \u201cReload\u201d button: you will see all CVEs that applied to previous versions of your dependencies. The indicates that a given CVE did apply to earlier versions, but you are currently using a non-vulnerable one. Despite our best efforts to keep the vulnerability-assessment-tool vulnerability knowledge base continuously updated, it is possible that a particular vulnerability is not yet covered. Query /backend/bugs to check if a vulnerability is covered or not. Method-level bill of material (goal app) \u00b6 app : NotFoundException when analyzing JAR files? \u00b6 Problem: When analyzing JAR files, error messages similar to the following are printed: ERROR com.sap.psr.vulas.JarAnalyzer - JarAnalyzer[jar/war=org.apache.servicemix.bundles.jaxb-xjc-2.2.4_1.jar, mavenId=(org.apache.servicemix.bundles:org.apache.servicemix.bundles.jaxb-xjc:2.2.4_1), instr=false, instrCtx=(com.acme:foo:pom:1.0-SNAPSHOT)]: NotFoundException while analyzing class [1.0.com.sun.xml.xsom.parser.JAXPParser]: 1.0.com.sun.xml.xsom.parser.JAXPParser Explanation: This can be due to the use of Java identifiers that do not confirm with the Java language specification . In this example, the actual package name of \"1.0.com.sun.xml.xsom.parser.JAXPParser\", as seen in the JAR file, is \"1.0\". vulnerability-assessment-tool, however, uses dots for separating package identifiers. Note: As of Java 9, multi-release archives can contain class files in subdirectories. They are not yet supported by vulnerability-assessment-tool. Solution: Not yet known. For the time being, clarify who produced the respective JAR file. app : The goal execution takes very long \u00b6 Problem: The execution of the APP goal takes very long. Explanation: Whenever a JAR, identified by its SHA1, is unknown to the backend, all its method signatures are gathered and uploaded. As a result, the first execution(s) of vulas:app can take some time, as any yet unknown JAR need to be covered. Future executions will be significantly faster. app : The goal execution breaks with a 5xx response code received from the backend \u00b6 Problem: The goal execution breaks with a 5xx response code received from the backend. Explanation: This can happen if multiple processes (on the same computer or remotely) try to upload the same method signature to the backend. In such cases, one can simply restart at a later time to avoid the clash. app : The goal execution breaks with a java.nio.file.InvalidPathException \u00b6 Problem: The goal execution breaks with a java.nio.file.InvalidPathException: Malformed input or input contains unmappable characters as viewable here below. [ERROR] Failed to execute goal com.sap.research.security.vulas:plugin-maven:3.1.6:app (default-cli) on project xxxxx: java.nio.file.InvalidPathException: Malformed input or input contains unmappable characters: shapeless/$tilde$qmark$greater$?.class Explanation : the exception is often due to an encoding problem. Solution : Try one of the following options. 1/ Add the property <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> to your pom.xml file. Current property <encoding> only works if added to the configuration section of individual plugins. OR 2/ Force the usage of the UTF-8 encoding using the \"-Dsun.jnu.encoding=UTF-8 -Dfile.encoding=UTF-8\" properties in your command line. Reachability Analysis (goals a2c and t2c) \u00b6 a2c : java.lang.OutOfMemoryError \u00b6 Solutions: Increase the maximum and minimum JVM heap space with -Xmx and -Xms . Prior to Java8, also add -XX:MaxPermSize=2g -XX:+CMSClassUnloadingEnabled . a2c : Timeout during reachability analysis \u00b6 Problem: The execution of the reachability analysis causes a timeout, e.g., [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] reached timeout and will be interrupted [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.<init>(BitVectorIntSet.java:45) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.addAllOblivious(BitVectorIntSet.java:126) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.makeDenseCopy(MutableSharedBitVectorIntSet.java:984) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAll(MutableSharedBitVectorIntSet.java:752) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersectionInternal(MutableSharedBitVectorIntSet.java:1067) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersection(MutableSharedBitVectorIntSet.java:1032) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:175) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:158) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.FilteredPointerKey$SingleClassFilter.addFiltered(FilteredPointerKey.java:65) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:623) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:1) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.UnaryStatement.evaluate(UnaryStatement.java:36) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixedpoint.impl.AbstractFixedPointSolver.solve(AbstractFixedPointSolver.java:150) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.StandardSolver.solve(StandardSolver.java:40) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder.makeCallGraph(PropagationCallGraphBuilder.java:269) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.wala.WalaCallgraphConstructor.buildCallgraph(WalaCallgraphConstructor.java:308) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.ReachabilityAnalyzer.run(ReachabilityAnalyzer.java:265) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - java.lang.Thread.run(Thread.java:745) [main] ERROR com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] terminated w/o success after [ 15,0 min] Solution(s): Increase the timeout by changing the configuration setting vulas.reach.timeout , e.g., mvn -Dvulas.reach.timeout=600 -Dvulas compile vulas:a2c Decrease the precision of the call graph construction, e.g., by changing the system property vulas.reach.wala.callgraph.reflection . For instance, run the reachability analysis as follows: mvn -Dvulas vulas:a2c -Dcallgraph.reflection=NONE . See manual/analysis#a2c for more configuration options. a2c : java.io.FileNotFoundException? \u00b6 Problem: During a2c , a given JAR cannot be found by Wala, which produces an error message as following: Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError: java.io.FileNotFoundException: .\\InfoView\\dep\\BOE\\WEB-INF\\eclipse\\plugins\\axis2\\lib\\jaxb-api.jar (The system cannot find the file specified) Solution(s): Set the configuration parameter vulas.reach.preprocessDependencies to true Explanation: The problem occurs if the MANIFEST file of a JAR refers to other dependencies using the Class-Path entry. Wala, for instance, will try to resolve those dependencies. The pre-processing will remove the corresponding manifest file entries. a2c : Invalid byte code in method? \u00b6 Problem: During a2c or t2c , the call graph construction by Wala fails with an error message as follows: error: invalid byte code in method org.springframework.asm.ClassReader.readConst(I[C)Ljava/lang/Object; Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError at com.ibm.wala.util.debug.Assertions.UNREACHABLE(Assertions.java:46) at com.ibm.wala.classLoader.ShrikeCTMethod.makeDecoder(ShrikeCTMethod.java:107) Solution: Append the respective package to the configuration setting vulas.reach.wala.callgraph.exclusions , which lists all the Java packages to be ignored by Wala. Note that dots (.) separating package names are replaced by slash (/). Example: In case of the above error message, one has to add the string org/springframework/asm/.* in order to ignore all classes of package asm . The new value of the configuration setting looks as follows: vulas.reach.wala.callgraph.exclusions = java/awt/.*;javax/swing/.*;sun/awt/.*;sun/swing/.*;org/netbeans/.*;com/sun/.*;org/openide/.*;com/ibm/crypto/.*;com/ibm/security/.*;org/apache/xerces/.*;org/springframework/asm/.* Instrumentation and trace collection (goals test and instr) \u00b6 TEST : java.lang.NoSuchMethodError? \u00b6 Problem: The execution of the test phase throws a NoSuchMethodError exception. This can happen if an application makes use (directly or transitively) of an older release of a library that is also required by vulnerability-assessment-tool. In the below example, an application used commons-collections v3.0.0, while vulnerability-assessment-tool needs commons-collections v3.2.2 (whose classes are actually included in the vulas-with-dependencies.jar). ------------------------------------------------------- T E S T S ------------------------------------------------------- java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:386) at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:401) Caused by: java.lang.NoSuchMethodError: org.apache.commons.collections.CollectionUtils.isEmpty(Ljava/util/Collection;)Z at org.apache.commons.configuration.XMLConfiguration.constructHierarchy(XMLConfiguration.java:640) at org.apache.commons.configuration.XMLConfiguration.initProperties(XMLConfiguration.java:596) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:1009) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:972) at org.apache.commons.configuration.XMLConfiguration$XMLFileConfigurationDelegate.load(XMLConfiguration.java:1647) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:324) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:261) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:238) at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.load(AbstractHierarchicalFileConfiguration.java:184) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:608) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:587) at com.sap.psr.vulas.monitor.DynamicTransformer.<init>(DynamicTransformer.java:81) at com.sap.psr.vulas.monitor.DynamicTransformer.getInstance(DynamicTransformer.java:304) at com.sap.psr.vulas.monitor.DynamicTransformer.premain(DynamicTransformer.java:320) ... 6 more FATAL ERROR in native method: processing of -javaagent failed Exception in thread \"main\" Solution: Change the dependency of your application to a more recent release. In the above example, the following XML snippet was added to the application's POM (which transitively depended on it): <dependency> <groupId> commons-collections </groupId> <artifactId> commons-collections </artifactId> <version> 3.2.2 </version> </dependency> TEST : Not all vulnerability-assessment-tool analysis results are uploaded to the backend \u00b6 Problem: At the end of the JUnit test case execution ( mvn -Dvulas test ), not all the vulnerability-assessment-tool analysis results are uploaded to the the vulnerability-assessment-tool backend. The reason is that the Maven Surefire Plugin kills the JVM before vulnerability-assessment-tool' shutdown hook uploaded all the data. Solution: Disable the upload by changing the Surefire configuration in the POM file as follows. The analysis results will then be written in the folder target/vulas/upload . Afterwards, run the vulnerability-assessment-tool plugin goal \"upload\" in order to upload the JSON analysis results to the backend ( mvn -Dvulas vulas:upload ). <argLine> -Dvulas.upload=false TEST : How to run -Dvulas test in projects using Mockito? \u00b6 Problem : when running mvn -Dvulas test , tests fail with an error such as org.mockito.exceptions.misusing.MissingMethodInvocationException Solution : Run your tests as usual: mvn test Then run them again with vulnerability-assessment-tool enabled to perform reachability analysis: mvn -Dmaven.test.failure.ignore = true -Dvulas test vulas:upload Alternative solutions (when running mvn -Dvulas test ) : disable selectively the failing tests ignore selected jars TEST : Byte code instrumentation fails \u00b6 Problem No traces are collected during the execution of JUnit tests, no matter which instrumentor is used. Moreover, no corresponding error messages or exceptions are printed to the console. A possible indicator of that problem is the appearance of the log message \"Completed instantiation of trace collector\" after the log message \"Tests run: XXX, Failures: XXX, Errors: XXX, Skipped: XXX, Time elapsed: XXX sec\", which signals the termination of the actual JUnit tests. Example: [main] INFO com.sap.psr.vulas.monitor.InstrumentationControl - JAR [C:\\Users\\XXXXXX\\.m2\\repository\\org\\apache\\commons\\commons-lang3\\3.2\\commons-lang3-3.2.jar] is blacklisted: [false] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.141 sec - in code.MainTest [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET [uri=http://localhost:8033/backend/apps/XXXXXX/XXXXXX/XXXXXX/bugs?historical=false, proxy=false] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET completed with response code [200] in [0,0573 min] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.BackendConnector - [53] constructs for [7] bugs received from backend [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - Completed instantiation of trace collector [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No paths collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No traces collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.GoalExecution - vulnerability-assessment-tool goal execution finished [id=TEST-1487175325075-7552264, goal=TEST, app=(XXXXXX:XXXXXX:XXXXXX)] in [0,0877 min] Solution Similar to the above problem, it can happen that an application depends on a previous release of Javassist. As such, methods required by vulnerability-assessment-tool are not present at the time vulnerability-assessment-tool tries to change the byte code of loaded classes. As for the previous problem, you can add an explicit dependency to the application under test in order to let Maven resolve to a recent release of Javassist. TEST : The forked VM terminated \u00b6 Problem: Tests terminate with a log message as follows: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Solutions: Increase JVM heap space by adding -Xmx4096M -Xms2048M (or more if possible) to the <argLine> argument of the Maven Surefire plugin Select an instrumentor that consumes less memory by adding, for instance, -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor . TEST : Incomplete app context \u00b6 Problem Tests terminate with the error message App context incomplete: [group=, artifact=, version=] and there exists a white space in any of the parent directories of the Maven project (e.g., C:\\My Documents\\projects\\foo ). Solutions Move the Maven project to a location without whitespaces in the names of any of the parent directories. Open the pom.xml and replace the Maven variable ${project.build.directory} in the <argLine> configuration setting of the maven-surefire-plugi n by the relative path of the respective directory, typically target . Open the POM file and remove the -Dvulas.core.uploadDir and -Dvulas.shared.tmpDir system properties in the <argLine> configuration setting of the maven-surefire-plugin . Create two new system property variables in the configuration section of the maven-surefire-plugin as follows (see here for more information). <systemPropertyVariables> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> </systemPropertyVariables> TEST : \"Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger\" \u00b6 Problem When running the vulnerability-assessment-tool test goal, you face an error similar to Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger Solution This error seems to appear with certain versions of Maven. It should disappear with maven 3.5.2 or higher. Please insure which version of maven you are using. If you locally run maven on your machine, please upgrade your local maven version to maven 3.5.2 or higher and run your scan again. If you perform your scans in a CI/CD environment like Jenkins, please check which version of Maven is used there. Then validate that the issue is linked to the current maven version (see previous point). Once you validated that the current Maven version is responsible for the issue, proceed with the update/upgrade to Maven 3.5.2 or higher in your CI/CD environment. As an example in Jenkins environments you can use one of the following alternatives: Make an upgrade request to your Jenkins administrator. Install Maven \"globaly\": in this case you can continue using your former command ex: mvn clean compile vulas:clean vulas:app install vulas:upload -Pvulas -Dskip.integration.tests as it is and Jenkins will use the new version. Install maven as new \"Global Tool\": you can do this in \"Manage Jenkins\" -> \"Global Tool Configuration\". Here you find the entry \"Maven installations\". Add there the new Maven installation \"M360\" (if you like to install maven 3.6.0) with the installer \"Install from Apache\" Version 3.6.0. As a consequence, you will need to change the command in your job/task so that the new Maven version is used instead of the global one (which is still the version including the bug) and your command should like like /var/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation/M360/bin/mvn clean compile vulas:clean vulas:app install vulas:upload -Pvulas -Dskip.integration.tests JUnit tests using Powermock fail when using vulnerability-assessment-tool \u00b6 Problem JUnit tests making use of Powermock fail when activating the vulnerability-assessment-tool profile. Explanation In order to collect execution traces during test execution, the vulnerability-assessment-tool agent has to be registered at the JVM. This is done in the configuration section of the surefire plugin inside the vulnerability-assessment-tool profile. The parallel use of Powermock and the vulnerability-assessment-tool agent, which modifies all the bytecode of every class loaded by the JVM, fails in certain cases. Solution(s) This problem can be solved in several ways: Ignore all test failures by adding -Dmaven.test.failure.ignore=true (also see other options of the maven-surefire-plugin ) In case of multi-module projects, continue the build of later modules using the options --fail-never or --fail-at-end (see here for more information) Exclude problematic classes from being instrumented by adding their prefixes via -Dvulas.core.instr.blacklist.classes.custom=foo.bar,bar.baz.Class,... Exclude single problematic tests by modifying the <excludes> section of the surefire configuration in the vulnerability-assessment-tool profile: <excludes> <exclude> **/doesnotexist.java </exclude> </excludes> Python \u00b6 app goal is slow \u00b6 Dependencies are analyzed by setting up a virtual environment for the respective application. The setup of such a virtualenv can take some time (no matter whether it is done in the context of vulnerability-assessment-tool or not). Moreover, whenever a Python library is found that is not yet known to the backend, its bill of material needs to be uploaded. The delay caused by this initial upload will not occur for subsequent scans. virtualenv problems \u00b6 Run virtualenv from the command line to see whether it is properly installed and working. Other topics \u00b6 report: The HTML result report is not properly rendered inside Jenkins \u00b6 Symptom : The HTML report is not properly rendered inside Jenkins (e.g., no images, no color-coding, no JavaScript, see the example screenshot below). Solution : Either (a) download a ZIP of the vulnerability-assessment-tool report (the link can be found in the upper-right corner), or (b) adjust the content security policy (CSP) of Jenkins as described here . In the latter case, you should execute the following command in the Jenkins script console (on a single line ): System . setProperty ( \"hudson.model.DirectoryBrowserSupport.CSP\" , \"sandbox allow-scripts; default-src 'none'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'unsafe-inline'\" ) No log messages of the vulnerability-assessment-tool Maven plugin appear on the console. Why? \u00b6 Symptom vulnerability-assessment-tool log messages are not printed to the console (e.g., during the execution of the Maven lifecycle phase \"test\"). Instead, the following error message is printed. ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. Explanation The vulnerability-assessment-tool Maven plugin makes use of log4j version 1, a corresponding configuration file is included in its JAR file. If, however, the project under analysis makes use of log4j version 2, but does not have a log4j2.xml file in folder src/main/resources , no log message of vulnerability-assessment-tool but the above error message is printed. Still, the traces are actually collected and uploaded to the central engine. Solution Create a file src/main/resources/log4j2.xml with the following sample content (copied from here ) and adapt as needed. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <Configuration> <Appenders> <Console name= \"STDOUT\" target= \"SYSTEM_OUT\" > <PatternLayout pattern= \"%d %-5p [%t] %C{2} (%F:%L) - %m%n\" /> </Console> </Appenders> <Loggers> <Logger name= \"org.apache.log4j.xml\" level= \"info\" /> <Root level= \"info\" > <AppenderRef ref= \"STDOUT\" /> </Root> </Loggers> </Configuration> OutOfMemoryError: GC overhead limit exceeded? \u00b6 Use the command line options -Xms and -Xmx to adjust the heap memory available to the JVM. Chose a value for -Xmx that is close to your machine's physical memory. In case of Maven, use the statement export MAVEN_OPTS=\"-Xms4g -Xmx8g\" . For versions before Java 8, you should also add the options -XX:MaxPermSize=2024M -XX:+CMSClassUnloadingEnabled . Notes: See here for problems related to the heap space allocations on 32bit Java versions See here for background information on Java memory management I get an error saying VerifyError: Inconsistent stackmap frames at branch target . What should I do? \u00b6 If the execution of the Maven Surefire Plugin during the Maven lifecycle phase test fails with a java.lang.VerifyError similar to the following: [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test (default-test) on project foo-bar: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test failed: There was an error in the forked process [ERROR] java.lang.VerifyError: Inconsistent stackmap frames at branch target 54 [ERROR] Exception Details: [ERROR] Location: [ERROR] com/acme/FooTest.<init>()V @54: aconst_null [ERROR] Reason: [ERROR] Type uninitializedThis (current frame, locals[0]) is not assignable to 'com/acme/FooTest' (stack map, locals[0]) [ERROR] Current Frame: [ERROR] bci: @16 [ERROR] flags: { flagThisUninit } [ERROR] locals: { uninitializedThis, null, 'java/lang/ClassLoader' } [ERROR] stack: { 'java/lang/ClassLoader', null } [ERROR] Stackmap Frame: [ERROR] bci: @54 [ERROR] flags: { } [ERROR] locals: { 'com/acme/FooTest', 'java/net/URL', 'java/lang/ClassLoader' } [ERROR] stack: { } [ERROR] Bytecode: [ERROR] 0000000: b200 bd9a 0047 014c 1235 b600 914d 2c01 [ERROR] 0000010: a500 262c bb00 9359 b700 9412 35b6 0098 [ERROR] 0000020: 102e 102f b600 9cb6 00a0 12a2 b600 a0b6 [ERROR] 0000030: 00a5 b600 ab4c 014e 12bf 2c2b 0101 0101 [ERROR] 0000040: 2d03 0304 b800 c2b3 00bd 2ab7 0001 b800 [ERROR] 0000050: 022a b600 0312 04b6 0005 4c2a 2bb8 0006 [ERROR] 0000060: b500 07b1 [ERROR] Stackmap Table: [ERROR] full_frame(@54,{Object[#53],Object[#181],Object[#167]},{}) [ERROR] full_frame(@74,{UninitializedThis},{}) [ERROR] [ERROR] at java.lang.Class.getDeclaredMethods0(Native Method) then you should include the Java option noverify in the Surefire configuration as follows: <argLine> -javaagent:target/vulas/lib/vulas-core-${vulas.version}-jar-with-dependencies.jar -DperiodicUpload.enabled=false -DappContext.fixed.groupId=${project.groupId} -DappContext.fixed.artifactId=${project.artifactId} -DappContext.fixed.version=${project.version} -noverify <!-- Uncomment to debug the test execution or the vulnerability-assessment-tool plugin --> <!-- -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 --> </argLine> See here for more information on the noverify option: Stackoverflow Chrononsystems Informit","title":"FAQ"},{"location":"user/support/faq/#general-questions","text":"","title":"General questions"},{"location":"user/support/faq/#why-cant-i-compile-my-maven-project-anymore-after-i-activate-the-vulnerability-assessment-tool-profile","text":"You may want to check whether there are other <profile> sections that declare dependencies. If so, one of those is probably activated by default. In this case, when using the vulnerability-assessment-tool profile, those other profiles will not be active, hence, there are dependencies missing, which can lead to compile exceptions. To fix, you should activate multiple profiles at once using the -P option, see here for more information.","title":"Why can't I compile my Maven project anymore after I activate the vulnerability-assessment-tool profile?"},{"location":"user/support/faq/#why-does-vulnerability-assessment-tool-backend-refuse-http-connections-established-by-vulnerability-assessment-tool-maven-plugin","text":"The vulnerability-assessment-tool plugins gathers very detailed information about all Java archives required by an application. For example, it collects the method signatures of all methods contained in every JAR. For every archive, identified by its SHA1, this information must be uploaded to and stored by the vulnerability-assessment-tool backend in case it is not yet known. This requirement will cause a lot of uploads when an application is first analyzed, because a lot of dependencies may not be known. Problem: As a result of the above, it can happen that several HTTP POST connection requests are refused by the vulnerability-assessment-tool backend during the vulnerability-assessment-tool Maven plugin execution, which will result in error messages as follows. Copy&paste from console Solution vulnerability-assessment-tool plugin users can simply re-run the vulnerability-assessment-tool goal \"app\" multiple times up until the information for all archives has been uploaded. With each run, more and more archives will be successfully uploaded, up until a point where every archive is known. According to our experience, this is the case after a few runs only ( <5 ).","title":"Why does vulnerability-assessment-tool backend refuse HTTP connections established by vulnerability-assessment-tool Maven plugin?"},{"location":"user/support/faq/#why-do-all-http-connections-fail-from-the-vulnerability-assessment-tool-maven-plugin","text":"Problem Not a single HTTP connection can be established, which becomes obvious if even the first connection request hangs for several minutes and eventually fails as follows: [INFO] ------------------------------------------------------------------------ [INFO] Building com.at.example.spring-01 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ com.at.example.spring-01 --- [INFO] Deleting C:\\My Documents\\com.at.example.spring-01\\target [INFO] [INFO] --- maven-dependency-plugin:2.10:copy (copy-vulas) @ com.at.example.spring-01 --- [INFO] Configured Artifact: com.sap.research.security.vulas:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Configured Artifact: com.sap.research.security.vulas:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\lib\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\include\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] [INFO] --- vulas-maven-plugin:1.1.0-SNAPSHOT:clean (vulas-clean) @ com.at.example.spring-01 --- [main] INFO com.sap.psr.vulas.GoalExecution - vulnerability-assessment-tool goal execution started [id=CLEAN-1448374577441-14554386, goal=CLEAN, app=(com.at.example:com.at.example.spring-01:jar:0.0.1-SNAPSHOT)] [main] INFO com.sap.psr.vulas.backend.Collector - HTTP request started [url=, user=] [vulas-memo] INFO com.sap.psr.vulas.GoalExecution - Memory consumption (used/avg): [57.75 MB/57.75 MB], JVM (free/total/max): [183.75 MB/241.50 MB/3559.50 MB] [main] ERROR com.sap.psr.vulas.backend.Collector - HTTP request error while calling [], HTTP response written to [C:\\Users\\iXXXXXX\\AppData\\Local\\Temp\\vulas-tmp-8966348801119324800.html] Solution Run the vulnerability-assessment-tool Maven plugin with a different proxy than the default proxy specified in the configuration ( none ). You need to change 2 settings: On the command line, run Maven as follows, whereby <proxy> can be custom_proxy or simply proxy mvn -Dhttp.proxyHost = <proxy> -Dvulas vulas:app In the Maven Surefire plugin, include the -Dhttp.proxyHost system property for the JVM spawned for JUnit tests: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.14 </version> <configuration> <argLine> ... -Dhttp.proxyHost=custom_proxy ... </argLine> </configuration> </plugin>","title":"Why do all HTTP connections fail from the vulnerability-assessment-tool Maven plugin?"},{"location":"user/support/faq/#why-does-my-workspace-stay-empty","text":"When executing a vulas goal, your workspace is not filled with the results of the scan. Instead of this your results are usually uploaded to the PUBLIC workspace of the vulnerability-assessment-tool Frontend. You first need to insure that you are using at least version 3.0 of vulnerability-assessment-tool. The workspace feature was introduced with vulnerability-assessment-tool 3. By default, if you are running vulnerability-assessment-tool 2.x (and you should not!) all the data are stored in the \"PUBLIC\" workspace in the vulnerability-assessment-tool Frontend. Please notice that the vulnerability-assessment-tool plugin name was changed with vulnerability-assessment-tool 3: it was changed from vulas-maven-plugin to plugin-maven (click here for more details). It is quite usual that developers working with Jenkins/Piper are pointing to an old version of vulnerability-assessment-tool (2.x) because their Jenkins/Piper platform itself points to the old vulnerability-assessment-tool plugin name. A simple update there usually solves the issue. You need to insure that you have correctly indicated to vulnerability-assessment-tool where to upload the results of your scans (e.g. in your workspace). Please click here and here for details about workspaces and how to use them.","title":"Why does my workspace stay empty?"},{"location":"user/support/faq/#what-is-the-cause-of-the-following-error-vulas-maven-plugin3xx-or-one-of-its-dependencies-could-not-be-resolved","text":"You are running the execution of a maven goal and are facing an error similar to the following one: [ERROR] Plugin com.sap.research.security.vulas:vulas-maven-plugin:3.0.8 or one of its dependencies could not be resolved: Could not find artifact com.sap.research.security.vulas:vulas-maven-plugin:jar:3.0.8 in mirror1 (url) -> [Help 1] You most probably updated your settings to use Maven 3.x instead of Maven 2.x. The vulnerability-assessment-tool plugin was renamed with vulnerability-assessment-tool 3.x: it was changed from vulas-maven-plugin to plugin-maven . You may need to update your settings accordingly (click here for more details on how to update your settings).","title":"What is the cause of the following ERROR: vulas-maven-plugin:3.x.x or one of its dependencies could not be resolved?"},{"location":"user/support/faq/#why-do-i-get-the-following-message-warn-app-does-not-exist-in-backend-goal-upload-skipped","text":"Symptom : The console contains a log message as follows: WARN com.sap.psr.vulas.backend.BackendConnector - App [group=com.acme, artifact=parent, version=1-SNAPSHOT, packaging=pom] does not exist in backend, goal upload skipped Explanation : Information related to the execution of a goal, e.g., execution time or memory consumption, cannot be uploaded as the respective application does not exist in the backend. This is not necessarily a problem, hence, the message is issued as warning. Examples where an application does not exist in the backend are as follows: If an application does neither have any dependencies nor source code, e.g., in folder src/main/java , it will not be uploaded to the backend (depending on configuration parameter vulas.core.app.uploadEmpty , which defaults to false ). In this case, the execution of goal execution information cannot be uploaded. Typical examples of empty applications are Maven aggregator projects ( <packaging>pom</packaging> ). If an application version is analyzed for the first time, the initial execution of the clean goal will also result in this warning message.","title":"Why do I get the following message: WARN: App does not exist in backend, goal upload skipped?"},{"location":"user/support/faq/#why-does-vulnerability-assessment-tool-show-vulnerabilities-that-are-seemingly-related-to-other-components","text":"Symptom : In the Web frontend or in the report, vulnerability-assessment-tool displays findings which seem to be related to others components. Example : In the following screenshot, several CVEs related to jackson-databind are shown for spring-cloud-cloudfoundry-connector . Explanation : vulnerability-assessment-tool detects the presence of vulnerable code, no matter the file name or GAV of a dependency. Sometimes, an archive re-bundles code of other open source projects. Sometimes, re-bundled code is even re-packaged, thus, the Java package namespace is altered. Both of those cases are still detected by vulnerability-assessment-tool. In the previous example, the file spring-cloud-cloudfoundry-connector-2.0.5.RELEASE.jar contains (re-bundles) vulnerable code of jackson-databind .","title":"Why does vulnerability-assessment-tool show vulnerabilities that are seemingly related to other components"},{"location":"user/support/faq/#understanding-the-results-produced-by-vulnerability-assessment-tool","text":"","title":"Understanding the results produced by vulnerability-assessment-tool"},{"location":"user/support/faq/#vulnerability-assessment-tool-reported-vulnerabilities-for-which-i-found-no-data-in-nvd-what-should-i-do-about-them","text":"For vulnerabilities that do not come from the NVD we do provide reference links. They are listed in the vulnerability details page accessible clicking on the different rows of the vulnerability main table (see example below).","title":"vulnerability-assessment-tool reported vulnerabilities for which I found no data in NVD. What should I do about them?"},{"location":"user/support/faq/#why-is-vulnerability-assessment-tool-is-not-detecting-all-vulnerabilities-of-my-project","text":"If the vulnerability is included in our knowledge base but it is not detected for your application, you can select the checkbox \u201cInclude historical vulnerabilities\u201d in the vulnerability-assessment-tool frontend and hit \u201cReload\u201d button: you will see all CVEs that applied to previous versions of your dependencies. The indicates that a given CVE did apply to earlier versions, but you are currently using a non-vulnerable one. Despite our best efforts to keep the vulnerability-assessment-tool vulnerability knowledge base continuously updated, it is possible that a particular vulnerability is not yet covered. Query /backend/bugs to check if a vulnerability is covered or not.","title":"Why is vulnerability-assessment-tool is not detecting all vulnerabilities of my project?"},{"location":"user/support/faq/#method-level-bill-of-material-goal-app","text":"","title":"Method-level bill of material (goal app)"},{"location":"user/support/faq/#app-notfoundexception-when-analyzing-jar-files","text":"Problem: When analyzing JAR files, error messages similar to the following are printed: ERROR com.sap.psr.vulas.JarAnalyzer - JarAnalyzer[jar/war=org.apache.servicemix.bundles.jaxb-xjc-2.2.4_1.jar, mavenId=(org.apache.servicemix.bundles:org.apache.servicemix.bundles.jaxb-xjc:2.2.4_1), instr=false, instrCtx=(com.acme:foo:pom:1.0-SNAPSHOT)]: NotFoundException while analyzing class [1.0.com.sun.xml.xsom.parser.JAXPParser]: 1.0.com.sun.xml.xsom.parser.JAXPParser Explanation: This can be due to the use of Java identifiers that do not confirm with the Java language specification . In this example, the actual package name of \"1.0.com.sun.xml.xsom.parser.JAXPParser\", as seen in the JAR file, is \"1.0\". vulnerability-assessment-tool, however, uses dots for separating package identifiers. Note: As of Java 9, multi-release archives can contain class files in subdirectories. They are not yet supported by vulnerability-assessment-tool. Solution: Not yet known. For the time being, clarify who produced the respective JAR file.","title":"app : NotFoundException when analyzing JAR files?"},{"location":"user/support/faq/#app-the-goal-execution-takes-very-long","text":"Problem: The execution of the APP goal takes very long. Explanation: Whenever a JAR, identified by its SHA1, is unknown to the backend, all its method signatures are gathered and uploaded. As a result, the first execution(s) of vulas:app can take some time, as any yet unknown JAR need to be covered. Future executions will be significantly faster.","title":"app : The goal execution takes very long"},{"location":"user/support/faq/#app-the-goal-execution-breaks-with-a-5xx-response-code-received-from-the-backend","text":"Problem: The goal execution breaks with a 5xx response code received from the backend. Explanation: This can happen if multiple processes (on the same computer or remotely) try to upload the same method signature to the backend. In such cases, one can simply restart at a later time to avoid the clash.","title":"app : The goal execution breaks with a 5xx response code received from the backend"},{"location":"user/support/faq/#app-the-goal-execution-breaks-with-a-javaniofileinvalidpathexception","text":"Problem: The goal execution breaks with a java.nio.file.InvalidPathException: Malformed input or input contains unmappable characters as viewable here below. [ERROR] Failed to execute goal com.sap.research.security.vulas:plugin-maven:3.1.6:app (default-cli) on project xxxxx: java.nio.file.InvalidPathException: Malformed input or input contains unmappable characters: shapeless/$tilde$qmark$greater$?.class Explanation : the exception is often due to an encoding problem. Solution : Try one of the following options. 1/ Add the property <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> to your pom.xml file. Current property <encoding> only works if added to the configuration section of individual plugins. OR 2/ Force the usage of the UTF-8 encoding using the \"-Dsun.jnu.encoding=UTF-8 -Dfile.encoding=UTF-8\" properties in your command line.","title":"app : The goal execution breaks with a java.nio.file.InvalidPathException"},{"location":"user/support/faq/#reachability-analysis-goals-a2c-and-t2c","text":"","title":"Reachability Analysis (goals a2c and t2c)"},{"location":"user/support/faq/#a2c-javalangoutofmemoryerror","text":"Solutions: Increase the maximum and minimum JVM heap space with -Xmx and -Xms . Prior to Java8, also add -XX:MaxPermSize=2g -XX:+CMSClassUnloadingEnabled .","title":"a2c : java.lang.OutOfMemoryError"},{"location":"user/support/faq/#a2c-timeout-during-reachability-analysis","text":"Problem: The execution of the reachability analysis causes a timeout, e.g., [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] reached timeout and will be interrupted [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.<init>(BitVectorIntSet.java:45) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.addAllOblivious(BitVectorIntSet.java:126) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.makeDenseCopy(MutableSharedBitVectorIntSet.java:984) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAll(MutableSharedBitVectorIntSet.java:752) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersectionInternal(MutableSharedBitVectorIntSet.java:1067) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersection(MutableSharedBitVectorIntSet.java:1032) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:175) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:158) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.FilteredPointerKey$SingleClassFilter.addFiltered(FilteredPointerKey.java:65) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:623) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:1) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.UnaryStatement.evaluate(UnaryStatement.java:36) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixedpoint.impl.AbstractFixedPointSolver.solve(AbstractFixedPointSolver.java:150) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.StandardSolver.solve(StandardSolver.java:40) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder.makeCallGraph(PropagationCallGraphBuilder.java:269) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.wala.WalaCallgraphConstructor.buildCallgraph(WalaCallgraphConstructor.java:308) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.ReachabilityAnalyzer.run(ReachabilityAnalyzer.java:265) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - java.lang.Thread.run(Thread.java:745) [main] ERROR com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] terminated w/o success after [ 15,0 min] Solution(s): Increase the timeout by changing the configuration setting vulas.reach.timeout , e.g., mvn -Dvulas.reach.timeout=600 -Dvulas compile vulas:a2c Decrease the precision of the call graph construction, e.g., by changing the system property vulas.reach.wala.callgraph.reflection . For instance, run the reachability analysis as follows: mvn -Dvulas vulas:a2c -Dcallgraph.reflection=NONE . See manual/analysis#a2c for more configuration options.","title":"a2c : Timeout during reachability analysis"},{"location":"user/support/faq/#a2c-javaiofilenotfoundexception","text":"Problem: During a2c , a given JAR cannot be found by Wala, which produces an error message as following: Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError: java.io.FileNotFoundException: .\\InfoView\\dep\\BOE\\WEB-INF\\eclipse\\plugins\\axis2\\lib\\jaxb-api.jar (The system cannot find the file specified) Solution(s): Set the configuration parameter vulas.reach.preprocessDependencies to true Explanation: The problem occurs if the MANIFEST file of a JAR refers to other dependencies using the Class-Path entry. Wala, for instance, will try to resolve those dependencies. The pre-processing will remove the corresponding manifest file entries.","title":"a2c : java.io.FileNotFoundException?"},{"location":"user/support/faq/#a2c-invalid-byte-code-in-method","text":"Problem: During a2c or t2c , the call graph construction by Wala fails with an error message as follows: error: invalid byte code in method org.springframework.asm.ClassReader.readConst(I[C)Ljava/lang/Object; Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError at com.ibm.wala.util.debug.Assertions.UNREACHABLE(Assertions.java:46) at com.ibm.wala.classLoader.ShrikeCTMethod.makeDecoder(ShrikeCTMethod.java:107) Solution: Append the respective package to the configuration setting vulas.reach.wala.callgraph.exclusions , which lists all the Java packages to be ignored by Wala. Note that dots (.) separating package names are replaced by slash (/). Example: In case of the above error message, one has to add the string org/springframework/asm/.* in order to ignore all classes of package asm . The new value of the configuration setting looks as follows: vulas.reach.wala.callgraph.exclusions = java/awt/.*;javax/swing/.*;sun/awt/.*;sun/swing/.*;org/netbeans/.*;com/sun/.*;org/openide/.*;com/ibm/crypto/.*;com/ibm/security/.*;org/apache/xerces/.*;org/springframework/asm/.*","title":"a2c : Invalid byte code in method?"},{"location":"user/support/faq/#instrumentation-and-trace-collection-goals-test-and-instr","text":"","title":"Instrumentation and trace collection (goals test and instr)"},{"location":"user/support/faq/#test-javalangnosuchmethoderror","text":"Problem: The execution of the test phase throws a NoSuchMethodError exception. This can happen if an application makes use (directly or transitively) of an older release of a library that is also required by vulnerability-assessment-tool. In the below example, an application used commons-collections v3.0.0, while vulnerability-assessment-tool needs commons-collections v3.2.2 (whose classes are actually included in the vulas-with-dependencies.jar). ------------------------------------------------------- T E S T S ------------------------------------------------------- java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:386) at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:401) Caused by: java.lang.NoSuchMethodError: org.apache.commons.collections.CollectionUtils.isEmpty(Ljava/util/Collection;)Z at org.apache.commons.configuration.XMLConfiguration.constructHierarchy(XMLConfiguration.java:640) at org.apache.commons.configuration.XMLConfiguration.initProperties(XMLConfiguration.java:596) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:1009) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:972) at org.apache.commons.configuration.XMLConfiguration$XMLFileConfigurationDelegate.load(XMLConfiguration.java:1647) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:324) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:261) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:238) at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.load(AbstractHierarchicalFileConfiguration.java:184) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:608) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:587) at com.sap.psr.vulas.monitor.DynamicTransformer.<init>(DynamicTransformer.java:81) at com.sap.psr.vulas.monitor.DynamicTransformer.getInstance(DynamicTransformer.java:304) at com.sap.psr.vulas.monitor.DynamicTransformer.premain(DynamicTransformer.java:320) ... 6 more FATAL ERROR in native method: processing of -javaagent failed Exception in thread \"main\" Solution: Change the dependency of your application to a more recent release. In the above example, the following XML snippet was added to the application's POM (which transitively depended on it): <dependency> <groupId> commons-collections </groupId> <artifactId> commons-collections </artifactId> <version> 3.2.2 </version> </dependency>","title":"TEST : java.lang.NoSuchMethodError?"},{"location":"user/support/faq/#test-not-all-vulnerability-assessment-tool-analysis-results-are-uploaded-to-the-backend","text":"Problem: At the end of the JUnit test case execution ( mvn -Dvulas test ), not all the vulnerability-assessment-tool analysis results are uploaded to the the vulnerability-assessment-tool backend. The reason is that the Maven Surefire Plugin kills the JVM before vulnerability-assessment-tool' shutdown hook uploaded all the data. Solution: Disable the upload by changing the Surefire configuration in the POM file as follows. The analysis results will then be written in the folder target/vulas/upload . Afterwards, run the vulnerability-assessment-tool plugin goal \"upload\" in order to upload the JSON analysis results to the backend ( mvn -Dvulas vulas:upload ). <argLine> -Dvulas.upload=false","title":"TEST : Not all vulnerability-assessment-tool analysis results are uploaded to the backend"},{"location":"user/support/faq/#test-how-to-run-dvulas-test-in-projects-using-mockito","text":"Problem : when running mvn -Dvulas test , tests fail with an error such as org.mockito.exceptions.misusing.MissingMethodInvocationException Solution : Run your tests as usual: mvn test Then run them again with vulnerability-assessment-tool enabled to perform reachability analysis: mvn -Dmaven.test.failure.ignore = true -Dvulas test vulas:upload Alternative solutions (when running mvn -Dvulas test ) : disable selectively the failing tests ignore selected jars","title":"TEST : How to run -Dvulas test in projects using Mockito?"},{"location":"user/support/faq/#test-byte-code-instrumentation-fails","text":"Problem No traces are collected during the execution of JUnit tests, no matter which instrumentor is used. Moreover, no corresponding error messages or exceptions are printed to the console. A possible indicator of that problem is the appearance of the log message \"Completed instantiation of trace collector\" after the log message \"Tests run: XXX, Failures: XXX, Errors: XXX, Skipped: XXX, Time elapsed: XXX sec\", which signals the termination of the actual JUnit tests. Example: [main] INFO com.sap.psr.vulas.monitor.InstrumentationControl - JAR [C:\\Users\\XXXXXX\\.m2\\repository\\org\\apache\\commons\\commons-lang3\\3.2\\commons-lang3-3.2.jar] is blacklisted: [false] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.141 sec - in code.MainTest [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET [uri=http://localhost:8033/backend/apps/XXXXXX/XXXXXX/XXXXXX/bugs?historical=false, proxy=false] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET completed with response code [200] in [0,0573 min] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.BackendConnector - [53] constructs for [7] bugs received from backend [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - Completed instantiation of trace collector [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No paths collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No traces collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.GoalExecution - vulnerability-assessment-tool goal execution finished [id=TEST-1487175325075-7552264, goal=TEST, app=(XXXXXX:XXXXXX:XXXXXX)] in [0,0877 min] Solution Similar to the above problem, it can happen that an application depends on a previous release of Javassist. As such, methods required by vulnerability-assessment-tool are not present at the time vulnerability-assessment-tool tries to change the byte code of loaded classes. As for the previous problem, you can add an explicit dependency to the application under test in order to let Maven resolve to a recent release of Javassist.","title":"TEST : Byte code instrumentation fails"},{"location":"user/support/faq/#test-the-forked-vm-terminated","text":"Problem: Tests terminate with a log message as follows: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Solutions: Increase JVM heap space by adding -Xmx4096M -Xms2048M (or more if possible) to the <argLine> argument of the Maven Surefire plugin Select an instrumentor that consumes less memory by adding, for instance, -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor .","title":"TEST : The forked VM terminated"},{"location":"user/support/faq/#test-incomplete-app-context","text":"Problem Tests terminate with the error message App context incomplete: [group=, artifact=, version=] and there exists a white space in any of the parent directories of the Maven project (e.g., C:\\My Documents\\projects\\foo ). Solutions Move the Maven project to a location without whitespaces in the names of any of the parent directories. Open the pom.xml and replace the Maven variable ${project.build.directory} in the <argLine> configuration setting of the maven-surefire-plugi n by the relative path of the respective directory, typically target . Open the POM file and remove the -Dvulas.core.uploadDir and -Dvulas.shared.tmpDir system properties in the <argLine> configuration setting of the maven-surefire-plugin . Create two new system property variables in the configuration section of the maven-surefire-plugin as follows (see here for more information). <systemPropertyVariables> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> </systemPropertyVariables>","title":"TEST : Incomplete app context"},{"location":"user/support/faq/#test-error-injecting-private-orgeclipseaetherspiloglogger-orgapachemavenrepositoryinternaldefaultversionresolverlogger","text":"Problem When running the vulnerability-assessment-tool test goal, you face an error similar to Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger Solution This error seems to appear with certain versions of Maven. It should disappear with maven 3.5.2 or higher. Please insure which version of maven you are using. If you locally run maven on your machine, please upgrade your local maven version to maven 3.5.2 or higher and run your scan again. If you perform your scans in a CI/CD environment like Jenkins, please check which version of Maven is used there. Then validate that the issue is linked to the current maven version (see previous point). Once you validated that the current Maven version is responsible for the issue, proceed with the update/upgrade to Maven 3.5.2 or higher in your CI/CD environment. As an example in Jenkins environments you can use one of the following alternatives: Make an upgrade request to your Jenkins administrator. Install Maven \"globaly\": in this case you can continue using your former command ex: mvn clean compile vulas:clean vulas:app install vulas:upload -Pvulas -Dskip.integration.tests as it is and Jenkins will use the new version. Install maven as new \"Global Tool\": you can do this in \"Manage Jenkins\" -> \"Global Tool Configuration\". Here you find the entry \"Maven installations\". Add there the new Maven installation \"M360\" (if you like to install maven 3.6.0) with the installer \"Install from Apache\" Version 3.6.0. As a consequence, you will need to change the command in your job/task so that the new Maven version is used instead of the global one (which is still the version including the bug) and your command should like like /var/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation/M360/bin/mvn clean compile vulas:clean vulas:app install vulas:upload -Pvulas -Dskip.integration.tests","title":"TEST : \"Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger\""},{"location":"user/support/faq/#junit-tests-using-powermock-fail-when-using-vulnerability-assessment-tool","text":"Problem JUnit tests making use of Powermock fail when activating the vulnerability-assessment-tool profile. Explanation In order to collect execution traces during test execution, the vulnerability-assessment-tool agent has to be registered at the JVM. This is done in the configuration section of the surefire plugin inside the vulnerability-assessment-tool profile. The parallel use of Powermock and the vulnerability-assessment-tool agent, which modifies all the bytecode of every class loaded by the JVM, fails in certain cases. Solution(s) This problem can be solved in several ways: Ignore all test failures by adding -Dmaven.test.failure.ignore=true (also see other options of the maven-surefire-plugin ) In case of multi-module projects, continue the build of later modules using the options --fail-never or --fail-at-end (see here for more information) Exclude problematic classes from being instrumented by adding their prefixes via -Dvulas.core.instr.blacklist.classes.custom=foo.bar,bar.baz.Class,... Exclude single problematic tests by modifying the <excludes> section of the surefire configuration in the vulnerability-assessment-tool profile: <excludes> <exclude> **/doesnotexist.java </exclude> </excludes>","title":"JUnit tests using Powermock fail when using vulnerability-assessment-tool"},{"location":"user/support/faq/#python","text":"","title":"Python"},{"location":"user/support/faq/#app-goal-is-slow","text":"Dependencies are analyzed by setting up a virtual environment for the respective application. The setup of such a virtualenv can take some time (no matter whether it is done in the context of vulnerability-assessment-tool or not). Moreover, whenever a Python library is found that is not yet known to the backend, its bill of material needs to be uploaded. The delay caused by this initial upload will not occur for subsequent scans.","title":"app goal is slow"},{"location":"user/support/faq/#virtualenv-problems","text":"Run virtualenv from the command line to see whether it is properly installed and working.","title":"virtualenv problems"},{"location":"user/support/faq/#other-topics","text":"","title":"Other topics"},{"location":"user/support/faq/#report-the-html-result-report-is-not-properly-rendered-inside-jenkins","text":"Symptom : The HTML report is not properly rendered inside Jenkins (e.g., no images, no color-coding, no JavaScript, see the example screenshot below). Solution : Either (a) download a ZIP of the vulnerability-assessment-tool report (the link can be found in the upper-right corner), or (b) adjust the content security policy (CSP) of Jenkins as described here . In the latter case, you should execute the following command in the Jenkins script console (on a single line ): System . setProperty ( \"hudson.model.DirectoryBrowserSupport.CSP\" , \"sandbox allow-scripts; default-src 'none'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'unsafe-inline'\" )","title":"report: The HTML result report is not properly rendered inside Jenkins"},{"location":"user/support/faq/#no-log-messages-of-the-vulnerability-assessment-tool-maven-plugin-appear-on-the-console-why","text":"Symptom vulnerability-assessment-tool log messages are not printed to the console (e.g., during the execution of the Maven lifecycle phase \"test\"). Instead, the following error message is printed. ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. Explanation The vulnerability-assessment-tool Maven plugin makes use of log4j version 1, a corresponding configuration file is included in its JAR file. If, however, the project under analysis makes use of log4j version 2, but does not have a log4j2.xml file in folder src/main/resources , no log message of vulnerability-assessment-tool but the above error message is printed. Still, the traces are actually collected and uploaded to the central engine. Solution Create a file src/main/resources/log4j2.xml with the following sample content (copied from here ) and adapt as needed. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <Configuration> <Appenders> <Console name= \"STDOUT\" target= \"SYSTEM_OUT\" > <PatternLayout pattern= \"%d %-5p [%t] %C{2} (%F:%L) - %m%n\" /> </Console> </Appenders> <Loggers> <Logger name= \"org.apache.log4j.xml\" level= \"info\" /> <Root level= \"info\" > <AppenderRef ref= \"STDOUT\" /> </Root> </Loggers> </Configuration>","title":"No log messages of the vulnerability-assessment-tool Maven plugin appear on the console. Why?"},{"location":"user/support/faq/#outofmemoryerror-gc-overhead-limit-exceeded","text":"Use the command line options -Xms and -Xmx to adjust the heap memory available to the JVM. Chose a value for -Xmx that is close to your machine's physical memory. In case of Maven, use the statement export MAVEN_OPTS=\"-Xms4g -Xmx8g\" . For versions before Java 8, you should also add the options -XX:MaxPermSize=2024M -XX:+CMSClassUnloadingEnabled . Notes: See here for problems related to the heap space allocations on 32bit Java versions See here for background information on Java memory management","title":"OutOfMemoryError: GC overhead limit exceeded?"},{"location":"user/support/faq/#i-get-an-error-saying-verifyerror-inconsistent-stackmap-frames-at-branch-target-what-should-i-do","text":"If the execution of the Maven Surefire Plugin during the Maven lifecycle phase test fails with a java.lang.VerifyError similar to the following: [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test (default-test) on project foo-bar: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test failed: There was an error in the forked process [ERROR] java.lang.VerifyError: Inconsistent stackmap frames at branch target 54 [ERROR] Exception Details: [ERROR] Location: [ERROR] com/acme/FooTest.<init>()V @54: aconst_null [ERROR] Reason: [ERROR] Type uninitializedThis (current frame, locals[0]) is not assignable to 'com/acme/FooTest' (stack map, locals[0]) [ERROR] Current Frame: [ERROR] bci: @16 [ERROR] flags: { flagThisUninit } [ERROR] locals: { uninitializedThis, null, 'java/lang/ClassLoader' } [ERROR] stack: { 'java/lang/ClassLoader', null } [ERROR] Stackmap Frame: [ERROR] bci: @54 [ERROR] flags: { } [ERROR] locals: { 'com/acme/FooTest', 'java/net/URL', 'java/lang/ClassLoader' } [ERROR] stack: { } [ERROR] Bytecode: [ERROR] 0000000: b200 bd9a 0047 014c 1235 b600 914d 2c01 [ERROR] 0000010: a500 262c bb00 9359 b700 9412 35b6 0098 [ERROR] 0000020: 102e 102f b600 9cb6 00a0 12a2 b600 a0b6 [ERROR] 0000030: 00a5 b600 ab4c 014e 12bf 2c2b 0101 0101 [ERROR] 0000040: 2d03 0304 b800 c2b3 00bd 2ab7 0001 b800 [ERROR] 0000050: 022a b600 0312 04b6 0005 4c2a 2bb8 0006 [ERROR] 0000060: b500 07b1 [ERROR] Stackmap Table: [ERROR] full_frame(@54,{Object[#53],Object[#181],Object[#167]},{}) [ERROR] full_frame(@74,{UninitializedThis},{}) [ERROR] [ERROR] at java.lang.Class.getDeclaredMethods0(Native Method) then you should include the Java option noverify in the Surefire configuration as follows: <argLine> -javaagent:target/vulas/lib/vulas-core-${vulas.version}-jar-with-dependencies.jar -DperiodicUpload.enabled=false -DappContext.fixed.groupId=${project.groupId} -DappContext.fixed.artifactId=${project.artifactId} -DappContext.fixed.version=${project.version} -noverify <!-- Uncomment to debug the test execution or the vulnerability-assessment-tool plugin --> <!-- -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 --> </argLine> See here for more information on the noverify option: Stackoverflow Chrononsystems Informit","title":"I get an error saying VerifyError: Inconsistent stackmap frames at branch target. What should I do?"},{"location":"user/tutorials/","text":"Getting started \u00b6 Welcome to the vulnerability-assessment-tool tutorials. Here you can find a set of step-by-step guides on how to perform the most common operations with vulnerability-assessment-tool. For detailed extensive documentation, please check out the vulnerability-assessment-tool Manual . Workspace \u00b6 Create a workspace (Beginner) Workspaces for multiple releases/branches (Advanced) Java \u00b6 Scanning Java apps built with Maven (Beginner) Scanning Java apps built with Gradle (Beginner) Scanning Java apps (no/other build system) (Beginner) - please follow this tutorial if your project neither uses Maven nor Gradle. Reachability analysis (Java/Maven) (Advanced) Python \u00b6 Scanning Python apps (other build systems) (Beginner) Other topics \u00b6 Automating vulnerability-assessment-tool scans with Jenkins Demystifying vulnerability-assessment-tool reports","title":"Getting started"},{"location":"user/tutorials/#getting-started","text":"Welcome to the vulnerability-assessment-tool tutorials. Here you can find a set of step-by-step guides on how to perform the most common operations with vulnerability-assessment-tool. For detailed extensive documentation, please check out the vulnerability-assessment-tool Manual .","title":"Getting started"},{"location":"user/tutorials/#workspace","text":"Create a workspace (Beginner) Workspaces for multiple releases/branches (Advanced)","title":"Workspace"},{"location":"user/tutorials/#java","text":"Scanning Java apps built with Maven (Beginner) Scanning Java apps built with Gradle (Beginner) Scanning Java apps (no/other build system) (Beginner) - please follow this tutorial if your project neither uses Maven nor Gradle. Reachability analysis (Java/Maven) (Advanced)","title":"Java"},{"location":"user/tutorials/#python","text":"Scanning Python apps (other build systems) (Beginner)","title":"Python"},{"location":"user/tutorials/#other-topics","text":"Automating vulnerability-assessment-tool scans with Jenkins Demystifying vulnerability-assessment-tool reports","title":"Other topics"},{"location":"user/tutorials/java_cli/","text":"Scanning Java apps with the CLI \u00b6 This tutorial will walk you through the steps needed to setup and use vulnerability-assessment-tool to scan a Java application that is not built with tools such as Maven or Gradle . Terminology: 'Goals' For consistency with the terminology used in Maven, the different \"commands\" available in vulnerability-assessment-tool are referred to as \" goals \". Prerequisites \u00b6 JDK 7 or later URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a vulnerability-assessment-tool workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Download \u00b6 Please download the latest ZIP archive vulas-cli-3.1.6.zip from Releases and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./vulas-cli-3.1.6-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the vulnerability-assessment-tool client. This is what you will use later to execute vulnerability-assessment-tool scans. ./instr/lang-java-3.1.6-jar-with-dependencies.jar This is used to instrument the Java runtime when performing dynamic analysis. ./vulas-custom.properties.sample This is a template for the configuration file required by vulnerability-assessment-tool. You will change it in order to specify an identifier for your application (see below). Setup \u00b6 Rename the file vulas-custom.properties.sample to vulas-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. Specify how vulnerability-assessment-tool can distinguish the code of your application from its dependencies, which is necessary for the call graph construction during the reachability analyses (goals a2c and t2c ). You can do so in two different ways: you can use either vulas.core.app.appPrefixes or vulas.core.app.appJarNames . # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames = Warning In order for the static reachability analysis to be performed correctly, all application methods must be used as entry points for the call graph construction. Therefore, if the criterion to distinguish application code and dependencies is not specified correctly, the potential execution of vulnerable open-source methods may be missed. To check whether the specification is correct, you may want to inspect the application frontend and see whether there are any items in the Dependencies tab that are created by you or your organization (there should be none, only 3 rd party libraries should be there), and whether there are open-source packages at all in the table on the Dependencies tab (there should be none, only packages from your own project). IMPORTANT REMARKS You should also keep the following into account: Single java and class files are always considered as application code ( regardless of the package prefix configured with vulas.core.app.appPrefixes ). JARs are always considered application dependencies unless they only contain methods starting with the configured package prefix. Nested JARs must be manually extracted (but no need to do so for WARs). Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to. clean \u00b6 java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal clean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Java (CLI)"},{"location":"user/tutorials/java_cli/#scanning-java-apps-with-the-cli","text":"This tutorial will walk you through the steps needed to setup and use vulnerability-assessment-tool to scan a Java application that is not built with tools such as Maven or Gradle . Terminology: 'Goals' For consistency with the terminology used in Maven, the different \"commands\" available in vulnerability-assessment-tool are referred to as \" goals \".","title":"Scanning Java apps with the CLI"},{"location":"user/tutorials/java_cli/#prerequisites","text":"JDK 7 or later URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a vulnerability-assessment-tool workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/java_cli/#download","text":"Please download the latest ZIP archive vulas-cli-3.1.6.zip from Releases and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./vulas-cli-3.1.6-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the vulnerability-assessment-tool client. This is what you will use later to execute vulnerability-assessment-tool scans. ./instr/lang-java-3.1.6-jar-with-dependencies.jar This is used to instrument the Java runtime when performing dynamic analysis. ./vulas-custom.properties.sample This is a template for the configuration file required by vulnerability-assessment-tool. You will change it in order to specify an identifier for your application (see below).","title":"Download"},{"location":"user/tutorials/java_cli/#setup","text":"Rename the file vulas-custom.properties.sample to vulas-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. Specify how vulnerability-assessment-tool can distinguish the code of your application from its dependencies, which is necessary for the call graph construction during the reachability analyses (goals a2c and t2c ). You can do so in two different ways: you can use either vulas.core.app.appPrefixes or vulas.core.app.appJarNames . # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames = Warning In order for the static reachability analysis to be performed correctly, all application methods must be used as entry points for the call graph construction. Therefore, if the criterion to distinguish application code and dependencies is not specified correctly, the potential execution of vulnerable open-source methods may be missed. To check whether the specification is correct, you may want to inspect the application frontend and see whether there are any items in the Dependencies tab that are created by you or your organization (there should be none, only 3 rd party libraries should be there), and whether there are open-source packages at all in the table on the Dependencies tab (there should be none, only packages from your own project). IMPORTANT REMARKS You should also keep the following into account: Single java and class files are always considered as application code ( regardless of the package prefix configured with vulas.core.app.appPrefixes ). JARs are always considered application dependencies unless they only contain methods starting with the configured package prefix. Nested JARs must be manually extracted (but no need to do so for WARs).","title":"Setup"},{"location":"user/tutorials/java_cli/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/java_cli/#app","text":"java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/java_cli/#report","text":"java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to.","title":"report"},{"location":"user/tutorials/java_cli/#clean","text":"java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal clean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_cli/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/java_gradle/","text":"Scanning Java apps built with Gradle \u00b6 Prerequisites \u00b6 JDK 7 or later URL of the package repository to download the plugin JAR ( <PACKAGE-REPO> ) URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a vulnerability-assessment-tool workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Setup \u00b6 The plugin for Gradle requires changes of the following two files: build.gradle buildscript { repositories { maven { url '<PACKAGE-REPO>' } mavenCentral() } dependencies { classpath('com.sap.research.security.vulas:plugin-gradle:3.1.6') { changing = true } } } allprojects { apply plugin: \"vulas\" } gradle.properties // Used to identify the scan in the apps Web frontend group = <GROUP> version = <VERSION> // Replace token of test space vulas.core.space.token = <WORKSPACE-TOKEN> vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the vulnerability-assessment-tool analysis goals app , a2c etc. are listed among Other tasks when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here . Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 ./gradlew assemble vulasApp Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 ./gradlew vulasReport A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. clean \u00b6 ./gradlew vulasClean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Java (Gradle)"},{"location":"user/tutorials/java_gradle/#scanning-java-apps-built-with-gradle","text":"","title":"Scanning Java apps built with Gradle"},{"location":"user/tutorials/java_gradle/#prerequisites","text":"JDK 7 or later URL of the package repository to download the plugin JAR ( <PACKAGE-REPO> ) URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a vulnerability-assessment-tool workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/java_gradle/#setup","text":"The plugin for Gradle requires changes of the following two files: build.gradle buildscript { repositories { maven { url '<PACKAGE-REPO>' } mavenCentral() } dependencies { classpath('com.sap.research.security.vulas:plugin-gradle:3.1.6') { changing = true } } } allprojects { apply plugin: \"vulas\" } gradle.properties // Used to identify the scan in the apps Web frontend group = <GROUP> version = <VERSION> // Replace token of test space vulas.core.space.token = <WORKSPACE-TOKEN> vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the vulnerability-assessment-tool analysis goals app , a2c etc. are listed among Other tasks when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here .","title":"Setup"},{"location":"user/tutorials/java_gradle/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/java_gradle/#app","text":"./gradlew assemble vulasApp Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/java_gradle/#report","text":"./gradlew vulasReport A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities.","title":"report"},{"location":"user/tutorials/java_gradle/#clean","text":"./gradlew vulasClean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_gradle/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/java_maven/","text":"Scanning Java apps built with Maven \u00b6 Prerequisites \u00b6 JDK 7 or later Apache Maven 3.x with settings.xml configured to download from the Maven repository hosting the vulnerability-assessment-tool plugin for Maven URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a vulnerability-assessment-tool workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Setup \u00b6 The plugin for Maven can be used with or without adding a vulnerability-assessment-tool profile to the pom.xml of your application. This tutorial guides you through the setup with vulnerability-assessment-tool profile . Cannot add the vulnerability-assessment-tool profile? If possible we recommend to use the vulnerability-assessment-tool profile as the execution of goals using the command-line is more concise (readable). If you cannot paste the vulnerability-assessment-tool profile in the pom.xml of your application you can still use the vulnerability-assessment-tool plugin for Maven. Check out the Manual Java (Maven) Add the following to the <profiles> section of the pom.xml of your application project and make sure that <vulas.shared.backend.serviceUrl> points to the URL of the backend service and that <vulas.core.space.token> specifies the token of your individual workspace (see highlighted lines). <profile> <id> vulas </id> <activation> <property> <name> vulas </name> </property> </activation> <properties> <vulas.version> 3.1.6 </vulas.version> <vulas.shared.backend.serviceUrl> http://localhost:8033/backend/ </vulas.shared.backend.serviceUrl> <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> <vulas.core.appContext.group> ${project.groupId} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${project.artifactId} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${project.version} </vulas.core.appContext.version> </properties> <build> <plugins> <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.core.app.sourceDir> ${project.build.directory}/classes,${project.basedir}/src/main/java,${project.basedir}/src/main/python </vulas.core.app.sourceDir> <!-- vulas:instr : Instruments JAR/WAR files found in source dir, and writes to target dir. Files in include dir are put into /WEB-INF/lib of output WARs. Files in lib dir are part of the class path when instrumenting. --> <vulas.core.instr.sourceDir> ${project.build.directory} </vulas.core.instr.sourceDir> <vulas.core.instr.targetDir> ${project.build.directory}/vulas/target </vulas.core.instr.targetDir> <vulas.core.instr.includeDir> ${project.build.directory}/vulas/include </vulas.core.instr.includeDir> <vulas.core.instr.libDir> ${project.build.directory}/vulas/lib </vulas.core.instr.libDir> <vulas.core.instr.writeCode> false </vulas.core.instr.writeCode> <vulas.core.instr.instrumentorsChoosen> com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor </vulas.core.instr.instrumentorsChoosen> <vulas.core.instr.searchRecursive> false </vulas.core.instr.searchRecursive> <vulas.core.monitor.periodicUpload.enabled> false </vulas.core.monitor.periodicUpload.enabled> <vulas.core.instr.maxStacktraces> 10 </vulas.core.instr.maxStacktraces> <!-- vulas:a2c/t2c : Performs static call graph analysis --> <vulas.reach.wala.callgraph.reflection> NO_FLOW_TO_CASTS_NO_METHOD_INVOKE </vulas.reach.wala.callgraph.reflection> <vulas.reach.timeout> 60 </vulas.reach.timeout> <!-- vulas:report --> <vulas.report.exceptionExcludeBugs></vulas.report.exceptionExcludeBugs> <vulas.report.reportDir> ${project.build.directory}/vulas/report </vulas.report.reportDir> </layeredConfiguration> </configuration> </plugin> </plugins> </build> </profile> In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file. Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 mvn -Dvulas compile vulas:app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . In case your application does not follow the standard structure of Maven applications, please refer to the Manual Java (Maven) to learn how to configure the vulnerability-assessment-tool plugin accordingly. Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 mvn -Dvulas vulas:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed. clean \u00b6 mvn -Dvulas vulas:clean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Java (Maven)"},{"location":"user/tutorials/java_maven/#scanning-java-apps-built-with-maven","text":"","title":"Scanning Java apps built with Maven"},{"location":"user/tutorials/java_maven/#prerequisites","text":"JDK 7 or later Apache Maven 3.x with settings.xml configured to download from the Maven repository hosting the vulnerability-assessment-tool plugin for Maven URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a vulnerability-assessment-tool workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/java_maven/#setup","text":"The plugin for Maven can be used with or without adding a vulnerability-assessment-tool profile to the pom.xml of your application. This tutorial guides you through the setup with vulnerability-assessment-tool profile . Cannot add the vulnerability-assessment-tool profile? If possible we recommend to use the vulnerability-assessment-tool profile as the execution of goals using the command-line is more concise (readable). If you cannot paste the vulnerability-assessment-tool profile in the pom.xml of your application you can still use the vulnerability-assessment-tool plugin for Maven. Check out the Manual Java (Maven) Add the following to the <profiles> section of the pom.xml of your application project and make sure that <vulas.shared.backend.serviceUrl> points to the URL of the backend service and that <vulas.core.space.token> specifies the token of your individual workspace (see highlighted lines). <profile> <id> vulas </id> <activation> <property> <name> vulas </name> </property> </activation> <properties> <vulas.version> 3.1.6 </vulas.version> <vulas.shared.backend.serviceUrl> http://localhost:8033/backend/ </vulas.shared.backend.serviceUrl> <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> <vulas.core.appContext.group> ${project.groupId} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${project.artifactId} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${project.version} </vulas.core.appContext.version> </properties> <build> <plugins> <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.core.app.sourceDir> ${project.build.directory}/classes,${project.basedir}/src/main/java,${project.basedir}/src/main/python </vulas.core.app.sourceDir> <!-- vulas:instr : Instruments JAR/WAR files found in source dir, and writes to target dir. Files in include dir are put into /WEB-INF/lib of output WARs. Files in lib dir are part of the class path when instrumenting. --> <vulas.core.instr.sourceDir> ${project.build.directory} </vulas.core.instr.sourceDir> <vulas.core.instr.targetDir> ${project.build.directory}/vulas/target </vulas.core.instr.targetDir> <vulas.core.instr.includeDir> ${project.build.directory}/vulas/include </vulas.core.instr.includeDir> <vulas.core.instr.libDir> ${project.build.directory}/vulas/lib </vulas.core.instr.libDir> <vulas.core.instr.writeCode> false </vulas.core.instr.writeCode> <vulas.core.instr.instrumentorsChoosen> com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor </vulas.core.instr.instrumentorsChoosen> <vulas.core.instr.searchRecursive> false </vulas.core.instr.searchRecursive> <vulas.core.monitor.periodicUpload.enabled> false </vulas.core.monitor.periodicUpload.enabled> <vulas.core.instr.maxStacktraces> 10 </vulas.core.instr.maxStacktraces> <!-- vulas:a2c/t2c : Performs static call graph analysis --> <vulas.reach.wala.callgraph.reflection> NO_FLOW_TO_CASTS_NO_METHOD_INVOKE </vulas.reach.wala.callgraph.reflection> <vulas.reach.timeout> 60 </vulas.reach.timeout> <!-- vulas:report --> <vulas.report.exceptionExcludeBugs></vulas.report.exceptionExcludeBugs> <vulas.report.reportDir> ${project.build.directory}/vulas/report </vulas.report.reportDir> </layeredConfiguration> </configuration> </plugin> </plugins> </build> </profile> In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file.","title":"Setup"},{"location":"user/tutorials/java_maven/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/java_maven/#app","text":"mvn -Dvulas compile vulas:app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . In case your application does not follow the standard structure of Maven applications, please refer to the Manual Java (Maven) to learn how to configure the vulnerability-assessment-tool plugin accordingly. Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/java_maven/#report","text":"mvn -Dvulas vulas:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed.","title":"report"},{"location":"user/tutorials/java_maven/#clean","text":"mvn -Dvulas vulas:clean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_maven/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/java_maven_advanced/","text":"Scanning Java apps built with Maven \u00b6 Beginner? Read here This tutorial is the second part of the introductory tutorial that you can find here . If you have not done so yet, you are warmly encouraged to follow that one first, and then come back here. This document will assume you already have a working configuration and have successfully executed the steps described in the basic tutorial. Prerequisites \u00b6 The same prerequisites as in the introductory tutorial also apply here. Goal execution \u00b6 The introductory tutorial explained how to use the app analysis goal in order to establish whether an application projects depends on open-source libraries that contain vulnerable code . This tutorial explains how to perform the static and dynamic analyses in order to collect evidence regarding the reachability or execution of vulnerable code in the context of a given application project. The reachability of vulnerable code is an important pre-requisite for the vulnerability to be exploitable. a2c \u00b6 mvn -Dvulas compile vulas:a2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from application code. By selecting a single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). test \u00b6 mvn -Dvulas vulas:prepare-vulas-agent test vulas:upload Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Dynamic Analysis is populated for all libraries subject to known vulnerabilities whose vulnerable code is executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of actual executions (if any). In the tab Statistics , the number of traced vs. the number of total executable constructs (e.g., Java methods) is shown per application package. t2c \u00b6 mvn -Dvulas compile vulas:t2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from code executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). report \u00b6 mvn -Dvulas vulas:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed. clean \u00b6 mvn -Dvulas vulas:clean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the vulas:clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Reachability analysis (Java/Maven)"},{"location":"user/tutorials/java_maven_advanced/#scanning-java-apps-built-with-maven","text":"Beginner? Read here This tutorial is the second part of the introductory tutorial that you can find here . If you have not done so yet, you are warmly encouraged to follow that one first, and then come back here. This document will assume you already have a working configuration and have successfully executed the steps described in the basic tutorial.","title":"Scanning Java apps built with Maven"},{"location":"user/tutorials/java_maven_advanced/#prerequisites","text":"The same prerequisites as in the introductory tutorial also apply here.","title":"Prerequisites"},{"location":"user/tutorials/java_maven_advanced/#goal-execution","text":"The introductory tutorial explained how to use the app analysis goal in order to establish whether an application projects depends on open-source libraries that contain vulnerable code . This tutorial explains how to perform the static and dynamic analyses in order to collect evidence regarding the reachability or execution of vulnerable code in the context of a given application project. The reachability of vulnerable code is an important pre-requisite for the vulnerability to be exploitable.","title":"Goal execution"},{"location":"user/tutorials/java_maven_advanced/#a2c","text":"mvn -Dvulas compile vulas:a2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from application code. By selecting a single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any).","title":"a2c"},{"location":"user/tutorials/java_maven_advanced/#test","text":"mvn -Dvulas vulas:prepare-vulas-agent test vulas:upload Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Dynamic Analysis is populated for all libraries subject to known vulnerabilities whose vulnerable code is executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of actual executions (if any). In the tab Statistics , the number of traced vs. the number of total executable constructs (e.g., Java methods) is shown per application package.","title":"test"},{"location":"user/tutorials/java_maven_advanced/#t2c","text":"mvn -Dvulas compile vulas:t2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from code executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any).","title":"t2c"},{"location":"user/tutorials/java_maven_advanced/#report","text":"mvn -Dvulas vulas:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed.","title":"report"},{"location":"user/tutorials/java_maven_advanced/#clean","text":"mvn -Dvulas vulas:clean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the vulas:clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_maven_advanced/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/jenkins_howto/","text":"Jenkins automation \u00b6 Quick vs. deep scans \u00b6 CI/CD jobs configured with Jenkins or Travis can be triggered in many different ways, e.g., on-commit or periodically, which decides about the frequency of scan jobs. Quick scans (without reachability analysis): If scan jobs are expected to run very frequently, e.g., after every commit in the application's source code repository, it is preferable to only execute the app analysis goal, which typically does not take more than a couple of minutes (at most). Such a quick scan detects the very same number of vulnerabilities than a deep scan, but does not collect any information about the reachability of vulnerable code. Maven mvn -Dvulas clean compile vulas:clean vulas:app Deep scans (with reachability analysis): Scan jobs that run once a day or less can include analysis goals such as a2c , test and t2c . The static analysis goals a2c and t2c , in particular, can take a considerable amount of time until completion (up to several hours), depending on the complexity of the application project under analysis (number of modules, number of application constructs, etc.): Maven mvn -Dvulas clean compile vulas:clean vulas:app vulas:a2c vulas:prepare-vulas-agent package vulas:upload vulas:t2c See here for more information on vulnerability-assessment-tool goals. Jenkins \u00b6 A typical Jenkins job configuration using the vulnerability-assessment-tool plugin for Maven comprises the following two build steps and one post-build action (see screenshot below): Build step for a quick scan or deep scan , depending on the expected run frequency. Build step -Dvulas vulas:report to create result reports (per default in folder target/vulas/result ). Post-build action with HTML Publisher Plugin to copy the Html report created by report into the Jenkins dashboard. As such, vulnerability-assessment-tool results can be consumed w/o the need to scroll through the verbose console output. Additional notes: The above assumes that the vulnerability-assessment-tool Maven profile is present in the project's pom.xml . The report goal should always be run in a separate Maven invocation. Otherwise, in case of multi-module Maven projects, report may throw a build exception before all of the modules have been analyzed.","title":"Jenkins automation"},{"location":"user/tutorials/jenkins_howto/#jenkins-automation","text":"","title":"Jenkins automation"},{"location":"user/tutorials/jenkins_howto/#quick-vs-deep-scans","text":"CI/CD jobs configured with Jenkins or Travis can be triggered in many different ways, e.g., on-commit or periodically, which decides about the frequency of scan jobs. Quick scans (without reachability analysis): If scan jobs are expected to run very frequently, e.g., after every commit in the application's source code repository, it is preferable to only execute the app analysis goal, which typically does not take more than a couple of minutes (at most). Such a quick scan detects the very same number of vulnerabilities than a deep scan, but does not collect any information about the reachability of vulnerable code. Maven mvn -Dvulas clean compile vulas:clean vulas:app Deep scans (with reachability analysis): Scan jobs that run once a day or less can include analysis goals such as a2c , test and t2c . The static analysis goals a2c and t2c , in particular, can take a considerable amount of time until completion (up to several hours), depending on the complexity of the application project under analysis (number of modules, number of application constructs, etc.): Maven mvn -Dvulas clean compile vulas:clean vulas:app vulas:a2c vulas:prepare-vulas-agent package vulas:upload vulas:t2c See here for more information on vulnerability-assessment-tool goals.","title":"Quick vs. deep scans"},{"location":"user/tutorials/jenkins_howto/#jenkins","text":"A typical Jenkins job configuration using the vulnerability-assessment-tool plugin for Maven comprises the following two build steps and one post-build action (see screenshot below): Build step for a quick scan or deep scan , depending on the expected run frequency. Build step -Dvulas vulas:report to create result reports (per default in folder target/vulas/result ). Post-build action with HTML Publisher Plugin to copy the Html report created by report into the Jenkins dashboard. As such, vulnerability-assessment-tool results can be consumed w/o the need to scroll through the verbose console output. Additional notes: The above assumes that the vulnerability-assessment-tool Maven profile is present in the project's pom.xml . The report goal should always be run in a separate Maven invocation. Otherwise, in case of multi-module Maven projects, report may throw a build exception before all of the modules have been analyzed.","title":"Jenkins"},{"location":"user/tutorials/python_cli/","text":"Scanning Python apps with the CLI \u00b6 Using vulnerability-assessment-tool for Python applications not built with SetupTools Prerequisites \u00b6 JDK 7 or later pip is installed and \"knows\" all application dependencies (check with pip list ) URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a vulnerability-assessment-tool workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Download \u00b6 Please download the latest ZIP archive vulas-cli-<VERSION>.zip from Releases and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (python files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./vulas-cli-<version>-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the vulnerability-assessment-tool client. This is what you will use later to execute vulnerability-assessment-tool scans. ./vulas-custom.properties.sample This is a template for the configuration file required by vulnerability-assessment-tool. You will change it in order to specify an identifier for your application (see below). Setup \u00b6 Rename the file vulas-custom.properties.sample to vulas-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. For Python applications, feel free to use the same value for both <GROUP> and <ARTIFACT> . Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (python files) into the folder ./app/ . Specify the setting vulas.core.bom.python.pip such that it points to a pip binary (not only the path in which the binary is located, but the binary itself, e.g., /foor/bar/pip ). pip will be used to determine the dependencies of your Python application. You can either use the global pip or one installed in a virtual environment ( virtualenv , Anaconda, etc.). # Full path to PIP binary (e.g., global installation, virtual environment or Anaconda) #vulas.core.bom.python.pip = <PATH-TO-PIP-BINARY>/pip Additional notes: Java resources contained in folder ./app/ will also be added as application code or dependencies. For the above reason, make sure that the vulnerability-assessment-tool CLI is not contained in ./app/ or other folders specified by setting vulas.core.app.sourceDir , if any. Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to. clean \u00b6 java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal clean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Python (CLI)"},{"location":"user/tutorials/python_cli/#scanning-python-apps-with-the-cli","text":"Using vulnerability-assessment-tool for Python applications not built with SetupTools","title":"Scanning Python apps with the CLI"},{"location":"user/tutorials/python_cli/#prerequisites","text":"JDK 7 or later pip is installed and \"knows\" all application dependencies (check with pip list ) URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a vulnerability-assessment-tool workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/python_cli/#download","text":"Please download the latest ZIP archive vulas-cli-<VERSION>.zip from Releases and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (python files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./vulas-cli-<version>-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the vulnerability-assessment-tool client. This is what you will use later to execute vulnerability-assessment-tool scans. ./vulas-custom.properties.sample This is a template for the configuration file required by vulnerability-assessment-tool. You will change it in order to specify an identifier for your application (see below).","title":"Download"},{"location":"user/tutorials/python_cli/#setup","text":"Rename the file vulas-custom.properties.sample to vulas-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. For Python applications, feel free to use the same value for both <GROUP> and <ARTIFACT> . Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (python files) into the folder ./app/ . Specify the setting vulas.core.bom.python.pip such that it points to a pip binary (not only the path in which the binary is located, but the binary itself, e.g., /foor/bar/pip ). pip will be used to determine the dependencies of your Python application. You can either use the global pip or one installed in a virtual environment ( virtualenv , Anaconda, etc.). # Full path to PIP binary (e.g., global installation, virtual environment or Anaconda) #vulas.core.bom.python.pip = <PATH-TO-PIP-BINARY>/pip Additional notes: Java resources contained in folder ./app/ will also be added as application code or dependencies. For the above reason, make sure that the vulnerability-assessment-tool CLI is not contained in ./app/ or other folders specified by setting vulas.core.app.sourceDir , if any.","title":"Setup"},{"location":"user/tutorials/python_cli/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/python_cli/#app","text":"java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/python_cli/#report","text":"java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to.","title":"report"},{"location":"user/tutorials/python_cli/#clean","text":"java -jar vulas-cli-3.1.6-jar-with-dependencies.jar -goal clean All application-specific data in the vulnerability-assessment-tool backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/python_cli/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/reports/","text":"Reports comprehension \u00b6 Coming soon This is being written, please come back later.","title":"Understanding reports"},{"location":"user/tutorials/reports/#reports-comprehension","text":"Coming soon This is being written, please come back later.","title":"Reports comprehension"},{"location":"user/tutorials/workspace_howto/","text":"Workspaces \u00b6 A workspace acts as a container to group the results of several application analyses. Prerequisites \u00b6 URL of the apps Web frontend: http://localhost:8033/apps Create workspace \u00b6 Proceed as follows to create a workspace. Note that by creating a workspace, you will also generate a token to be used when performing actual application scans. Connect to the apps Web frontend: http://localhost:8033/apps Click on the third button in the lower left corner: Enter the following workspace properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL). Export results : AGGREGATED: Findings are aggregated on workspace-level, one item for the entire workspace will be exported DETAILED: Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF: No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not. Important: It will not be possible to retrieve the token of a private space at later points in time, thus, note it down when it is shown right after workspace creation. Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s). Use workspace \u00b6 To use a workspace, you need to pass the token as configuration parameter vulas.core.space.token . See here for more information on how-to configure the scans clients or continue with the scan tutorials .","title":"Workspace"},{"location":"user/tutorials/workspace_howto/#workspaces","text":"A workspace acts as a container to group the results of several application analyses.","title":"Workspaces"},{"location":"user/tutorials/workspace_howto/#prerequisites","text":"URL of the apps Web frontend: http://localhost:8033/apps","title":"Prerequisites"},{"location":"user/tutorials/workspace_howto/#create-workspace","text":"Proceed as follows to create a workspace. Note that by creating a workspace, you will also generate a token to be used when performing actual application scans. Connect to the apps Web frontend: http://localhost:8033/apps Click on the third button in the lower left corner: Enter the following workspace properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL). Export results : AGGREGATED: Findings are aggregated on workspace-level, one item for the entire workspace will be exported DETAILED: Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF: No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not. Important: It will not be possible to retrieve the token of a private space at later points in time, thus, note it down when it is shown right after workspace creation. Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s).","title":"Create workspace"},{"location":"user/tutorials/workspace_howto/#use-workspace","text":"To use a workspace, you need to pass the token as configuration parameter vulas.core.space.token . See here for more information on how-to configure the scans clients or continue with the scan tutorials .","title":"Use workspace"},{"location":"user/tutorials/workspace_howto_advanced/","text":"Workspaces \u00b6 If an application has been already released to customers and, at the same time, new releases are under development, you may want to setup workspaces as follows: One workspace for the development branch, to prevent that vulnerable dependencies are introduced at development time One workspace for every release branch, to monitor whether there are new vulnerabilities for dependencies of production releases","title":"Workspaces (advanced)"},{"location":"user/tutorials/workspace_howto_advanced/#workspaces","text":"If an application has been already released to customers and, at the same time, new releases are under development, you may want to setup workspaces as follows: One workspace for the development branch, to prevent that vulnerable dependencies are introduced at development time One workspace for every release branch, to monitor whether there are new vulnerabilities for dependencies of production releases","title":"Workspaces"},{"location":"user/tutorials/partials/create_workspace/","text":"Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Create workspace"},{"location":"user/tutorials/partials/vulas_profile/","text":"<profile> <id> vulas </id> <activation> <property> <name> vulas </name> </property> </activation> <properties> <vulas.version> 3.1.6 </vulas.version> <vulas.shared.backend.serviceUrl> http://localhost:8033/backend/ </vulas.shared.backend.serviceUrl> <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> <vulas.core.appContext.group> ${project.groupId} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${project.artifactId} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${project.version} </vulas.core.appContext.version> </properties> <build> <plugins> <plugin> <groupId> com.sap.research.security.vulas </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.core.app.sourceDir> ${project.build.directory}/classes,${project.basedir}/src/main/java,${project.basedir}/src/main/python </vulas.core.app.sourceDir> <!-- vulas:instr : Instruments JAR/WAR files found in source dir, and writes to target dir. Files in include dir are put into /WEB-INF/lib of output WARs. Files in lib dir are part of the class path when instrumenting. --> <vulas.core.instr.sourceDir> ${project.build.directory} </vulas.core.instr.sourceDir> <vulas.core.instr.targetDir> ${project.build.directory}/vulas/target </vulas.core.instr.targetDir> <vulas.core.instr.includeDir> ${project.build.directory}/vulas/include </vulas.core.instr.includeDir> <vulas.core.instr.libDir> ${project.build.directory}/vulas/lib </vulas.core.instr.libDir> <vulas.core.instr.writeCode> false </vulas.core.instr.writeCode> <vulas.core.instr.instrumentorsChoosen> com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor </vulas.core.instr.instrumentorsChoosen> <vulas.core.instr.searchRecursive> false </vulas.core.instr.searchRecursive> <vulas.core.monitor.periodicUpload.enabled> false </vulas.core.monitor.periodicUpload.enabled> <vulas.core.instr.maxStacktraces> 10 </vulas.core.instr.maxStacktraces> <!-- vulas:a2c/t2c : Performs static call graph analysis --> <vulas.reach.wala.callgraph.reflection> NO_FLOW_TO_CASTS_NO_METHOD_INVOKE </vulas.reach.wala.callgraph.reflection> <vulas.reach.timeout> 60 </vulas.reach.timeout> <!-- vulas:report --> <vulas.report.exceptionExcludeBugs></vulas.report.exceptionExcludeBugs> <vulas.report.reportDir> ${project.build.directory}/vulas/report </vulas.report.reportDir> </layeredConfiguration> </configuration> </plugin> </plugins> </build> </profile>","title":"Vulas profile"},{"location":"vuln_db/","text":"Vulnerability database \u00b6 The vulnerability database comprises code-level information about publicly disclosed vulnerabilities in open source projects, which is the fuel of the code-centric analysis performed by vulnerability-assessment-tool . The tool is able to detect and assess all and only the vulnerabilities present in this PostgreSQL database. The code-level information is gathered by analyzing the commits that the open source developers submitted in order to fix the respective vulnerability (the so-called fix commit). The results of this analysis comprise, for instance, the unique names and abstract syntax trees of all methods or functions modified in the respective fix-commits. The fix commits for hundreds of vulnerabilities in Java and Python open source projects are available in a dedicated GitHub repository called vulnerability assessment knowledge base . Step by step tutorial Here you can find the steps to populate your vulnerability database with five known vulnerabilities. Of course, you can exercise the tutorial for all the other vulnerabilities of the vulnerability assessment knowledge base as well. Go to the Tutorials page Manual Here you can find a description of the main activities and tools around the vulnerability database. Go to the Vulnerability Database Manual Contribute Here you can find information about how to contribute new publicly disclosed vulnerabilities to the knowledge base Go to the Contribute page Orange Hourglass Whenever an application library contains the signature of a construct that was changed to fix a vulnerability, but the patch lib analyzer didn't yet (or could not) establish whether it contains the vulnerable or fixed version of the construct, then the tool reports the vulnerability in the web frontend with an ORANGE hourglass in the column \"Inclusion of vulnerable code\". To resolve orange hourglasses it's necessary to feed the tool with the information whether the library contains the vulnerable or fixed version of the construct changed in the vulnerability fix. This can be done either manually or automatically with the patch-lib-analyzer (for a subset of cases).","title":"Vulnerability database"},{"location":"vuln_db/#vulnerability-database","text":"The vulnerability database comprises code-level information about publicly disclosed vulnerabilities in open source projects, which is the fuel of the code-centric analysis performed by vulnerability-assessment-tool . The tool is able to detect and assess all and only the vulnerabilities present in this PostgreSQL database. The code-level information is gathered by analyzing the commits that the open source developers submitted in order to fix the respective vulnerability (the so-called fix commit). The results of this analysis comprise, for instance, the unique names and abstract syntax trees of all methods or functions modified in the respective fix-commits. The fix commits for hundreds of vulnerabilities in Java and Python open source projects are available in a dedicated GitHub repository called vulnerability assessment knowledge base . Step by step tutorial Here you can find the steps to populate your vulnerability database with five known vulnerabilities. Of course, you can exercise the tutorial for all the other vulnerabilities of the vulnerability assessment knowledge base as well. Go to the Tutorials page Manual Here you can find a description of the main activities and tools around the vulnerability database. Go to the Vulnerability Database Manual Contribute Here you can find information about how to contribute new publicly disclosed vulnerabilities to the knowledge base Go to the Contribute page Orange Hourglass Whenever an application library contains the signature of a construct that was changed to fix a vulnerability, but the patch lib analyzer didn't yet (or could not) establish whether it contains the vulnerable or fixed version of the construct, then the tool reports the vulnerability in the web frontend with an ORANGE hourglass in the column \"Inclusion of vulnerable code\". To resolve orange hourglasses it's necessary to feed the tool with the information whether the library contains the vulnerable or fixed version of the construct changed in the vulnerability fix. This can be done either manually or automatically with the patch-lib-analyzer (for a subset of cases).","title":"Vulnerability database"},{"location":"vuln_db/manuals/","text":"Vulnerability Database Manual \u00b6 The code-level vulnerability analysis performed by vulnerability-assessment-tool is based on the so-called change list, which is a set of constructs (e.g., Java methods) changed to fix a given security vulnerability. Vulnerability detection is based on construct containment: a library is affected by a vulnerability if it contains the constructs that were changed to fix a vulnerability. Once a vulnerability's change list has been created and added to the database, every application analyzed in the past is automatically assessed with regard to the new vulnerability. In other words, application owners see immediately whether their application is affected or not, without the need to re-run the analysis. An up-to-date list of all vulnerabilities currently comprised in the database can be obtained using the following link: http://localhost:8033/backend/bugs Detailed information for a given vulnerability can be obtained using the following link, whereby <foo> has to be replaced by the vulnerability identifier: http://localhost:8033/backend/bugs/<foo> The Patch Analyzer module can be used to add vulnerabilities to the knowledge base. In the current implementation, the vulnerability detection is based on the containment of the fully-qualified name of a construct changed to fix a vulnerability in a library. The information whether the library contains the vulnerable or fixed version of the construct is computed asynchronously by the Patch Lib Analyzer .","title":"Intro"},{"location":"vuln_db/manuals/#vulnerability-database-manual","text":"The code-level vulnerability analysis performed by vulnerability-assessment-tool is based on the so-called change list, which is a set of constructs (e.g., Java methods) changed to fix a given security vulnerability. Vulnerability detection is based on construct containment: a library is affected by a vulnerability if it contains the constructs that were changed to fix a vulnerability. Once a vulnerability's change list has been created and added to the database, every application analyzed in the past is automatically assessed with regard to the new vulnerability. In other words, application owners see immediately whether their application is affected or not, without the need to re-run the analysis. An up-to-date list of all vulnerabilities currently comprised in the database can be obtained using the following link: http://localhost:8033/backend/bugs Detailed information for a given vulnerability can be obtained using the following link, whereby <foo> has to be replaced by the vulnerability identifier: http://localhost:8033/backend/bugs/<foo> The Patch Analyzer module can be used to add vulnerabilities to the knowledge base. In the current implementation, the vulnerability detection is based on the containment of the fully-qualified name of a construct changed to fix a vulnerability in a library. The information whether the library contains the vulnerable or fixed version of the construct is computed asynchronously by the Patch Lib Analyzer .","title":"Vulnerability Database Manual"},{"location":"vuln_db/manuals/manual_assessment/","text":"Manual Assessment \u00b6 The manual assessment can be done from the bugs frontend http://localhost:8033/bugs , by setting the assessment to the appropriate value in the \"Assessment (Manual)\" column and clicking the \"Save\" button. Our recommendation is to always rely on code (manually inspecting it in the worst case) in order to take a decision. The versions indicated in the vulnerability's description were proved wrong in multiple cases. The column \"Patch eval\" shows information about the results (if any) of the patch lib analyzer. By clicking on the cell the results obtained by code comparison for each elements of the bug change list are shown. If available, it is recommended to use them in order to take a decision about the vulnerability of the corresponding library version.","title":"Manual Assessment"},{"location":"vuln_db/manuals/manual_assessment/#manual-assessment","text":"The manual assessment can be done from the bugs frontend http://localhost:8033/bugs , by setting the assessment to the appropriate value in the \"Assessment (Manual)\" column and clicking the \"Save\" button. Our recommendation is to always rely on code (manually inspecting it in the worst case) in order to take a decision. The versions indicated in the vulnerability's description were proved wrong in multiple cases. The column \"Patch eval\" shows information about the results (if any) of the patch lib analyzer. By clicking on the cell the results obtained by code comparison for each elements of the bug change list are shown. If available, it is recommended to use them in order to take a decision about the vulnerability of the corresponding library version.","title":"Manual Assessment"},{"location":"vuln_db/manuals/patch_analyzer/","text":"Patch Analyzer \u00b6 The vulnerability database contains known vulnerabilities for which a fix (aka patch) exists. In fact, the fix (commit fix in the vulnerable library project) of the vulnerability must be provided in order to add a vulnerability to the database. Each vulnerability in the database is characterized by the set of program constructs that were changed in order to fix it. Program Construct A program construct (or simply construct) is a structural element of the source code characterized by a type (e.g., package , class , constructor , method ), a language (e.g., Java, Python), and a unique identifier (e.g., the fully-qualified name). Construct Change A construct change is characterized by a change operation (i.e., addition, deletion or modification) on a construct. In case of modifications the vulnerability database also contains the abstract syntax tree (AST) of the construct before and after the fix, i.e., the AST of the vulnerable and fixed construct. The analysis can be done using the patch-analyzer module. Configuration \u00b6 To add a new vulnerability fixed in a given library repository, the following fields need to be provided as input: bug (-b) <arg> : vulnerability identifier repo (-r) <arg> : URL of the VCS repository hosting the library project revision (-e) <arg> : One or multiple revisions (multiple ones must be comma-separated w/o blanks). In the case of Git repositories, the revision can be optionally concatenated with ':' with the branch information. description (-descr) <arg> : Textual vulnerability description (optional, it must be provided for vulnerabilities not available from the NVD) links (-links) <arg> : Comma-separated list of links to comprehensive vulnerability information (optional, it must be provided for vulnerabilities not available from the NVD) skip-if-existing (-sie) : Skips the analysis of a vulnerability if it already exists in the backend upload (-u) : Upload construct changes Additionally the vulnerability-assessment-tool backend service URL must be configured (see here for instructions). Info In case you want to be sure about the analysis result before uploading it to the backend, you can run the analysis without the -u option so that the resulting JSON will be saved to file for you to review (e.g., to check that the list of construct changes is not empty). The options -descr and -links can be used to add a custom description and/or link url. This is of utmost importance in case the vulnerability is not available in the NVD. Such information can also be provided from the bugs frontend after the bug has been created (both fields must be provided when saving). Critical If a vulnerability fix is applied in multiple repositories, it must be analysed as two separate vulnerabilities with different identifiers. Vulnerabilities without change list \u00b6 In case a vulnerability fix does not include any code change (e.g., only changes configuration parameters), it is still possible to add it to the vulnerability database by manually creating and POSTing the initial JSON. Also the initial affected versions have to be POSTed as JSON and then assessed via the bug frontend, see [Manual Assessments] (../../vuln_db/manual_assessment). The first POST request creates the entry into the vulnerabilities database (in the following example we create and entry for CVE \"S2-043\"): POST http://http://localhost:8033/backend/bugs { \"bugId\" : \"S2-043\" , \"constructChanges\" : [], \"createdBy\" : \"sp\" , \"description\" : \"Usage of the Config Browser in a production environment can lead to exposing vunerable information of the application.\" , \"source\" : \"StrutsSecBulletin\" , \"reference\" : [ \"https://struts.apache.org/docs/s2-043.htm\" ] } The second POST request defines which versions to be marked as affected or not. Please notice that the id of the CVE to update (\"S2-403\" in the following example) has to be used/replaced in the following POST request. POST http://http://localhost:8033/backend/bugs/S2-043/affectedLibIds?source=MANUAL [ { \"libraryId\" :{ \"artifact\" : \"struts2-core\" , \"version\" : \"2.0.11\" , \"group\" : \"org.apache.struts\" }, \"lib\" : null , \"affectedcc\" : [], \"source\" : \"MANUAL\" , \"affected\" : true } ] Vulnerabilities of proprietary libraries \u00b6 The vulnerability Database can also handle undisclosed vulnerabilities and proprietary components. This allows to make company-internal users of proprietary libraries aware and update to non-vulnerable versions. The required elements for the creation are: Brief description of the vulnerability (max 2-3 lines) using the NVD vulnerability description style and phrasing (e.g. including the type of vulnerability, the affected software component). URL of the code repository of the affected component. Commit(s) used to the fix the vulnerability in the component. Links with additional information about the vulnerability (if available).","title":"Patch Analyzer"},{"location":"vuln_db/manuals/patch_analyzer/#patch-analyzer","text":"The vulnerability database contains known vulnerabilities for which a fix (aka patch) exists. In fact, the fix (commit fix in the vulnerable library project) of the vulnerability must be provided in order to add a vulnerability to the database. Each vulnerability in the database is characterized by the set of program constructs that were changed in order to fix it. Program Construct A program construct (or simply construct) is a structural element of the source code characterized by a type (e.g., package , class , constructor , method ), a language (e.g., Java, Python), and a unique identifier (e.g., the fully-qualified name). Construct Change A construct change is characterized by a change operation (i.e., addition, deletion or modification) on a construct. In case of modifications the vulnerability database also contains the abstract syntax tree (AST) of the construct before and after the fix, i.e., the AST of the vulnerable and fixed construct. The analysis can be done using the patch-analyzer module.","title":"Patch Analyzer"},{"location":"vuln_db/manuals/patch_analyzer/#configuration","text":"To add a new vulnerability fixed in a given library repository, the following fields need to be provided as input: bug (-b) <arg> : vulnerability identifier repo (-r) <arg> : URL of the VCS repository hosting the library project revision (-e) <arg> : One or multiple revisions (multiple ones must be comma-separated w/o blanks). In the case of Git repositories, the revision can be optionally concatenated with ':' with the branch information. description (-descr) <arg> : Textual vulnerability description (optional, it must be provided for vulnerabilities not available from the NVD) links (-links) <arg> : Comma-separated list of links to comprehensive vulnerability information (optional, it must be provided for vulnerabilities not available from the NVD) skip-if-existing (-sie) : Skips the analysis of a vulnerability if it already exists in the backend upload (-u) : Upload construct changes Additionally the vulnerability-assessment-tool backend service URL must be configured (see here for instructions). Info In case you want to be sure about the analysis result before uploading it to the backend, you can run the analysis without the -u option so that the resulting JSON will be saved to file for you to review (e.g., to check that the list of construct changes is not empty). The options -descr and -links can be used to add a custom description and/or link url. This is of utmost importance in case the vulnerability is not available in the NVD. Such information can also be provided from the bugs frontend after the bug has been created (both fields must be provided when saving). Critical If a vulnerability fix is applied in multiple repositories, it must be analysed as two separate vulnerabilities with different identifiers.","title":"Configuration"},{"location":"vuln_db/manuals/patch_analyzer/#vulnerabilities-without-change-list","text":"In case a vulnerability fix does not include any code change (e.g., only changes configuration parameters), it is still possible to add it to the vulnerability database by manually creating and POSTing the initial JSON. Also the initial affected versions have to be POSTed as JSON and then assessed via the bug frontend, see [Manual Assessments] (../../vuln_db/manual_assessment). The first POST request creates the entry into the vulnerabilities database (in the following example we create and entry for CVE \"S2-043\"): POST http://http://localhost:8033/backend/bugs { \"bugId\" : \"S2-043\" , \"constructChanges\" : [], \"createdBy\" : \"sp\" , \"description\" : \"Usage of the Config Browser in a production environment can lead to exposing vunerable information of the application.\" , \"source\" : \"StrutsSecBulletin\" , \"reference\" : [ \"https://struts.apache.org/docs/s2-043.htm\" ] } The second POST request defines which versions to be marked as affected or not. Please notice that the id of the CVE to update (\"S2-403\" in the following example) has to be used/replaced in the following POST request. POST http://http://localhost:8033/backend/bugs/S2-043/affectedLibIds?source=MANUAL [ { \"libraryId\" :{ \"artifact\" : \"struts2-core\" , \"version\" : \"2.0.11\" , \"group\" : \"org.apache.struts\" }, \"lib\" : null , \"affectedcc\" : [], \"source\" : \"MANUAL\" , \"affected\" : true } ]","title":"Vulnerabilities without change list"},{"location":"vuln_db/manuals/patch_analyzer/#vulnerabilities-of-proprietary-libraries","text":"The vulnerability Database can also handle undisclosed vulnerabilities and proprietary components. This allows to make company-internal users of proprietary libraries aware and update to non-vulnerable versions. The required elements for the creation are: Brief description of the vulnerability (max 2-3 lines) using the NVD vulnerability description style and phrasing (e.g. including the type of vulnerability, the affected software component). URL of the code repository of the affected component. Commit(s) used to the fix the vulnerability in the component. Links with additional information about the vulnerability (if available).","title":"Vulnerabilities of proprietary libraries"},{"location":"vuln_db/manuals/patch_lib_analyzer/","text":"Patch Library Analyzer \u00b6 The patch library analyzer is a Java application that establishes whether a library contains a construct modified to fix a vulnerability (aka changed-construct) in its vulnerable or fixed version. The core idea of the patch lib analyzer is to compare the abstract syntax tree (AST) of the body of the changed-construct contained in a library with the AST of its vulnerable and fixed version. However, the biggest obstacle is that vulnerability fixes are applied on source code whereas library releases imported within applications are binaries. The patch lib analyzer overcomes this issue by retrieving the source code of binaries (if available) from Maven repositories (e.g. Maven Central or organization's specific Nexus repositories). Warning The current implementation only assesses libraries having a GAV known to Maven Central or configured Nexus repositories. The assessment of python artifacts available in Pypi will soon be covered. If the sources of a given library are available, the patch lib analyzer compares the ASTs of the changed-constructs with the AST of their vulnerable and fixed version. Once equalities are found in source code, they are also used to conclude--wherever possible--for cases where the source code is not available or equalities are not found. The patch lib analyzer may conclude that a library is fixed or vulnerable based on the following criteria: AST EQUALITY vulnerable: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct before it was modified to fix the vulnerability (and none is equal to the fixed version) fixed: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct after it was modified to fix the vulnerability (and none is equal to the vulnerable version) MINOR EQUALITY : The library version is minor of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to vulnerable MAJOR EQUALITY : The library version is major of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to fixed INTERSECTION vulnerable: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct before it was modified to fix the vulnerability than to the one after the change fixed: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct after it was modified to fix the vulnerability than to the one before the change GREATER RELEASE : the library is in a minor release which was released after the most recent fix of the vulnerability. E.g., 3.4.0 release on Jan 2017 is a greater release for bug CVE-2016-1234 if its latest fix was applied on release 3.3.y before 2016, Dec 31 st . Even in cases where the automated approach cannot conclude, the data computed over the libraries are stored in the vulnerability-assessment-tool backend under the source TO_REVIEW . The key data used to assess the libraries and always available for review are: sourceAvailable : whether the sources for the library are available in external repositories construct in jar : whether a construct changed to fix a vulnerability is part of the library archive (Jar) dTv (distance to vulnerable): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct before the fix (computer with ChangeDistiller) dTf (distance to fixed): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct after the fix (computer with ChangeDistiller) The results are visible in the column \"Patch eval\" of the bugs frontend. Clicking on the cell, all the information computed (based on which the assessment result was taken - if any) are available. Usage \u00b6 The patch lib analyzer can be run as a periodic job or a single run. Configuration: j (-jib) : Run patch Eval as cron job (optional) h (-hour) <arg> : Delay for starting the job (hours) (optional, only relevant if -job is specified, Default: 0 ) p (-period) <arg> : The period between successive executions (in hours) (optional, only relevant if -job is specified, Default: 6) bug (-bug) : Comma separated list of bugs to analyze (optional, all bugs analyzed if config not provided) f (-toFile) : Save JSON results to file; otherwise upload to backend (optional, default: false) o (-overrideResults) : Delete all existing results before upload; otherwise only upload results for AffectedLibraries not already existing in the backend (optional, default: false) Other useful/required configurations: vulas.shared.cia.serviceUrl : url of the deployed rest-lib-util service (Mandatory) vulas.shared.backend.serviceUrl : Url of the deployed rest-backend service (Mandatory) vulas.patchEval.uploadResults : whether to upload the results to vulas.shared.backend.serviceUrl or save the JSON to file (equivalent to -file ) vulas.patchEval.onlyAddNewResults : only upload results for AffectedLibraries not already existing in the backend; otherwise all existing results are deleted before the upload (equivalent to -overrideResults ) vulas.patchEval.basefolder : filesystem path where to save and look for the csv files with the computed data per library vulas.patchEval.bugId : comma separated list of bug identifiers to analyze (equivalent to -bug ) Run as cron job java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -j -p 6 -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.1.6-jar-with-dependencies.jar Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.1.6-jar-with-dependencies.jar Run for CVE-2018-1111,CVE-2018-2222 java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = CVE-2018-1111,CVE-2018-2222 -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.1.6-jar-with-dependencies.jar","title":"Patch Lib Analyzer"},{"location":"vuln_db/manuals/patch_lib_analyzer/#patch-library-analyzer","text":"The patch library analyzer is a Java application that establishes whether a library contains a construct modified to fix a vulnerability (aka changed-construct) in its vulnerable or fixed version. The core idea of the patch lib analyzer is to compare the abstract syntax tree (AST) of the body of the changed-construct contained in a library with the AST of its vulnerable and fixed version. However, the biggest obstacle is that vulnerability fixes are applied on source code whereas library releases imported within applications are binaries. The patch lib analyzer overcomes this issue by retrieving the source code of binaries (if available) from Maven repositories (e.g. Maven Central or organization's specific Nexus repositories). Warning The current implementation only assesses libraries having a GAV known to Maven Central or configured Nexus repositories. The assessment of python artifacts available in Pypi will soon be covered. If the sources of a given library are available, the patch lib analyzer compares the ASTs of the changed-constructs with the AST of their vulnerable and fixed version. Once equalities are found in source code, they are also used to conclude--wherever possible--for cases where the source code is not available or equalities are not found. The patch lib analyzer may conclude that a library is fixed or vulnerable based on the following criteria: AST EQUALITY vulnerable: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct before it was modified to fix the vulnerability (and none is equal to the fixed version) fixed: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct after it was modified to fix the vulnerability (and none is equal to the vulnerable version) MINOR EQUALITY : The library version is minor of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to vulnerable MAJOR EQUALITY : The library version is major of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to fixed INTERSECTION vulnerable: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct before it was modified to fix the vulnerability than to the one after the change fixed: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct after it was modified to fix the vulnerability than to the one before the change GREATER RELEASE : the library is in a minor release which was released after the most recent fix of the vulnerability. E.g., 3.4.0 release on Jan 2017 is a greater release for bug CVE-2016-1234 if its latest fix was applied on release 3.3.y before 2016, Dec 31 st . Even in cases where the automated approach cannot conclude, the data computed over the libraries are stored in the vulnerability-assessment-tool backend under the source TO_REVIEW . The key data used to assess the libraries and always available for review are: sourceAvailable : whether the sources for the library are available in external repositories construct in jar : whether a construct changed to fix a vulnerability is part of the library archive (Jar) dTv (distance to vulnerable): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct before the fix (computer with ChangeDistiller) dTf (distance to fixed): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct after the fix (computer with ChangeDistiller) The results are visible in the column \"Patch eval\" of the bugs frontend. Clicking on the cell, all the information computed (based on which the assessment result was taken - if any) are available.","title":"Patch Library Analyzer"},{"location":"vuln_db/manuals/patch_lib_analyzer/#usage","text":"The patch lib analyzer can be run as a periodic job or a single run. Configuration: j (-jib) : Run patch Eval as cron job (optional) h (-hour) <arg> : Delay for starting the job (hours) (optional, only relevant if -job is specified, Default: 0 ) p (-period) <arg> : The period between successive executions (in hours) (optional, only relevant if -job is specified, Default: 6) bug (-bug) : Comma separated list of bugs to analyze (optional, all bugs analyzed if config not provided) f (-toFile) : Save JSON results to file; otherwise upload to backend (optional, default: false) o (-overrideResults) : Delete all existing results before upload; otherwise only upload results for AffectedLibraries not already existing in the backend (optional, default: false) Other useful/required configurations: vulas.shared.cia.serviceUrl : url of the deployed rest-lib-util service (Mandatory) vulas.shared.backend.serviceUrl : Url of the deployed rest-backend service (Mandatory) vulas.patchEval.uploadResults : whether to upload the results to vulas.shared.backend.serviceUrl or save the JSON to file (equivalent to -file ) vulas.patchEval.onlyAddNewResults : only upload results for AffectedLibraries not already existing in the backend; otherwise all existing results are deleted before the upload (equivalent to -overrideResults ) vulas.patchEval.basefolder : filesystem path where to save and look for the csv files with the computed data per library vulas.patchEval.bugId : comma separated list of bug identifiers to analyze (equivalent to -bug ) Run as cron job java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -j -p 6 -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.1.6-jar-with-dependencies.jar Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.1.6-jar-with-dependencies.jar Run for CVE-2018-1111,CVE-2018-2222 java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = CVE-2018-1111,CVE-2018-2222 -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.1.6-jar-with-dependencies.jar","title":"Usage"},{"location":"vuln_db/tutorials/vuln_db_tutorial/","text":"Getting started with the Vulnerability Database \u00b6 Vulnerabilities in vulnerability-assessment-tool are represented at code level. This tutorial will guide you through the creation of the following vulnerabilities in the vulnerability database: CVE-2017-7525 (Jackson Databind) CVE-2018-5382 (BouncyCastle) CVE-2018-11039 (Spring) CVE-2014-0050 (Apache Commons FileUpload) COLLECTIONS-580 (Apache Commons Collections) The tutorial also explains how to consume the import script available in the knowledge base . Such script triggers the analysis of the available vulnerabilities. If you have a working installation of the vulnerability-assessment-tool backend services you will need to import vulnerability data before you can actually perform scans. Installing the vulnerability-assessment-tool backend services Instructions on how to setup backend services are available here . It is possible to add new vulnerabilities to the database using the patch-analyzer module of the vulnerability-assessment-tool project. Patch Analyzer \u00b6 Creation of above-listed vulnerabilities \u00b6 Run the following commands to create the change list for the vulnerability and upload it to the backend java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/FasterXML/jackson-databind -b CVE-2017-7525 -e e8f043d1aac9b82eee907e0f0c3abbdea723a935,ddfddfba6414adbecaff99684ef66eebd3a92e92,60d459cedcf079c6106ae7da2ac562bc32dcabe1 -links https://github.com/FasterXML/jackson-databind/issues/1599,https://github.com/FasterXML/jackson-databind/issues/1680,https://github.com/FasterXML/jackson-databind/issues/1737 -descr \"When configured to enable default typing, Jackson contained a deserialization vulnerability that could lead to arbitrary code execution. Jackson fixed this vulnerability by blacklisting known 'deserialization gadgets'. This vulnerability solves an incomplete fix for CVE-2017-4995-JK (main description at: https://github.com/FasterXML/jackson-databind/issues/1599 Issues not addressed by the incomplete fix of CVE-2017-4995-JK: https://github.com/FasterXML/jackson-databind/issues/1680 and https://github.com/FasterXML/jackson-databind/issues/1737) \" -u java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/bcgit/bc-java/ -b CVE-2018-5382 -e 81b00861cd5711e85fe8dce2a0e119f684120255 -links https://snyk.io/vuln/SNYK-JAVA-ORGBOUNCYCASTLE-31659,https://www.kb.cert.org/vuls/id/306792 -u java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.patcha.PatchAnalyzer -r https://github.com/spring-projects/spring-framework/ -b CVE-2018-11039 -e dac97f1b7dac3e70ff603fb6fc9f205b95dd6b01,f2694a8ed93f1f63f87ce45d0bb638478b426acd -links https://pivotal.io/security/cve-2018-11039,https://jira.spring.io/browse/SPR-16836 -descr \"Cross Site Tracing (XST) with Spring Framework. Description: Spring Framework (versions 5.0.x prior to 5.0.7, versions 4.3.x prior to 4.3.18, and older unsupported versions) allow web applications to change the HTTP request method to any HTTP method (including TRACE) using the HiddenHttpMethodFilter in Spring MVC. If an application has a pre-existing XSS vulnerability, a malicious user (or attacker) can use this filter to escalate to an XST (Cross Site Tracing) attack. Affected Pivotal Products and Versions: Spring Framework 5.0 to 5.0.6, Spring Framework 4.3 to 4.3.17, Older unsupported versions are also affected. Mitigation: Users of affected versions should apply the following mitigation: \\n 5.0.x users should upgrade to 5.0.7. \\n- 4.3.x users should upgrade to 4.3.18. - Older versions should upgrade to a supported branch. \\nThere are no other mitigation steps necessary. This attack applies to applications that: \\n1/ Use the HiddenHttpMethodFilter (it is enabled by default in Spring Boot). \\n2/ Allow HTTP TRACE requests to be handled by the application server. \\nThis attack is not exploitable directly because an attacker would have to make a cross-domain request via HTTP POST, which is forbidden by the Same Origin Policy. This is why a pre-existing XSS (Cross Site Scripting) vulnerability in the web application itself is necessary to enable an escalation to XST.\" -u java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/apache/commons-fileupload -b CVE-2014-0050 -e c61ff05b3241cb14d989b67209e57aa71540417a -u java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/apache/commons-collections -b COLLECTIONS-580 -e 3eee44cf63b1ebb0da6925e98b3dcc6ef1e4d610,78d47d4d098ab814a7a00a0b1c81646b27f050cf,e585cd0433ae4cfbc56e58572b9869bd0c86b611,b2b8f4adc557e4ef1ee2fe5e0ab46866c06ec55b,da1a5fe00d79e1840b7e52317933e9eb56e88246,1642b00d67b96de87cad44223efb9ab5b4fb7be5:3_2_X,5ec476b0b756852db865b2e442180f091f8209ee:3_2_X,bce4d022f27a723fa0e0b7484dcbf0afa2dd210a:3_2_X,d9a00134f16d685bea11b2b12de824845e6473e3:3_2_X -descr \"Arbitrary remote code execution with InvokerTransformer. With InvokerTransformer serializable collections can be build that execute arbitrary Java code. sun.reflect.annotation.AnnotationInvocationHandler#readObject invokes #entrySet and #get on a deserialized collection. If you have an endpoint that accepts serialized Java objects (JMX, RMI, remote EJB, ...) you can combine the two to create arbitrary remote code execution vulnerability. Fixed in versions 3.2.2, 4.1\" -links https://issues.apache.org/jira/browse/COLLECTIONS-580,https://commons.apache.org/proper/commons-collections/security-reports.html -u To run such commands in your own environment, you may need to adapt: the path to the patch analyzer artifact and the artifact version, -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar the URL of the vulnerability-assessment-tool backend, -Dvulas.shared.backend.serviceUrl=http://localhost:8033/backend/ the proxy settings; the proxy is not configured in the example but you can do so using the following configurations: -Dhttp.proxyHost = -Dhttp.proxyPort = -Dhttps.proxyHost = -Dhttps.proxyPort = -Dhttp.nonProxyHosts = Batch Import from Knowledge Base \u00b6 To run the batch import you need to : Download the script \"import_vulas_kb.sh\" from the knowledge base Move it to the same folder where the patch-analyzer built artifact is available (Note that the artifact must be named patch-analyzer-jar-with-dependencies.jar ) Run the following command providing as argument the url of the backend bash import_vulas_kb.sh http://localhost:8033/backend/ Info The patch-analyzer artifact can be found in the /target folder of the patch-analyzer module after building the project with maven, or in the docker/client-tools folder as a result of the build described here . In both cases the file needs to be renamed by removing the version information into patch-analyzer-jar-with-dependencies.jar . Patch Lib Analyzer \u00b6 Once vulnerabilities are created in the vulnerability database, the patch lib analyzer must run periodically to assess whether all versions of the library known by the backend contain the vulnerable or fixed version of the construct. Info To get the best of the tutorial, we recommend to proceed to the next step only after having analyzed at least one application (see tutorial page ). Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.1.6-jar-with-dependencies.jar To check how to run it as a job, check here Info In case the application results still shows orange hourglasses after running the patch lib analyser, the manual assessment is required, see here","title":"Tutorial"},{"location":"vuln_db/tutorials/vuln_db_tutorial/#getting-started-with-the-vulnerability-database","text":"Vulnerabilities in vulnerability-assessment-tool are represented at code level. This tutorial will guide you through the creation of the following vulnerabilities in the vulnerability database: CVE-2017-7525 (Jackson Databind) CVE-2018-5382 (BouncyCastle) CVE-2018-11039 (Spring) CVE-2014-0050 (Apache Commons FileUpload) COLLECTIONS-580 (Apache Commons Collections) The tutorial also explains how to consume the import script available in the knowledge base . Such script triggers the analysis of the available vulnerabilities. If you have a working installation of the vulnerability-assessment-tool backend services you will need to import vulnerability data before you can actually perform scans. Installing the vulnerability-assessment-tool backend services Instructions on how to setup backend services are available here . It is possible to add new vulnerabilities to the database using the patch-analyzer module of the vulnerability-assessment-tool project.","title":"Getting started with the Vulnerability Database"},{"location":"vuln_db/tutorials/vuln_db_tutorial/#patch-analyzer","text":"","title":"Patch Analyzer"},{"location":"vuln_db/tutorials/vuln_db_tutorial/#creation-of-above-listed-vulnerabilities","text":"Run the following commands to create the change list for the vulnerability and upload it to the backend java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/FasterXML/jackson-databind -b CVE-2017-7525 -e e8f043d1aac9b82eee907e0f0c3abbdea723a935,ddfddfba6414adbecaff99684ef66eebd3a92e92,60d459cedcf079c6106ae7da2ac562bc32dcabe1 -links https://github.com/FasterXML/jackson-databind/issues/1599,https://github.com/FasterXML/jackson-databind/issues/1680,https://github.com/FasterXML/jackson-databind/issues/1737 -descr \"When configured to enable default typing, Jackson contained a deserialization vulnerability that could lead to arbitrary code execution. Jackson fixed this vulnerability by blacklisting known 'deserialization gadgets'. This vulnerability solves an incomplete fix for CVE-2017-4995-JK (main description at: https://github.com/FasterXML/jackson-databind/issues/1599 Issues not addressed by the incomplete fix of CVE-2017-4995-JK: https://github.com/FasterXML/jackson-databind/issues/1680 and https://github.com/FasterXML/jackson-databind/issues/1737) \" -u java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/bcgit/bc-java/ -b CVE-2018-5382 -e 81b00861cd5711e85fe8dce2a0e119f684120255 -links https://snyk.io/vuln/SNYK-JAVA-ORGBOUNCYCASTLE-31659,https://www.kb.cert.org/vuls/id/306792 -u java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.patcha.PatchAnalyzer -r https://github.com/spring-projects/spring-framework/ -b CVE-2018-11039 -e dac97f1b7dac3e70ff603fb6fc9f205b95dd6b01,f2694a8ed93f1f63f87ce45d0bb638478b426acd -links https://pivotal.io/security/cve-2018-11039,https://jira.spring.io/browse/SPR-16836 -descr \"Cross Site Tracing (XST) with Spring Framework. Description: Spring Framework (versions 5.0.x prior to 5.0.7, versions 4.3.x prior to 4.3.18, and older unsupported versions) allow web applications to change the HTTP request method to any HTTP method (including TRACE) using the HiddenHttpMethodFilter in Spring MVC. If an application has a pre-existing XSS vulnerability, a malicious user (or attacker) can use this filter to escalate to an XST (Cross Site Tracing) attack. Affected Pivotal Products and Versions: Spring Framework 5.0 to 5.0.6, Spring Framework 4.3 to 4.3.17, Older unsupported versions are also affected. Mitigation: Users of affected versions should apply the following mitigation: \\n 5.0.x users should upgrade to 5.0.7. \\n- 4.3.x users should upgrade to 4.3.18. - Older versions should upgrade to a supported branch. \\nThere are no other mitigation steps necessary. This attack applies to applications that: \\n1/ Use the HiddenHttpMethodFilter (it is enabled by default in Spring Boot). \\n2/ Allow HTTP TRACE requests to be handled by the application server. \\nThis attack is not exploitable directly because an attacker would have to make a cross-domain request via HTTP POST, which is forbidden by the Same Origin Policy. This is why a pre-existing XSS (Cross Site Scripting) vulnerability in the web application itself is necessary to enable an escalation to XST.\" -u java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/apache/commons-fileupload -b CVE-2014-0050 -e c61ff05b3241cb14d989b67209e57aa71540417a -u java -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/ -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar com.sap.psr.vulas.PatchAnalyzer -r https://github.com/apache/commons-collections -b COLLECTIONS-580 -e 3eee44cf63b1ebb0da6925e98b3dcc6ef1e4d610,78d47d4d098ab814a7a00a0b1c81646b27f050cf,e585cd0433ae4cfbc56e58572b9869bd0c86b611,b2b8f4adc557e4ef1ee2fe5e0ab46866c06ec55b,da1a5fe00d79e1840b7e52317933e9eb56e88246,1642b00d67b96de87cad44223efb9ab5b4fb7be5:3_2_X,5ec476b0b756852db865b2e442180f091f8209ee:3_2_X,bce4d022f27a723fa0e0b7484dcbf0afa2dd210a:3_2_X,d9a00134f16d685bea11b2b12de824845e6473e3:3_2_X -descr \"Arbitrary remote code execution with InvokerTransformer. With InvokerTransformer serializable collections can be build that execute arbitrary Java code. sun.reflect.annotation.AnnotationInvocationHandler#readObject invokes #entrySet and #get on a deserialized collection. If you have an endpoint that accepts serialized Java objects (JMX, RMI, remote EJB, ...) you can combine the two to create arbitrary remote code execution vulnerability. Fixed in versions 3.2.2, 4.1\" -links https://issues.apache.org/jira/browse/COLLECTIONS-580,https://commons.apache.org/proper/commons-collections/security-reports.html -u To run such commands in your own environment, you may need to adapt: the path to the patch analyzer artifact and the artifact version, -jar ./patch-analyzer/target/patch-analyzer-3.1.6-jar-with-dependencies.jar the URL of the vulnerability-assessment-tool backend, -Dvulas.shared.backend.serviceUrl=http://localhost:8033/backend/ the proxy settings; the proxy is not configured in the example but you can do so using the following configurations: -Dhttp.proxyHost = -Dhttp.proxyPort = -Dhttps.proxyHost = -Dhttps.proxyPort = -Dhttp.nonProxyHosts =","title":"Creation of above-listed vulnerabilities"},{"location":"vuln_db/tutorials/vuln_db_tutorial/#batch-import-from-knowledge-base","text":"To run the batch import you need to : Download the script \"import_vulas_kb.sh\" from the knowledge base Move it to the same folder where the patch-analyzer built artifact is available (Note that the artifact must be named patch-analyzer-jar-with-dependencies.jar ) Run the following command providing as argument the url of the backend bash import_vulas_kb.sh http://localhost:8033/backend/ Info The patch-analyzer artifact can be found in the /target folder of the patch-analyzer module after building the project with maven, or in the docker/client-tools folder as a result of the build described here . In both cases the file needs to be renamed by removing the version information into patch-analyzer-jar-with-dependencies.jar .","title":"Batch Import from Knowledge Base"},{"location":"vuln_db/tutorials/vuln_db_tutorial/#patch-lib-analyzer","text":"Once vulnerabilities are created in the vulnerability database, the patch lib analyzer must run periodically to assess whether all versions of the library known by the backend contain the vulnerable or fixed version of the construct. Info To get the best of the tutorial, we recommend to proceed to the next step only after having analyzed at least one application (see tutorial page ). Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.1.6-jar-with-dependencies.jar To check how to run it as a job, check here Info In case the application results still shows orange hourglasses after running the patch lib analyser, the manual assessment is required, see here","title":"Patch Lib Analyzer"}]}